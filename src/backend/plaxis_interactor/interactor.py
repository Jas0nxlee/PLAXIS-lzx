"""
Main orchestrator for interacting with PLAXIS.

This module, PlaxisInteractor, is responsible for managing the connection to
PLAXIS (both Input and Output servers), executing commands generated by
builder modules (geometry, soil, calculation), running PLAXIS operations
(either via API or CLI scripts), and coordinating the extraction of results
via parser modules. It also handles mapping PLAXIS-specific exceptions to
custom, more informative application exceptions.

PRD Ref: Tasks 3.7 (PLAXIS Process Execution & Monitoring), 3.9 (Error Mapping)
"""
import os
import re
import logging
from typing import List, Dict, Any, Optional, Callable, Tuple
import subprocess
import time # For potential timeouts or delays if ever needed

from ..exceptions import (
    PlaxisAutomationError, PlaxisConnectionError, PlaxisConfigurationError,
    PlaxisCalculationError, PlaxisOutputError, PlaxisCliError
)
from ..models import ProjectSettings # For type hinting project_settings

logger = logging.getLogger(__name__)

# --- Dynamic Imports for Optional Dependencies ---
try:
    from PySide6.QtCore import QObject, Signal
except ImportError:
    logger.warning("PySide6.QtCore not found. Using dummy QObject and Signal for PlaxisInteractor.InteractorSignals. This is expected for backend-only tests or non-GUI environments.")
    class QObject: # type: ignore
        """Dummy QObject if PySide6 is not available."""
        def __init__(self, parent: Optional[Any] = None): pass

    class Signal: # type: ignore
        """Dummy Signal if PySide6 is not available."""
        def __init__(self, *args: Any, **kwargs: Any): pass
        def emit(self, *args: Any, **kwargs: Any) -> None: pass
        def connect(self, slot: Callable[..., Any]) -> None: pass # type: ignore
        def disconnect(self, slot: Callable[..., Any]) -> None: pass # type: ignore

try:
    from plxscripting.easy import new_server
    from plxscripting.plx_scripting_exceptions import PlxScriptingError
except ImportError:
    logger.warning("plxscripting library not found. PlaxisInteractor will not be able to connect to PLAXIS API.")
    class PlxScriptingError(Exception): # type: ignore
        """Placeholder for PlxScriptingError if plxscripting library is not available."""
        pass
    def new_server(host: str, port: int, password: str) -> Tuple[Any, Any]: # type: ignore
        """Placeholder for new_server if plxscripting library is not available."""
        raise PlaxisConnectionError("plxscripting library not available, cannot create new_server.")

# These are imported at method level to avoid circular dependencies if models use this module indirectly
# from ..models import ProjectSettings, AnalysisResults
# from . import geometry_builder, soil_builder, calculation_builder, results_parser


def _map_plaxis_sdk_exception_to_custom(e: Exception, context: str = "PLAXIS operation") -> PlaxisAutomationError:
    """
    Maps a Python or PlxScripting exception to a custom PlaxisAutomationError.

    This function attempts to categorize common error messages from PLAXIS
    into more specific custom exception types for better error handling
    and user feedback.

    Args:
        e: The original exception caught.
        context: A string describing the operation during which the error occurred.

    Returns:
        A PlaxisAutomationError (or one of its subtypes) wrapping the original error.
    """
    logger.debug(f"Mapping SDK error: {type(e).__name__} - {e} in context: {context}", exc_info=True)

    if isinstance(e, PlaxisAutomationError): # If already one of ours, pass through
        return e

    err_str = str(e).lower()
    # Check if the exception type name is exactly 'PlxScriptingError' to avoid issues if it's a placeholder
    is_plx_scripting_error_type = type(e).__name__ == 'PlxScriptingError'


    if is_plx_scripting_error_type:
        if re.search(r"object\s*.*not found", err_str):
            return PlaxisConfigurationError(f"PLAXIS configuration: Object not found during {context}: {e}")
        elif "connection refused" in err_str or "actively refused it" in err_str or \
             "server not responding" in err_str or "no response from server" in err_str or \
             "cannot connect" in err_str:
            return PlaxisConnectionError(f"PLAXIS API connection issue during {context}: {e}")
        # ... (other PlxScriptingError mappings remain the same) ...
        elif "password incorrect" in err_str or "authentication failed" in err_str:
            return PlaxisConnectionError(f"PLAXIS API authentication failed (password incorrect?) during {context}: {e}")
        elif "unknown identifier" in err_str or \
             "does not exist" in err_str or "property not found" in err_str or \
             "unknown command" in err_str or "command is not recognized" in err_str or \
             "incorrect mode" in err_str or "operation not allowed in current mode" in err_str or \
             "type mismatch" in err_str or "incorrect type" in err_str or \
             "index out of range" in err_str or ("is not valid" in err_str and "index" in err_str):
            return PlaxisConfigurationError(f"PLAXIS model/API configuration error during {context}: {e}")
        elif "calculation failed" in err_str or "convergence not reached" in err_str or \
             "did not converge" in err_str or "numerical error" in err_str or \
             "singular matrix" in err_str or "matrix is not positive definite" in err_str or \
             "soil body seems to collapse" in err_str or "mechanism formed" in err_str or \
             "error code 101" in err_str or "error code 25" in err_str or \
             "accuracy condition not met" in err_str or "load increment reduced to zero" in err_str or \
             "calculation aborted" in err_str or "calculation has been aborted" in err_str:
            return PlaxisCalculationError(f"PLAXIS calculation error/aborted during {context}: {e}")
        elif "mesh generation failed" in err_str or "error generating mesh" in err_str or \
             "cannot generate mesh for region" in err_str:
            return PlaxisConfigurationError(f"PLAXIS meshing error during {context}: {e}")
        elif "geometric inconsistency" in err_str or "invalid geometry" in err_str:
            return PlaxisConfigurationError(f"PLAXIS geometry error during {context}: {e}")
        elif ("parameter" in err_str and ("missing" in err_str or "invalid" in err_str or "out of range" in err_str)) or \
             "input value is not correct" in err_str or "value is out of range" in err_str:
            param_name_match = re.search(r"parameter\s*['\"]?([^'\"\s]+)['\"]?", err_str)
            param_info = f" for parameter '{param_name_match.group(1)}'" if param_name_match else ""
            return PlaxisConfigurationError(f"Invalid PLAXIS parameter or value{param_info} during {context}: {e}")
        elif "license" in err_str or "dongle" in err_str or "no valid license" in err_str:
            return PlaxisConnectionError(f"PLAXIS license issue during {context}: {e}")
        elif "file not found" in err_str and ".p3dscript" not in err_str: # Avoid matching script file not found for CLI
            return PlaxisConfigurationError(f"PLAXIS project/data file not found during {context}: {e}")
        elif "cannot open file" in err_str or ("access denied" in err_str and "file" in err_str):
            return PlaxisConfigurationError(f"PLAXIS file access error during {context}: {e}")
        elif "disk space" in err_str:
            return PlaxisAutomationError(f"Insufficient disk space for PLAXIS operations during {context}: {e}")
        else: # Default for other PlxScriptingErrors
            return PlaxisAutomationError(f"A PLAXIS scripting error occurred during {context}: {e}")

    # General Python exceptions that might indicate issues with PLAXIS interaction
    elif isinstance(e, AttributeError): # Often due to incorrect API usage or unexpected PLAXIS object state
        return PlaxisConfigurationError(f"AttributeError (API misuse or unexpected PLAXIS object state) during {context}: {e}")
    elif isinstance(e, TypeError): # API called with incorrect type
        return PlaxisConfigurationError(f"TypeError (API called with incorrect type) during {context}: {e}")
    elif isinstance(e, ValueError): # API called with invalid value (not covered by specific parameter checks)
        return PlaxisConfigurationError(f"ValueError (API called with invalid value) during {context}: {e}")
    elif isinstance(e, FileNotFoundError) and ".p3dscript" not in err_str: # For general files, not CLI script itself
        return PlaxisConfigurationError(f"FileNotFoundError for a project/data file during {context}: {e}")
    elif isinstance(e, TimeoutError) or ("timeout" in err_str or "timed out" in err_str): # For operations that might time out
        return PlaxisCalculationError(f"Operation timed out during {context}: {e}")

    # Fallback for any other uncategorized Python errors
    return PlaxisAutomationError(f"An unexpected Python error ({type(e).__name__}) occurred during {context}: {e}")


class PlaxisInteractor:
    """
    Manages interaction with PLAXIS for model setup, calculation, and result extraction.

    This class serves as the primary interface between the application's backend logic
    and the PLAXIS software, using either its Python scripting API or Command Line Interface (CLI).

    Attributes:
        plaxis_path (Optional[str]): Full path to the PLAXIS input executable (e.g., Plaxis3DInput.exe).
                                     Required for CLI operations.
        project_settings (Optional[ProjectSettings]): The current project's settings,
                                                      containing all input data and configurations.
        s_i (Optional[Any]): PLAXIS input server object.
        g_i (Optional[Any]): PLAXIS input global object.
        s_o (Optional[Any]): PLAXIS output server object.
        g_o (Optional[Any]): PLAXIS output global object.
        signals (InteractorSignals): Qt signals for progress and stage updates.
    """
    def __init__(self, plaxis_path: Optional[str] = None, project_settings: Optional[ProjectSettings] = None):
        """
        Initializes the PlaxisInteractor.

        Args:
            plaxis_path: Path to the PLAXIS input executable.
            project_settings: Project settings containing model data and API configurations.
        """
        self.plaxis_path: Optional[str] = plaxis_path
        self.project_settings: Optional[ProjectSettings] = project_settings
        self.s_i: Optional[Any] = None
        self.g_i: Optional[Any] = None
        self.s_o: Optional[Any] = None
        self.g_o: Optional[Any] = None
        self._default_input_port: int = 10000
        self._default_output_port: int = 10001
        self._default_api_password: str = "YOUR_API_PASSWORD"
        self.plaxis_process: Optional[subprocess.Popen] = None

        self.signals = PlaxisInteractor.InteractorSignals()

        logger.info(f"PlaxisInteractor initialized. PLAXIS exe path: {plaxis_path or 'Not specified (API only assumed)'}")

    class InteractorSignals(QObject):
        """Container for Qt signals emitted by PlaxisInteractor to update the UI."""
        analysis_stage_changed = Signal(str)
        progress_updated = Signal(int, int)

    def _get_api_credentials(self) -> Tuple[str, int, int, str]:
        """
        Retrieves API connection credentials (host, ports, password).
        Prioritizes values from `project_settings` if available, otherwise uses defaults.
        """
        host: str = "localhost"
        input_port: int = self._default_input_port
        output_port: int = self._default_output_port
        password: str = self._default_api_password

        if self.project_settings:
            input_port = getattr(self.project_settings, 'plaxis_api_input_port', input_port)
            output_port = getattr(self.project_settings, 'plaxis_api_output_port', output_port)
            # Check if plaxis_api_password attribute exists and is not None before using it
            custom_password = getattr(self.project_settings, 'plaxis_api_password', None)
            if custom_password is not None:
                password = custom_password
            else:
                logger.warning("API password not found or is None in project settings. Using interactor default.")

        if password == "YOUR_API_PASSWORD": # Check against the default placeholder
            logger.critical("Using default PLAXIS API password ('YOUR_API_PASSWORD'). This is insecure and likely incorrect. Configure a proper password in application settings or project file.")
        return host, input_port, output_port, password

    def _connect_to_input_server(self) -> None:
        """
        Connects to the PLAXIS Input API server.
        Raises PlaxisConnectionError or PlaxisConfigurationError on failure.
        """
        if self.g_i and self.s_i: # Check if already connected
            try:
                _ = self.g_i.Project.Title.value # Simple check to see if connection is alive
                logger.info("Input server connection already active.")
                return
            except Exception as e:
                logger.warning(f"Input API connection check failed: {e}. Attempting to reconnect.", exc_info=True)
                self.s_i, self.g_i = None, None # Reset before attempting reconnection

        host, input_port, _, password = self._get_api_credentials()
        logger.info(f"Attempting to connect to PLAXIS Input API on {host}:{input_port}...")
        try:
            self.s_i, self.g_i = new_server(host, input_port, password=password)
            project_title_value = self.g_i.Project.Title.value # Verify connection with a command
            logger.info(f"Successfully connected to PLAXIS Input API. Current project title: '{project_title_value}'.")
        except Exception as e:
            self.s_i, self.g_i = None, None # Ensure state is clean on failure
            raise _map_plaxis_sdk_exception_to_custom(e, f"connecting to Input API ({host}:{input_port})")

    def _connect_to_output_server(self, project_file_to_open: Optional[str] = None) -> None:
        """
        Connects to the PLAXIS Output API server.
        If `project_file_to_open` is provided, it attempts to open that project.

        Args:
            project_file_to_open: Optional path to a .p3dxml or .p2dxml project file to open.

        Raises PlaxisConnectionError or PlaxisConfigurationError on failure.
        """
        if self.g_o and self.s_o: # Check if already connected
            try:
                _ = self.g_o.ResultTypes # Simple check for Output server
                if project_file_to_open and hasattr(self.s_o, 'open'):
                    logger.info(f"Output server already connected. Attempting to (re)open '{project_file_to_open}'.")
                    self.s_o.open(project_file_to_open) # type: ignore
                    logger.info(f"Successfully (re)opened '{project_file_to_open}' in existing output server.")
                else:
                    logger.info("Output server already connected. No new file specified or s_o cannot open files.")
                return
            except Exception as e:
                logger.warning(f"Output API connection check/re-open failed: {e}. Attempting to reconnect.", exc_info=True)
                self.s_o, self.g_o = None, None

        host, _, output_port, password = self._get_api_credentials()
        logger.info(f"Attempting to connect to PLAXIS Output API on {host}:{output_port}...")
        try:
            self.s_o, self.g_o = new_server(host, output_port, password=password)
            _ = self.g_o.ResultTypes # Verify connection
            logger.info(f"Successfully connected to PLAXIS Output API on {host}:{output_port}.")

            if project_file_to_open:
                if not os.path.exists(project_file_to_open):
                    raise PlaxisConfigurationError(f"Project file for output results does not exist: {project_file_to_open}")
                if hasattr(self.s_o, 'open'):
                    logger.info(f"Attempting to open project '{project_file_to_open}' in Output server...")
                    self.s_o.open(project_file_to_open) # type: ignore
                    if not self.g_o.Phases: # Check if project loaded successfully
                        logger.warning(f"Opened '{project_file_to_open}' but no phases found or g_o not updated properly.")
                    else:
                        logger.info(f"Successfully opened '{project_file_to_open}'. Found {len(self.g_o.Phases)} phases.") # type: ignore
                else:
                    logger.warning(f"Output server object (type: {type(self.s_o)}) lacks 'open' method. Cannot open specific project.")
        except Exception as e:
            self.s_o, self.g_o = None, None
            raise _map_plaxis_sdk_exception_to_custom(e, f"connecting/opening project in Output API ({host}:{output_port})")

    def _execute_cli_script(self, commands: List[str], script_filename: str = "temp_plaxis_script.p3dscript") -> None:
        """
        Executes a list of PLAXIS commands via a temporary CLI script.

        Args:
            commands: A list of command strings to write to the script.
            script_filename: The name for the temporary script file.

        Raises:
            PlaxisConfigurationError: If PLAXIS path is not configured.
            PlaxisCliError: If script writing or execution fails.
        """
        if not self.plaxis_path or not os.path.exists(self.plaxis_path) or "Plaxis3DInput.exe" not in os.path.basename(self.plaxis_path) : # Basic check
            raise PlaxisConfigurationError(f"PLAXIS executable path not configured correctly or not found: '{self.plaxis_path}'")

        # Determine script path (e.g., in a temp directory or current working dir)
        # For simplicity, using current working directory here. A temp dir is safer.
        abs_script_path = os.path.abspath(script_filename)
        logger.info(f"Writing {len(commands)} commands to script '{abs_script_path}' for CLI execution.")

        try:
            with open(abs_script_path, 'w') as f:
                for cmd in commands:
                    f.write(cmd + '\n')
        except IOError as e:
            raise PlaxisCliError(f"IOError writing script file '{abs_script_path}': {e}")

        cli_command_parts = [self.plaxis_path, f"--runscript={abs_script_path}"]
        logger.info(f"Executing PLAXIS CLI: \"{' '.join(cli_command_parts)}\"")

        timeout_duration = 3600 # Default 1 hour timeout
        if self.project_settings and hasattr(self.project_settings, 'analysis_control'):
             # Assuming AnalysisControlParameters might have a max_calc_time_seconds like attribute
             timeout_val = getattr(self.project_settings.analysis_control, 'max_overall_calc_time_seconds', None)
             if isinstance(timeout_val, (int, float)) and timeout_val > 0:
                 timeout_duration = timeout_val
        logger.debug(f"CLI execution timeout set to: {timeout_duration} seconds.")

        # Ensure plaxis_path is not None before using it in Popen
        if self.plaxis_path is None: # Should be caught by earlier check, but defensive
            raise PlaxisConfigurationError("PLAXIS executable path is None. Cannot execute CLI script.")

        try:
            self.plaxis_process = subprocess.Popen(
                cli_command_parts,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                creationflags=subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0 # type: ignore
            )
            stdout, stderr = self.plaxis_process.communicate(timeout=timeout_duration)

            if self.plaxis_process.returncode == 0:
                logger.info("PLAXIS script via CLI executed successfully.")
                if stdout: logger.debug(f"PLAXIS CLI STDOUT:\n{stdout}")
                if stderr: logger.warning(f"PLAXIS CLI STDERR (on success, RC=0):\n{stderr}") # Some PLAXIS versions output to stderr even on success
            else:
                error_output = stderr if stderr else stdout # Prefer stderr for error messages
                logger.error(f"PLAXIS script via CLI failed. RC: {self.plaxis_process.returncode}. Output:\n{error_output}")
                raise PlaxisCliError(f"PLAXIS script via CLI failed. RC: {self.plaxis_process.returncode}. Output:\n{error_output}")

        except FileNotFoundError: # If self.plaxis_path is invalid
            raise PlaxisConfigurationError(f"PLAXIS executable not found at '{self.plaxis_path}'. Check path.")
        except subprocess.TimeoutExpired:
            logger.error(f"PLAXIS script execution timed out after {timeout_duration}s.", exc_info=True)
            if self.plaxis_process:
                self.plaxis_process.kill()
                self.plaxis_process.wait() # Ensure process is reaped
            raise PlaxisCalculationError(f"TimeoutExpired: PLAXIS CLI process exceeded {timeout_duration}s.")
        except Exception as e: # Catch other potential Popen errors
            raise PlaxisCliError(f"Unexpected error during PLAXIS CLI execution: {e}")
        finally:
            if os.path.exists(abs_script_path):
                try:
                    os.remove(abs_script_path)
                except OSError as e_remove:
                    logger.warning(f"Could not remove temporary script file '{abs_script_path}': {e_remove}")

    def attempt_stop_calculation(self) -> None:
        """Attempts to stop an ongoing PLAXIS calculation (CLI or API)."""
        logger.info("Attempting to stop PLAXIS calculation...")
        stopped_cli = False
        stopped_api = False

        # Attempt to terminate CLI process if it's running
        if self.plaxis_process and self.plaxis_process.poll() is None: # Check if process exists and is running
            logger.info("Active CLI process found. Attempting to terminate.")
            try:
                self.plaxis_process.terminate() # SIGTERM
                self.plaxis_process.wait(timeout=5) # Wait for graceful termination
                logger.info("CLI process terminated (SIGTERM).")
                stopped_cli = True
            except subprocess.TimeoutExpired:
                logger.warning("CLI process did not terminate after 5s (SIGTERM), attempting kill (SIGKILL).")
                self.plaxis_process.kill() # SIGKILL
                self.plaxis_process.wait() # Ensure it's reaped
                logger.info("CLI process killed (SIGKILL).")
                stopped_cli = True
            except Exception as e: # Other errors during termination
                logger.error(f"Error terminating CLI process: {e}", exc_info=True)

        # Attempt to send breakcalculation via API if g_i is available
        if self.g_i and hasattr(self.g_i, 'breakcalculation'):
            logger.info("Attempting to send breakcalculation command via API (g_i).")
            try:
                self.g_i.breakcalculation()
                logger.info("breakcalculation command sent via API.")
                stopped_api = True
            except Exception as e: # Catch PlxScriptingError or other issues
                logger.warning(f"Failed to send breakcalculation via API: {e}", exc_info=True)

        if not stopped_cli and not stopped_api:
            logger.info("No active CLI process found to stop, or API break command failed/not applicable.")
        elif stopped_cli:
            logger.info("CLI process stop attempt made.")
        elif stopped_api:
            logger.info("API breakcalculation command sent.")


    def _execute_api_commands(self, commands: List[Callable[[Any], None]], server_global_object: Any, server_name: str) -> None:
        """
        Executes a list of command callables on the specified PLAXIS global object (g_i or g_o).

        Args:
            commands: A list of callable functions, each taking the server global object as an argument.
            server_global_object: The PLAXIS global object (g_i or g_o) to execute commands on.
            server_name: Name of the server ("Input" or "Output") for logging.

        Raises:
            PlaxisConnectionError: If the server_global_object is not available.
            PlaxisAutomationError (or subtype): If any command execution fails.
        """
        if not server_global_object:
            raise PlaxisConnectionError(f"{server_name} global object (g_i/g_o) is not available for executing API commands.")

        logger.info(f"Executing {len(commands)} API commands on {server_name} server...")
        for i, cmd_callable in enumerate(commands):
            # Try to get a meaningful name for the callable for logging
            command_name = getattr(cmd_callable, '__name__', f"lambda_or_partial_cmd_at_index_{i+1}")
            logger.debug(f"  Executing API command {i+1}/{len(commands)}: {command_name}")
            try:
                cmd_callable(server_global_object)
            except Exception as e: # Catch PlxScriptingError or other Python errors from the callable
                # Map to our custom exception hierarchy for consistent error handling upstream
                raise _map_plaxis_sdk_exception_to_custom(e, f"executing API command '{command_name}' on {server_name}")
        logger.info(f"Successfully executed all {len(commands)} API commands on {server_name} server.")

    def setup_model_in_plaxis(self, model_setup_callables: List[Callable[[Any], None]], is_new_project: bool = True) -> None:
        """
        Sets up the PLAXIS model using a list of command callables on the Input server (g_i).
        Handles project creation (new or open) and execution of model definition commands.

        Args:
            model_setup_callables: List of callables that define the model (geometry, soil, etc.).
            is_new_project: If True, creates a new PLAXIS project. If False, attempts to open
                            an existing project based on `project_settings.project_file_path`.

        Raises:
            PlaxisConfigurationError: If project_settings are missing or project file issues.
            PlaxisConnectionError: If connection to PLAXIS fails.
            Other PlaxisAutomationError subtypes for API command failures.
        """
        if not self.project_settings:
            raise PlaxisConfigurationError("ProjectSettings not provided to PlaxisInteractor for model setup.")

        self.signals.analysis_stage_changed.emit("setup_start")
        self.signals.progress_updated.emit(1, 4) # Example progress update

        self._connect_to_input_server() # Ensures g_i is available
        logger.info(f"Setting up PLAXIS model via API. New project: {is_new_project}")

        if is_new_project:
            initial_api_commands: List[Callable[[Any], None]] = [lambda gi_param: gi_param.new()]
            if self.project_settings.project_name:
                 initial_api_commands.append(lambda gi_param: gi_param.settitle(self.project_settings.project_name))
            self._execute_api_commands(initial_api_commands, self.g_i, "Input (g_i) - Project Initialization")
        else: # Open existing project
            if not self.project_settings.project_file_path or not os.path.exists(self.project_settings.project_file_path):
                raise PlaxisConfigurationError(
                    f"Project file path for opening is not specified or file does not exist: '{self.project_settings.project_file_path}'"
                )
            if not self.s_i or not hasattr(self.s_i, 'open'): # s_i is the server object
                 raise PlaxisConnectionError("Input server object (s_i) unavailable or lacks 'open' method for opening project.")
            try:
                logger.info(f"Attempting to open existing project: '{self.project_settings.project_file_path}' using s_i.open()")
                self.s_i.open(self.project_settings.project_file_path) # type: ignore
                logger.info(f"Project '{self.project_settings.project_file_path}' opened successfully.")
            except Exception as e:
                raise _map_plaxis_sdk_exception_to_custom(e, f"opening existing project '{self.project_settings.project_file_path}'")

        if model_setup_callables:
            logger.info(f"Executing {len(model_setup_callables)} main model setup callables...")
            self._execute_api_commands(model_setup_callables, self.g_i, "Input (g_i) - Model Definition")
        elif is_new_project: # Only log if new and no further commands; if opening, might just be an open action.
            logger.info("New project initialized, but no further model setup callables were provided.")

        logger.info("PLAXIS model setup phase completed successfully via API.")
        self.signals.analysis_stage_changed.emit("setup_end")


    def run_calculation(self, calculation_run_callables: List[Callable[[Any], None]]) -> None:
        """
        Runs the PLAXIS calculation sequence using command callables on the Input server (g_i).
        This typically includes meshing, setting up calculation phases, and executing `g_i.calculate()`.
        Also attempts to save the project after calculation.

        Args:
            calculation_run_callables: List of callables that define and run the calculation.

        Raises:
            PlaxisConfigurationError: If project_settings are missing.
            PlaxisConnectionError: If connection to PLAXIS fails.
            Other PlaxisAutomationError subtypes for API command failures (including calculation errors).
        """
        if not self.project_settings:
            raise PlaxisConfigurationError("ProjectSettings not provided. Cannot run calculation.")
        if not self.g_i: # Ensure connected
            self._connect_to_input_server()

        self.signals.analysis_stage_changed.emit("calculation_start")
        self.signals.progress_updated.emit(2, 4) # Example progress

        logger.info("Running PLAXIS calculation sequence via API...")
        self._execute_api_commands(calculation_run_callables, self.g_i, "Input (g_i) - Calculation Sequence")
        logger.info("Calculation sequence (including g_i.calculate() if present) reported success by PLAXIS.")
        self.signals.analysis_stage_changed.emit("calculation_end")

        # Attempt to save project after calculation
        project_save_path = self.project_settings.project_file_path
        if not project_save_path: # If no path was set (e.g. for a new unsaved project)
            default_filename = (self.project_settings.project_name or "UntitledPlaxisProject") + ".p3dxml" # Or .p2dxml
            # Save in current working directory or a configured output directory
            project_save_path = os.path.join(os.getcwd(), default_filename)
            logger.warning(f"`project_file_path` not set in ProjectSettings. Attempting to save to default: {project_save_path}")
            # Optionally update project_settings with this path if save is successful
            # self.project_settings.project_file_path = project_save_path

        logger.info(f"Attempting to save project to '{project_save_path}' after calculation...")
        if self.g_i and hasattr(self.g_i, 'save') and callable(self.g_i.save):
            save_cmd_callable: Callable[[Any], None] = lambda gi_param: gi_param.save(project_save_path)
            try:
                self._execute_api_commands([save_cmd_callable], self.g_i, "Input (g_i) - Save Project")
                logger.info(f"Project successfully saved to '{project_save_path}' after calculation.")
                # Update project_settings if it was a default path
                if not self.project_settings.project_file_path:
                     self.project_settings.project_file_path = project_save_path
            except PlaxisAutomationError as e_save: # Catch errors during save
               logger.warning(f"Failed to save project to '{project_save_path}' after calculation: {e_save}", exc_info=True)
               # Decide if this should re-raise or just be a warning
        else:
            logger.warning("`g_i.save` method not available or not callable. Cannot save project after calculation.")
        logger.info("PLAXIS calculation and subsequent save attempt finished.")

    def extract_results(self, results_extraction_callables: List[Callable[[Any, Optional[Any]], Any]]) -> List[Any]:
        """
        Extracts results from PLAXIS Output using a list of command callables.
        Connects to the Output server and opens the calculated project.

        Args:
            results_extraction_callables: List of callables, each taking (g_o, Optional[g_i])
                                          and returning a piece of result data.
        Returns:
            A list of data pieces extracted by the callables. Errors during extraction
            for a specific callable might result in an Exception object at that position in the list.

        Raises:
            PlaxisConfigurationError: If project settings or file path are missing/invalid.
            PlaxisOutputError: If the calculated project file cannot be found.
            PlaxisConnectionError: If connection to Output server fails.
        """
        if not self.project_settings or not self.project_settings.project_file_path:
            raise PlaxisConfigurationError("ProjectSettings or project_file_path not provided for results extraction.")

        self.signals.analysis_stage_changed.emit("results_start")
        self.signals.progress_updated.emit(3, 4) # Example progress

        calculated_project_path = self.project_settings.project_file_path
        if not os.path.exists(calculated_project_path):
            raise PlaxisOutputError(f"Calculated project file for results not found: {calculated_project_path}")

        self._connect_to_output_server(project_file_to_open=calculated_project_path) # Ensures g_o is available
        logger.info(f"Extracting results via API from PLAXIS Output for project: {calculated_project_path}")

        extracted_data_list: List[Any] = []
        if not self.g_o: # Should be caught by _connect_to_output_server, but defensive
            raise PlaxisConnectionError("PLAXIS Output global object (g_o) unavailable after connection attempt.")

        for i, cmd_callable in enumerate(results_extraction_callables):
            command_name = getattr(cmd_callable, '__name__', f"lambda_or_partial_res_cmd_at_index_{i+1}")
            try:
                logger.debug(f"  Executing result extraction command {i+1}/{len(results_extraction_callables)}: {command_name}")
                # Pass g_i as well, in case the result callable needs context from input model (e.g. for get_equivalent)
                result_piece = cmd_callable(self.g_o, self.g_i)
                extracted_data_list.append(result_piece)
            except Exception as e: # Catch errors from individual result callables
                logger.error(f"Result extraction command '{command_name}' failed: {e}", exc_info=True)
                # Map the error and append it, so caller can see which part failed
                mapped_error = _map_plaxis_sdk_exception_to_custom(e, f"extracting result '{command_name}'")
                extracted_data_list.append(mapped_error) # Store the error object itself

        logger.info(f"Executed {len(results_extraction_callables)} result callables, yielding {len(extracted_data_list)} data pieces/errors.")
        self.signals.analysis_stage_changed.emit("results_end")
        self.signals.progress_updated.emit(4, 4) # Example progress
        return extracted_data_list

    def close_all_connections(self) -> None:
        """
        Cleans up by nullifying server/global objects and attempting to terminate
        any running PLAXIS CLI process started by this interactor instance.
        """
        logger.info("Attempting to close all PLAXIS connections and processes initiated by this interactor...")

        # Nullify API objects
        if self.s_i or self.g_i:
            logger.info("Nullifying Input server objects (s_i, g_i). Actual server may remain running if started externally.")
            self.s_i, self.g_i = None, None
        if self.s_o or self.g_o:
            logger.info("Nullifying Output server objects (s_o, g_o). Actual server may remain running if started externally.")
            self.s_o, self.g_o = None, None

        # Terminate CLI process if managed by this instance
        if self.plaxis_process and self.plaxis_process.poll() is None: # Check if process exists and is running
            logger.info("Terminating active PLAXIS CLI process...")
            try:
                self.plaxis_process.terminate()
                self.plaxis_process.wait(timeout=5) # Wait for graceful exit
                logger.info("PLAXIS CLI process terminated gracefully.")
            except subprocess.TimeoutExpired:
                logger.warning("PLAXIS CLI process did not terminate gracefully after 5s, attempting to kill.")
                self.plaxis_process.kill()
                self.plaxis_process.wait() # Ensure it's reaped
                logger.info("PLAXIS CLI process killed.")
            except Exception as e:
                logger.error(f"Error during PLAXIS CLI process termination: {e}", exc_info=True)
            finally:
                self.plaxis_process = None # Clear reference

        logger.info("PLAXIS connections and processes handled for closure by PlaxisInteractor.")

# Example __main__ block for basic conceptual testing or direct execution (if ever needed)
if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    logger.info("\n--- Conceptual Test of PlaxisInteractor (with Exception Handling) ---")

    # This part would require actual plxscripting and a running PLAXIS instance
    # or more elaborate mocking to be truly runnable as a standalone script.
    # The pytest suite provides better, isolated testing with mocks.

    # Example of creating a mock ProjectSettings for basic tests
    # from dataclasses import dataclass
    # @dataclass
    # class MockProjectSettings(ProjectSettings): # Simplified version for tests
    #     plaxis_api_input_port: int = 10000
    #     plaxis_api_output_port: int = 10001
    #     plaxis_api_password: str = "test_password"
    #     project_file_path: Optional[str] = None
    #     # analysis_settings might contain max_calc_time_seconds
    #     # analysis_settings: Optional[Any] = None

    # mock_ps = MockProjectSettings(project_name="TestMain")
    # mock_ps.project_file_path = "test_main_project.p3dxml"

    # interactor = PlaxisInteractor(project_settings=mock_ps, plaxis_path="path/to/plaxis")
    # try:
    #     logger.info("Attempting conceptual connection (will fail if PLAXIS not running/mocked properly)...")
    #     # interactor._connect_to_input_server()
    #     # Further calls would go here
    # except Exception as e:
    #     logger.error(f"Main test block error: {e}")
    # finally:
    #     # interactor.close_all_connections()
    #     pass
    logger.info("\n--- Conceptual Test of PlaxisInteractor Finished ---")
