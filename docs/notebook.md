# PLAXIS commands index

Here you can find the relevant notebooks with examples of PLAXIS commands using the Python scripting capabilities.

---

## PLAXIS 3D

---

### Input

---

#### A

---

- [activate](input_notebooks/3d-python-inputcommands-activate.ipynb)
- [add](input_notebooks/3d-python-inputcommands-add.ipynb)
- [addedmass](input_notebooks/3d-python-inputcommands-addedmass.ipynb)
- [addpoint](input_notebooks/3d-python-inputcommands-addpoint.ipynb)
- [addsubcurve](input_notebooks/3d-python-inputcommands-addsubcurve.ipynb)
- [addtunnelphaseroutine](input_notebooks/3d-python-inputcommands-addtunnelphaseroutine.ipynb)
- [addtunnelphasestep](input_notebooks/3d-python-inputcommands-addtunnelphasestep.ipynb)
- [addwaterpoint](input_notebooks/3d-python-inputcommands-addwaterpoint.ipynb)
- [advance](input_notebooks/3d-python-inputcommands-advance.ipynb)
- [allocmem](input_notebooks/3d-python-inputcommands-allocmem.ipynb)
- [anchormat](input_notebooks/3d-python-inputcommands-anchormat.ipynb)
- [apply](input_notebooks/3d-python-inputcommands-apply.ipynb)
- [arrayp](input_notebooks/3d-python-inputcommands-arrayp.ipynb)
- [arrayr](input_notebooks/3d-python-inputcommands-arrayr.ipynb)

---

#### B

---

- [beam](input_notebooks/3d-python-inputcommands-beam.ipynb)
- [beammat](input_notebooks/3d-python-inputcommands-beammat.ipynb)
- [borehole](input_notebooks/3d-python-inputcommands-borehole.ipynb)

---

#### C

---

- [calculate](input_notebooks/3d-python-inputcommands-calculate.ipynb)
- [cable](input_notebooks/3d-python-inputcommands-cable.ipynb)
- [cablemat](input_notebooks/3d-python-inputcommands-cablemat.ipynb)
- [checkgeometry](input_notebooks/3d-python-inputcommands-checkgeometry.ipynb)
- [checkcalculationconditions](input_notebooks/3d-python-inputcommands-checkcalculationconditions.ipynb)
- [clear](input_notebooks/3d-python-inputcommands-clear.ipynb)
- [clearmaterial](input_notebooks/3d-python-inputcommands-clearmaterial.ipynb)
- [close](input_notebooks/3d-python-inputcommands-close.ipynb)
- [coarsen](input_notebooks/3d-python-inputcommands-coarsen.ipynb)
- [combine](input_notebooks/3d-python-inputcommands-combine.ipynb)
- [commands](input_notebooks/3d-python-inputcommands-commands.ipynb)
- [cone](input_notebooks/3d-python-inputcommands-cone.ipynb)
- [connection](input_notebooks/3d-python-inputcommands-connection.ipynb)
- [contraction](input_notebooks/3d-python-inputcommands-contraction.ipynb)
- [copylayers](input_notebooks/3d-python-inputcommands-copylayers.ipynb)
- [count](input_notebooks/3d-python-inputcommands-count.ipynb)
- [countmeshnodes](input_notebooks/3d-python-inputcommands-countmeshnodes.ipynb)
- [createreachedwl](input_notebooks/3d-python-inputcommands-createreachedwl.ipynb)
- [createreachedwlandcontinue](input_notebooks/3d-python-inputcommands-createreachedwlandcontinue.ipynb)
- [cuboid](input_notebooks/3d-python-inputcommands-cuboid.ipynb)
- [cylinder](input_notebooks/3d-python-inputcommands-cylinder.ipynb)

---

#### D

---

```python
- [deactivate](input_notebooks/3d-python-inputcommands-deactivate.ipynb)
- [decomposeoutl](input_notebooks/3d-python-inputcommands-decomposeoutl.ipynb)
- [decomposepolycurve](input_notebooks/3d-python-inputcommands-decomposepolycurve.ipynb)
- [decomposesrf](input_notebooks/3d-python-inputcommands-decomposesrf.ipynb)
- [decouplefromgenerator](input_notebooks/3d-python-inputcommands-decouplefromgenerator.ipynb)
- [delete](input_notebooks/3d-python-inputcommands-delete.ipynb)
- [deletepoint](input_notebooks/3d-python-inputcommands-deletepoint.ipynb)
- [delruntimetoggle](input_notebooks/3d-python-inputcommands-delruntimetoggle.ipynb)
- [dischargefunction](input_notebooks/3d-python-inputcommands-dischargefunction.ipynb)
- [displmultiplier](input_notebooks/3d-python-inputcommands-displmultiplier.ipynb)
- [dump](input_notebooks/3d-python-inputcommands-dump.ipynb)
- [dumpbeams](input_notebooks/3d-python-inputcommands-dumpbeams.ipynb)
- [dumpboreholes](input_notebooks/3d-python-inputcommands-dumpboreholes.ipynb)
- [dumpcutobjects](input_notebooks/3d-python-inputcommands-dumpcutobjects.ipynb)
- [dumpfixedendanchors](input_notebooks/3d-python-inputcommands-dumpfixedendanchors.ipynb)
- [dumpgeogrids](input_notebooks/3d-python-inputcommands-dumpgeogrids.ipynb)
- [dumpgroups](input_notebooks/3d-python-inputcommands-dumpgroups.ipynb)
- [dumplinedispls](input_notebooks/3d-python-inputcommands-dumplinedispls.ipynb)
- [dumplineloads](input_notebooks/3d-python-inputcommands-dumplineloads.ipynb)
- [dumplines](input_notebooks/3d-python-inputcommands-dumplines.ipynb)
- [dumpmaterials](input_notebooks/3d-python-inputcommands-dumpmaterials.ipynb)
- [dumpmeshes](input_notebooks/3d-python-inputcommands-dumpmeshes.ipynb)
- [dumpn2nanchors](input_notebooks/3d-python-inputcommands-dumpn2nanchors.ipynb)
- [dumpnegativeinterfaces](input_notebooks/3d-python-inputcommands-dumpnegativeinterfaces.ipynb)
- [dumpparamobject](input_notebooks/3d-python-inputcommands-dumpparamobject.ipynb)
- [dumpphases](input_notebooks/3d-python-inputcommands-dumpphases.ipynb)
- [dumppiles](input_notebooks/3d-python-inputcommands-dumppiles.ipynb)
- [dumppointdispls](input_notebooks/3d-python-inputcommands-dumppointdispls.ipynb)
- [dumppointloads](input_notebooks/3d-python-inputcommands-dumppointloads.ipynb)
- [dumppoints](input_notebooks/3d-python-inputcommands-dumppoints.ipynb)
- [dumppositiveinterfaces](input_notebooks/3d-python-inputcommands-dumppositiveinterfaces.ipynb)
- [dumpsoillayers](input_notebooks/3d-python-inputcommands-dumpsoillayers.ipynb)
- [dumpsoilvolumes](input_notebooks/3d-python-inputcommands-dumpsoilvolumes.ipynb)
- [dumpsurfaces](input_notebooks/3d-python-inputcommands-dumpsurfaces.ipynb)
- [dumpsurfdispls](input_notebooks/3d-python-inputcommands-dumpsurfdispls.ipynb)
- [dumpsurfloads](input_notebooks/3d-python-inputcommands-dumpsurfloads.ipynb)
- [dumpvolumes](input_notebooks/3d-python-inputcommands-dumpvolumes.ipynb)
- [duplicate](input_notebooks/3d-python-inputcommands-duplicate.ipynb)
```

---

#### E

---

- [echo](input_notebooks/3d-python-inputcommands-echo.ipynb)
- [echotunnelvalidation](input_notebooks/3d-python-inputcommands-echotunnelvalidation.ipynb)
- [embeddedbeam](input_notebooks/3d-python-inputcommands-embeddedbeam.ipynb)
- [embeddedbeammat](input_notebooks/3d-python-inputcommands-embeddedbeammat.ipynb)
- [export](input_notebooks/3d-python-inputcommands-export.ipynb)
- [extendtosymmetryaxis](input_notebooks/3d-python-inputcommands-extendtosymmetryaxis.ipynb)
- [extrude](input_notebooks/3d-python-inputcommands-extrude.ipynb)

---

#### F

---

- [filter](input_notebooks/3d-python-inputcommands-filter.ipynb)
- [findcutobject](input_notebooks/3d-python-inputcommands-findcutobject.ipynb)
- [findstagedfeature](input_notebooks/3d-python-inputcommands-findstagedfeature.ipynb)
- [fixedendanchor](input_notebooks/3d-python-inputcommands-fixedendanchor.ipynb)

---

#### G

---

- [generatefromfielddata](input_notebooks/3d-python-inputcommands-generatefromfielddata.ipynb)
- [generatesplittunnel](input_notebooks/3d-python-inputcommands-generatesplittunnel.ipynb)
- [generatethicklining](input_notebooks/3d-python-inputcommands-generatethicklining.ipynb)
- [generatetunnel](input_notebooks/3d-python-inputcommands-generatetunnel.ipynb)
- [geogrid](input_notebooks/3d-python-inputcommands-geogrid.ipynb)
- [geogridmat](input_notebooks/3d-python-inputcommands-geogridmat.ipynb)
- [getcommonmeshnodes](input_notebooks/3d-python-inputcommands-getcommonmeshnodes.ipynb)
- [getcurveresults](input_notebooks/3d-python-inputcommands-getcurveresults.ipynb)
- [getlocalaxes](input_notebooks/3d-python-inputcommands-getlocalaxes.ipynb)
- [getmeshlocalaxes](input_notebooks/3d-python-inputcommands-getmeshlocalaxes.ipynb)
- [getnormal](input_notebooks/3d-python-inputcommands-getnormal.ipynb)
- [getresults](input_notebooks/3d-python-inputcommands-getresults.ipynb)
- [getsoillayerlevel](input_notebooks/3d-python-inputcommands-getsoillayerlevel.ipynb)
- [getsoillayerporepressure](input_notebooks/3d-python-inputcommands-getsoillayerporepressure.ipynb)
- [gettoggle](input_notebooks/3d-python-inputcommands-gettoggle.ipynb)
- [getvalue](input_notebooks/3d-python-inputcommands-getvalue.ipynb)
- [gotoflow](input_notebooks/3d-python-inputcommands-gotoflow.ipynb)
- [gotomesh](input_notebooks/3d-python-inputcommands-gotomesh.ipynb)
- [gotosoil](input_notebooks/3d-python-inputcommands-gotosoil.ipynb)
- [gotostages](input_notebooks/3d-python-inputcommands-gotostages.ipynb)
- [gotostructures](input_notebooks/3d-python-inputcommands-gotostructures.ipynb)
- [gotowater](input_notebooks/3d-python-inputcommands-gotowater.ipynb)
- [group](input_notebooks/3d-python-inputcommands-group.ipynb)
- [groupfiltered](input_notebooks/3d-python-inputcommands-groupfiltered.ipynb)

---

#### H

---

- [headfunction](input_notebooks/3d-python-inputcommands-headfunction.ipynb)
- [help](input_notebooks/3d-python-inputcommands-help.ipynb)

---

#### I

---

- [import](input_notebooks/3d-python-inputcommands-import.ipynb)
- [importcrosssection](input_notebooks/3d-python-inputcommands-importcrosssection.ipynb)
- [importfielddata](input_notebooks/3d-python-inputcommands-importfielddata.ipynb)
- [importifc](input_notebooks/3d-python-inputcommands-importifc.ipynb)
- [importpointcloud](input_notebooks/3d-python-inputcommands-importpointcloud.ipynb)
- [importtrajectory](input_notebooks/3d-python-inputcommands-importtrajectory.ipynb)
- [info](input_notebooks/3d-python-inputcommands-info.ipynb)
- [initializerectangular](input_notebooks/3d-python-inputcommands-initializerectangular.ipynb)
- [insert](input_notebooks/3d-python-inputcommands-insert.ipynb)
- [insertphase](input_notebooks/3d-python-inputcommands-insertphase.ipynb)
- [insertpoint](input_notebooks/3d-python-inputcommands-insertpoint.ipynb)
- [insertsoillayer](input_notebooks/3d-python-inputcommands-insertsoillayer.ipynb)
- [insertwaterpoint](input_notebooks/3d-python-inputcommands-insertwaterpoint.ipynb)
- [intersect](input_notebooks/3d-python-inputcommands-intersect.ipynb)
- [intersectsegments](input_notebooks/3d-python-inputcommands-intersectsegments.ipynb)
- [invert](input_notebooks/3d-python-inputcommands-invert.ipynb)
- [invertdirection](input_notebooks/3d-python-inputcommands-invertdirection.ipynb)
- [invertnormal](input_notebooks/3d-python-inputcommands-invertnormal.ipynb)

---

#### K

---

- [kill](input_notebooks/3d-python-inputcommands-kill.ipynb)

---

#### L

---

- [line](input_notebooks/3d-python-inputcommands-line.ipynb)
- [lineangles](input_notebooks/3d-python-inputcommands-lineangles.ipynb)
- [linedispl](input_notebooks/3d-python-inputcommands-linedispl.ipynb)
- [linedrain](input_notebooks/3d-python-inputcommands-linedrain.ipynb)
- [lineload](input_notebooks/3d-python-inputcommands-lineload.ipynb)
- [linemovement](input_notebooks/3d-python-inputcommands-linemovement.ipynb)
- [lineparallel](input_notebooks/3d-python-inputcommands-lineparallel.ipynb)
- [linerelative](input_notebooks/3d-python-inputcommands-linerelative.ipynb)
- [linevector](input_notebooks/3d-python-inputcommands-linevector.ipynb)
- [loadmultiplier](input_notebooks/3d-python-inputcommands-loadmultiplier.ipynb)
- [loft](input_notebooks/3d-python-inputcommands-loft.ipynb)

---

#### M

---

- [materialcommand](input_notebooks/3d-python-inputcommands-materialcommand.ipynb)
- [mergeequivalents](input_notebooks/3d-python-inputcommands-mergeequivalents.ipynb)
- [mesh](input_notebooks/3d-python-inputcommands-mesh.ipynb)
- [meshd](input_notebooks/3d-python-inputcommands-meshd.ipynb)
- [move](input_notebooks/3d-python-inputcommands-move.ipynb)
- [movementfunction](input_notebooks/3d-python-inputcommands-movementfunction.ipynb)
- [movepoint](input_notebooks/3d-python-inputcommands-movepoint.ipynb)
- [multiply](input_notebooks/3d-python-inputcommands-multiply.ipynb)

---

#### N

---

- [n2nanchor](input_notebooks/3d-python-inputcommands-n2nanchor.ipynb)
- [neginterface](input_notebooks/3d-python-inputcommands-neginterface.ipynb)
- [nurbscurve](input_notebooks/3d-python-inputcommands-nurbscurve.ipynb)
- [nurbssurface](input_notebooks/3d-python-inputcommands-nurbssurface.ipynb)

---

#### O

---

- [observers](input_notebooks/3d-python-inputcommands-observers.ipynb)

---

#### P

---

- [phase](input_notebooks/3d-python-inputcommands-phase.ipynb)
- [plate](input_notebooks/3d-python-inputcommands-plate.ipynb)
- [platemat](input_notebooks/3d-python-inputcommands-platemat.ipynb)
- [point](input_notebooks/3d-python-inputcommands-point.ipynb)
- [pointdispl](input_notebooks/3d-python-inputcommands-pointdispl.ipynb)
- [pointload](input_notebooks/3d-python-inputcommands-pointload.ipynb)
- [pointmovement](input_notebooks/3d-python-inputcommands-pointmovement.ipynb)
- [polycurve](input_notebooks/3d-python-inputcommands-polycurve.ipynb)
- [polycurvechain](input_notebooks/3d-python-inputcommands-polycurvechain.ipynb)
- [posinterface](input_notebooks/3d-python-inputcommands-posinterface.ipynb)
- [predict](input_notebooks/3d-python-inputcommands-predict.ipynb)
- [preview](input_notebooks/3d-python-inputcommands-preview.ipynb)
- [projectpoints](input_notebooks/3d-python-inputcommands-projectpoints.ipynb)

---

#### R

---

- [raise](input_notebooks/3d-python-inputcommands-raise.ipynb)
- [raiseasync](input_notebooks/3d-python-inputcommands-raiseasync.ipynb)
- [raisethreaded](input_notebooks/3d-python-inputcommands-raisethreaded.ipynb)
- [redo](input_notebooks/3d-python-inputcommands-redo.ipynb)
- [refine](input_notebooks/3d-python-inputcommands-refine.ipynb)
- [regenerate](input_notebooks/3d-python-inputcommands-regenerate.ipynb)
- [reinforcement](input_notebooks/3d-python-inputcommands-reinforcement.ipynb)
- [removeintermediatesteps](input_notebooks/3d-python-inputcommands-removeintermediatesteps.ipynb)
- [removetunnelphaseroutine](input_notebooks/3d-python-inputcommands-removetunnelphaseroutine.ipynb)
- [removetunnelphasestep](input_notebooks/3d-python-inputcommands-removetunnelphasestep.ipynb)
- [rename](input_notebooks/3d-python-inputcommands-rename.ipynb)
- [reportmem](input_notebooks/3d-python-inputcommands-reportmem.ipynb)
- [reset](input_notebooks/3d-python-inputcommands-reset.ipynb)
- [resetlocal](input_notebooks/3d-python-inputcommands-resetlocal.ipynb)
- [retrievesuggestedparameters](input_notebooks/3d-python-inputcommands-retrievesuggestedparameters.ipynb)
- [revolve](input_notebooks/3d-python-inputcommands-revolve.ipynb)
- [rigidbody](input_notebooks/3d-python-inputcommands-rigidbody.ipynb)
- [rotate](input_notebooks/3d-python-inputcommands-rotate.ipynb)
- [rotateline](input_notebooks/3d-python-inputcommands-rotateline.ipynb)

---

#### S

---

```python
- [save](input_notebooks/3d-python-inputcommands-save.ipynb)
- [saveobjects](input_notebooks/3d-python-inputcommands-saveobjects.ipynb)
- [selectmeshpoints](input_notebooks/3d-python-inputcommands-selectmeshpoints.ipynb)
- [set](input_notebooks/3d-python-inputcommands-set.ipynb)
- [setcolour](input_notebooks/3d-python-inputcommands-setcolour.ipynb)
- [setcurrentphase](input_notebooks/3d-python-inputcommands-setcurrentphase.ipynb)
- [setdefaultmaterial](input_notebooks/3d-python-inputcommands-setdefaultmaterial.ipynb)
- [setglobalwaterlevel](input_notebooks/3d-python-inputcommands-setglobalwaterlevel.ipynb)
- [setinsertionpoint](input_notebooks/3d-python-inputcommands-setinsertionpoint.ipynb)
- [setmaterial](input_notebooks/3d-python-inputcommands-setmaterial.ipynb)
- [setphysicalcpucount](input_notebooks/3d-python-inputcommands-setphysicalcpucount.ipynb)
- [setproperties](input_notebooks/3d-python-inputcommands-setproperties.ipynb)
- [setsoillayerlevel](input_notebooks/3d-python-inputcommands-setsoillayerlevel.ipynb)
- [setsoillayerporepressure](input_notebooks/3d-python-inputcommands-setsoillayerporepressure.ipynb)
- [settoggle](input_notebooks/3d-python-inputcommands-settoggle.ipynb)
- [setundostacksize](input_notebooks/3d-python-inputcommands-setundostacksize.ipynb)
- [setwaterdry](input_notebooks/3d-python-inputcommands-setwaterdry.ipynb)
- [setwaterinterpolate](input_notebooks/3d-python-inputcommands-setwaterinterpolate.ipynb)
- [setwaterlevel](input_notebooks/3d-python-inputcommands-setwaterlevel.ipynb)
- [sleep](input_notebooks/3d-python-inputcommands-sleep.ipynb)
- [slicemerge](input_notebooks/3d-python-inputcommands-slicemerge.ipynb)
- [slicemergeall](input_notebooks/3d-python-inputcommands-slicemergeall.ipynb)
- [slicingreset](input_notebooks/3d-python-inputcommands-slicingreset.ipynb)
- [snap](input_notebooks/3d-python-inputcommands-snap.ipynb)
- [snaplinear](input_notebooks/3d-python-inputcommands-snaplinear.ipynb)
- [soil](input_notebooks/3d-python-inputcommands-soil.ipynb)
- [soillayer](input_notebooks/3d-python-inputcommands-soillayer.ipynb)
- [soillayerheight](input_notebooks/3d-python-inputcommands-soillayerheight.ipynb)
- [soilmat](input_notebooks/3d-python-inputcommands-soilmat.ipynb)
- [sphere](input_notebooks/3d-python-inputcommands-sphere.ipynb)
- [surface](input_notebooks/3d-python-inputcommands-surface.ipynb)
- [surfdispl](input_notebooks/3d-python-inputcommands-surfdispl.ipynb)
- [surfdrain](input_notebooks/3d-python-inputcommands-surfdrain.ipynb)
- [surfgwfbc](input_notebooks/3d-python-inputcommands-surfgwfbc.ipynb)
- [surfload](input_notebooks/3d-python-inputcommands-surfload.ipynb)
- [symmetricclose](input_notebooks/3d-python-inputcommands-symmetricclose.ipynb)
```

---

#### T

---

- [tabulate](input_notebooks/3d-python-inputcommands-tabulate.ipynb)
- [testasync](input_notebooks/3d-python-inputcommands-testasync.ipynb)
- [transform](input_notebooks/3d-python-inputcommands-transform.ipynb)
- [translateline](input_notebooks/3d-python-inputcommands-translateline.ipynb)
- [tunnel](input_notebooks/3d-python-inputcommands-tunnel.ipynb)

---

#### U

---

- [unassign](input_notebooks/2d-python-inputcommands-unassign.ipynb)
- [undo](input_notebooks/3d-python-inputcommands-undo.ipynb)
- [ungroup](input_notebooks/3d-python-inputcommands-ungroup.ipynb)
- [usecustombottomsurface](input_notebooks/3d-python-inputcommands-usecustombottomsurface.ipynb)
- [usecustomtopsurface](input_notebooks/3d-python-inputcommands-usecustomtopsurface.ipynb)

---

#### V

---

- [validate](input_notebooks/3d-python-inputcommands-validate.ipynb)
- [view](input_notebooks/3d-python-inputcommands-view.ipynb)
- [viewmesh](input_notebooks/3d-python-inputcommands-viewmesh.ipynb)

---

#### W

---

- [waterlevel](input_notebooks/3d-python-inputcommands-waterlevel.ipynb)
- [well](input_notebooks/3d-python-inputcommands-well.ipynb)
- [writephasestomesh](input_notebooks/3d-python-inputcommands-writephasestomesh.ipynb)

---

### Output

---

#### A

---

- [add](output_notebooks/3d-python-outputcommands-add.ipynb)
- [addcurvepoint](output_notebooks/3d-python-outputcommands-addcurvepoint.ipynb)
- [allocmem](output_notebooks/3d-python-outputcommands-allocmem.ipynb)
- [apply](output_notebooks/3d-python-outputcommands-apply.ipynb)

---

#### C

---

```python
- [centerline](output_notebooks/3d-python-outputcommands-centerline.ipynb)
- [centerlineconfig](output_notebooks/3d-python-outputcommands-centerlineconfig.ipynb)
- [clearcurvepoints](output_notebooks/3d-python-outputcommands-clearcurvepoints.ipynb)
- [close](output_notebooks/3d-python-outputcommands-close.ipynb)
- [commands](output_notebooks/3d-python-outputcommands-commands.ipynb)
- [count](output_notebooks/3d-python-outputcommands-count.ipynb)
- [crosssectionplot](output_notebooks/3d-python-outputcommands-crosssectionplot.ipynb)
```

---

#### D

---

- [delete](output_notebooks/3d-python-outputcommands-delete.ipynb)
- [dump](output_notebooks/3d-python-outputcommands-dump.ipynb)

---

#### E

---

- [echo](output_notebooks/3d-python-outputcommands-echo.ipynb)
- [export](output_notebooks/3d-python-outputcommands-export.ipynb)

---

#### F

---

- [filter](output_notebooks/3d-python-outputcommands-filter.ipynb)

---

#### G

---

- [generate](output_notebooks/3d-python-outputcommands-generate.ipynb)
- [getcrossectionresults](output_notebooks/3d-python-outputcommands-getcrosssectionresults.ipynb)
- [getcurveresults](output_notebooks/3d-python-outputcommands-getcurveresults.ipynb)
- [getcurveresultspath](output_notebooks/3d-python-outputcommands-getcurveresultspath.ipynb)
- [getresults](output_notebooks/3d-python-outputcommands-getresults.ipynb)
- [getsingleresult](output_notebooks/3d-python-outputcommands-getsingleresult.ipynb)

---

#### H

---

- [hide](output_notebooks/3d-python-outputcommands-hide.ipynb)

---

#### I

---

- [index](output_notebooks/3d-python-outputcommands-index.ipynb)
- [info](output_notebooks/3d-python-outputcommands-info.ipynb)

---

#### L

---

- [linecrosssectionplot](output_notebooks/3d-python-outputcommands-linecrosssectionplot.ipynb)

---

#### R

---

- [raise](output_notebooks/3d-python-outputcommands-raise.ipynb)
- [raiseasync](output_notebooks/3d-python-outputcommands-raiseasync.ipynb)
- [raisethreaded](output_notebooks/3d-python-outputcommands-raisethreaded.ipynb)
- [rename](output_notebooks/3d-python-outputcommands-rename.ipynb)
- [reportmem](output_notebooks/3d-python-outputcommands-reportmem.ipynb)

---

#### S

---

- [set](output_notebooks/3d-python-outputcommands-set.ipynb)
- [setphysicalcpucount](output_notebooks/3d-python-outputcommands-setphysicalcpucount.ipynb)
- [setproperties](output_notebooks/3d-python-outputcommands-setproperties.ipynb)
- [show](output_notebooks/3d-python-outputcommands-show.ipynb)
- [sleep](output_notebooks/3d-python-outputcommands-sleep.ipynb)
- [slice](output_notebooks/3d-python-outputcommands-slice.ipynb)
- [structuralforcesplot](output_notebooks/3d-python-outputcommands-structuralforcesplot.ipynb)
- [structureplot](output_notebooks/3d-python-outputcommands-structureplot.ipynb)

---

#### T

---

- [tabulate](output_notebooks/3d-python-outputcommands-tabulate.ipynb)
- [testasync](output_notebooks/3d-python-outputcommands-testasync.ipynb)

---

#### U

---

- [update](output_notebooks/3d-python-outputcommands-update.ipynb)

---

#### V

---

- [view](output_notebooks/3d-python-outputcommands-view.ipynb)

---

#### Z

---

- [zoom](output_notebooks/3d-python-outputcommands-zoom.ipynb)

---

### Sample scripts

---

- [Input scripts](sample_scripts_notebooks/3d-python-samplescripts-input.ipynb)
- [Output scripts](sample_scripts_notebooks/3d-python-samplescripts-output.ipynb)
- [Input - get_equivalent](sample_scripts_notebooks/3d-python-samplescripts-get_equivalent-input.ipynb)
- [Output - get_equivalent](sample_scripts_notebooks/3d-python-samplescripts-get_equivalent-output.ipynb)
- [Input - _plx_type](sample_scripts_notebooks/3d-python-samplescripts-plx_type-input.ipynb)

# Python wrapper commands [ACTIVATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## activate
Activates features.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Activates one or more activatable objects in one or more phases

# Example 1
# Creates a surface, assigns plate feature to it, then creates phases and activates a plate in two phases
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.plate(polygon_g)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
plate_s = g_i.Plates[-1]
g_i.setcurrentphase(phase1_s)

plate_s.activate(phase0_s, phase1_s)
```

---

```python
# Alternative 2
# Activates one or more activatable objects in one or more phases

# Example 1
# Creates a cuboid and a volume extruded from a created surface. Next, creates phases, and activates all volumes in Phase_1
g_i.gotostructures()
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.extrude(polygon_g, (1, 0, 5))

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.setcurrentphase(phase1_s)

volumes_s = g_i.Volumes
volumes_s.activate(phase1_s)
```

# Python wrapper commands [ADD]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## add
Adds a segment to a polycurve or a row to an advanced table.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds a line segment with a length of 1 to a polycurve
   
# Example 1
# Creates a polycurve with two segments (line and arc), and then adds a new segment to a polycurve.
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]

segment_g = polycurve_g.add() 

print(g_i.echo(segment_g))
```

---

```python
# Alternative 2
# Adds one or more segments with specified properties to a polycurve

# Example 1
# Creates a polycurve with three line segments, and then adds two new segments (arc and line) to a polycurve.
polycurve_g = g_i.polycurve((0, 0, 0), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "line", 90, 2, "line", 90, 2)[0]

segments_g = polycurve_g.add("arc", 0, 45, 1, "line", 90, 2)

print(g_i.echo(segments_g))
```

---

```python
# Alternative 3
# Adds a row to an advanced table

# Example 1
# Creates an empty load multiplier and adds one row to a table with values (0, 0). Finally, displays new row's address in the memory
loadmultiplier_i = g_i.loadmultiplier()
row_i = loadmultiplier_i.Table.add()

print(row_i)

# Example 2
# Creates an empty displacement multiplier and adds one row to a table with values (0, 0). Finally, displays new row's address in the memory
displacementmultiplier_i = g_i.displmultiplier()
row_i = displacementmultiplier_i.Table.add()

print(row_i)
```

---

```python
# Alternative 4
# Adds a row to an advanced table

# Example 1
# Creates an empty load multiplier and adds one row to a table with values (5, 2). Finally, displays new row's address in the memory
loadmultiplier_i = g_i.loadmultiplier()
row_i = loadmultiplier_i.Table.add(5, 2)
print(row_i)

# Example 2
# Creates an empty displacement multiplier and adds one row to a table with values (5, 2). Finally, displays new row's address in the memory
displacementmultiplier_i = g_i.displmultiplier()
row_i = displacementmultiplier_i.Table.add(5, 2)

print(row_i)
```

# Python wrapper commands [ADDEDMASS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

### addedmass
Adds Westergaard AddedMass feature features to surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds Westergaard AddedMass features to one or more existing surfaces in the geometry.

# Example 1
# Creates a surface and assigns a AddedMass feature to it. Displays AddedMass's address in the memory
g_i.gotostructures()
polygon_g = g_i.surface((0, 0, 0), (1, 0, 0), (1, 0, -5), (0, 0, -5))
addedmass_g = g_i.addedmass(polygon_g)

print(addedmass_g)

# Example 2
polygon1_g = g_i.surface((0, 0, 0), (1, 0, 0), (1, 0, -5), (0, 0, -5))
polygon2_g = g_i.surface((5, 0, 0), (6, 0, 0), (5, 0, -5), (5, 0, -5))
addedmasses_g = g_i.addedmass(polygon1_g, polygon2_g)

print(addedmasses_g)

# Example 3
# Creates two polygons and groups them. Then, assigns AddedMass feature to all objects in the group
g_i.gotostructures()
polygon1_g = g_i.surface((0, 0, 0), (1, 0, 0), (1, 0, -5), (0, 0, -5))
polygon2_g = g_i.surface((5, 0, 0), (6, 0, 0), (5, 0, -5), (5, 0, -5))
group_g  = g_i.group(polygon1_g, polygon2_g)
addedmasses_g = g_i.addedmass(group_g)

print(addedmasses_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points (which may either exist or will be created) and adds a Westergaard AddedMass feature to it.
g_i.gotostructures()
point1_g, point2_g = g_i.point((0, 0, 0),(1, 1, 1))

# Creates multiple objects, the last one is the Westergaard AddedMass object ([-1])
addedmass_g = g_i.addedmass(point1_g, point2_g, (2, 0, 5))[-1]
print(addedmass_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and adds a Westergaard AddedMass feature to it.
g_i.gotostructures()

# Creates multiple objects, the first one is the Polycurve object ([0]) and closes the polycurve
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()

addedmass_g = g_i.addedmass(polycurve_g)
print(addedmass_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Adds Westergaard AddedMass features to one or more existing structural surfaces in the geometry and directly sets their properties.

# Example 1
# Adds a Westergaard AddedMass feature to a surface and sets the Positive Water Base Level to 1.5.
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
addedmass_g = g_i.addedmass(polygon_g, "PositiveWBL", 1.5)

print(addedmass_g)

# Example 2
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))

addedmasses_g = g_i.addedmass((polygon1_g, polygon2_g), "PositiveWBL", 1.5)
print(addedmasses_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points (which may either exist or will be created), adds a Westergaard AddedMass feature to it and directly sets its properties

point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)

surface_g, addedmass_g = g_i.addedmass(point1_g, point2_g, (1, 0, 5), "PositiveWBL", 1.5)
print(surface_g, addedmass_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and adds a Westergaard AddedMass feature to it and directly sets its properties.

# Creates multiple objects, the first one is the Polycurve object ([0]) and closes the polycurve
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()

# Creates a structural surface from a polycurve, adds a Westergaard AddedMass feature to it and sets the Positive Water Base Level to 1.5.
surface_g, addedmass_g = g_i.addedmass(polycurve_g, "PositiveWBL", 1.5)

print(surface_g, addedmass_g)
```

# Python wrapper commands [ADDPOINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## addpoint
Adds a new point to a polygon or water level.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds a new point to a polygon

polygon_g = g_i.surface((0, 0, 2), (3, 5, 4), (7, 11, 13), (9, 8, 15))
polygon_g.addpoint(1, 2, 3)

print(g_i.echo(polygon_g))
```

---

```python
# Alternative 2
# Adds two or more new points to a polygon

polygon_g = g_i.surface((0, 0, 2), (3, 5, 4), (7, 11, 13), (9, 8, 15))
polygon_g.addpoint((1, 2, 3), (4, 5, 6))

print(g_i.echo(polygon_g))
```

---

```python
# Alternative 3
# Adds a new water point to an existing water level without pressure increment

# Creates a cuboid, then changes a mode, creates a water level. Next, it adds a point to a water level
g_i.gotosoil()
g_i.clear()
g_i.cuboid(10)
g_i.gotoflow()
waterlevel_s = g_i.waterlevel(1, 4, 6)
waterlevel_s.addpoint(1, 2, 3)

print(g_i.echo(waterlevel_s))
```

---

```python
# Alternative 4
# Adds two or more new water points to an existing water level without pressure increment

# Creates a cuboid, then changes a mode, creates a water level. Next, it adds two points to a water level
g_i.gotosoil()
g_i.clear()
g_i.cuboid(10)
g_i.gotoflow()
waterlevel_s = g_i.waterlevel((6, 4, 1), 2)
waterlevel_s.addpoint((1, 2, 3), (4, 5, 6))

print(g_i.echo(waterlevel_s))
```

# Python wrapper commands [ADDSUBCURVE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## addsubcurve
Adds a sub-curve to a tunnel cross section.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds a subline to a tunnel cross section

# Creates an empty tunnel object and then adds a adds sub-curve to tunnel's cross section. Finally, tabulate the tunnel properties
tunnel_g = g_i.tunnel(6, 2, 3)
subsectionpolycurve_g, segment_g = tunnel_g.CrossSection.addsubcurve()

print(g_i.tabulate(tunnel_g))
```

---

```python
# Alternative 2
# Adds a sub-curve to a tunnel cross section

# Example 1
# Creates an empty tunnel object and then adds a line sub-curve to tunnel's cross section. Finally, tabulate the tunnel, segment properties
tunnel_g = g_i.tunnel(0, 0, 0)
subsectionpolycurve_g, segment_g = tunnel_g.CrossSection.addsubcurve("Line", 2, 3, 180, 1)

print(g_i.tabulate(tunnel_g))
print(g_i.tabulate(segment_g))

# Example 2
# Creates an empty tunnel object and then adds an arc sub-curve to tunnel's cross section.  Finally, tabulate the tunnel, segment properties
tunnel_g = g_i.tunnel(1, 1, 1)
subsectionpolycurve_g, segment_g = tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)

print(g_i.tabulate(tunnel_g))
print(g_i.tabulate(segment_g))
```

# Python wrapper commands [ADDTUNNELPHASEROUTINE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## addtunnelphaseroutine
Adds a phase routine to a tunnel sequence.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates an empty tunnel object and then adds a adds sub-curve to tunnel's cross section. Finally, adds a tunnel phase routine to define the tunnel sequencing

tunnel_g = g_i.tunnel(6, 2, 3)
tunnel_g.CrossSection.addsubcurve("Line", 2, 3, 180, 1)
tunnel_g.PhasesDefinition.addtunnelphaseroutine()

print(g_i.echo(tunnel_g))
```

# Python wrapper commands [ADDTUNNELPHASESTEP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## addtunnelphasestep
Adds a phase step to a tunnel sequence.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates an empty tunnel object and then adds a adds sub-curve to tunnel's cross section. Finally, adds a tunnel phase step to define the tunnel sequencing
tunnel_g = g_i.tunnel(6, 2, 3)
tunnel_g.CrossSection.addsubcurve("Line", 2, 3, 180, 1)
tunnel_g.PhasesDefinition.addtunnelphasestep()

print(g_i.echo(tunnel_g))
```

# Python wrapper commands [ADDWATERPOINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## addwaterpoint
Adds a point to a water level.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates a volume object (cuboid), then changes a mode, creates two water levels and adds water point to one of them, with pressure increment value -5
g_i.cuboid(10)
g_i.gotoflow()
waterlevel1_s = g_i.waterlevel((6, 4, 1), 2)
waterlevel2_s = g_i.waterlevel(1, 4, 6)
waterlevel2_s.addwaterpoint((2, 3, 6), -5)

print(g_i.echo(waterlevel1_s, waterlevel2_s))
```

# Python wrapper commands [ADVANCE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## advance
Advances to next tunnel step.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates a tunnel, adds cross sections to it. Changes radius. Then adds trajectory, defines it as a line with length of 25, and generates tunnel
tunnel_g = g_i.tunnel((-44, 29, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4
tunnel_g.Trajectory.add()
tunnel_g.Trajectory.Segments[0].LineProperties.Length = 25
g_i.generatetunnel(tunnel_g)

# Adds phase steps and routine 7 times, then changes to staged construction mode, creates 7 phases and displays feedback on advancing the tunnel in all 7 phases
for i in range(7):
    tunnel_g.PhasesDefinition.addtunnelphasestep()
    tunnel_g.PhasesDefinition.addtunnelphaseroutine()

g_i.gotostages()

phases_s = [g_i.phase(g_i.Phases[i]) for i in range(7)]

for i in range(7):
    g_i.advance(tunnel_g, phases_s[i])

print(g_i.echo(tunnel_g))
```

# Python wrapper commands [ALLOCMEM]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## allocmem
Tests if it is possible to allocate a specific amount of additional memory.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Tries to allocate additional 64 MB of memory

try:
    g_i.allocmem(64)
except:
    print("Allocated 64 MB")
```

# Python wrapper commands [ANCHORMAT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## anchormat
Creates an anchor material set.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates an anchor material set with no specified properties. It is not possible to calculate with this material before editing it to make its properties valid

g_i.anchormat("Identification", "AnchorRod", "MaterialType", "Elastic", "EA", 500000)
```

# Python wrapper commands [APPLY]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## apply
Applies a command to multiple objects at once.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates 3 points, and then sets "x" coordinate to 3 for all points in the project
point1_g, point2_g, point3_g = g_i.point((6, 4, 7), (9, 8, 9), (4, 1, 1))
points_g = g_i.Points
print(g_i.apply(points_g, "setproperties", "x", 3))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Applies a command to multiple objects at once

# Example 1
# Clears the drawing area, creates 2 plates. Then changes mode, creates 5 phases and changes Solver property to 1 (Pardiso) in each phase
g_i.clear()
plate1_g = g_i.plate((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
plate2_g = g_i.plate((0, 0, 0), (0, 0, 2), (2, 0, 2), (2, 0, 0))
g_i.gotostages()
phaseobjects_s = [g_i.phase(g_i.Phases[i]) for i in range(5)]
phases_s = g_i.Phases
g_i.apply(phases_s, "setproperties", "Solver", 1)

print(g_i.tabulate(phases_s, "Solver"))

# Example 2
# Changes the mode, creates two lines, and assigns n2n anchor features to them
g_i.gotostructures()
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1] 
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
g_i.n2nanchor(line1_g, line2_g)
points_g = g_i.Points

# Changes the mode, creates 5 phases and checks Adjust prestress checkbox for n2n anchor (NodeToNodeAnchor_1_1) in phase with index 1
g_i.gotostages()
phases_s = [g_i.phase(g_i.Phases[i]) for i in range(5)]
nodetonodeanchors_s = g_i.NodeToNodeAnchors

g_i.apply(nodetonodeanchors_s, "sps", "AdjustPrestress", phases_s[1], True)
print(g_i.tabulate(nodetonodeanchors_s, phases_s[1]))
```

# Python wrapper commands [ARRAYP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## arrayp
Creates a polar array from one or more objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a line, and then copies and arranges it in a polar array (4 elements, 180 degrees arc, rotation enabled).
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1] # Creates multiple objects, the last one is the Line object
res = g_i.arrayp(line_g, (0, 0, 0), (0, 0, 1), 180, 4, True)

# Groups all line type objects into group of Lines (lines_g)
lines_g = [item for item in res if item._plx_type == 'Line']

print(g_i.echo(lines_g))
```

# Python wrapper commands [ARRAYR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## arrayr
Creates a rectangular array from one or more objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates an array from a borehole, with a specified number of new boreholes at a specified interval

# Creates a borehole, and then copies and arranges it in a rectangular array (1 unit in x direction, and 5 in y, 2 elements). Displays new boreholes' details in the memory
borehole1_g = g_i.borehole(2, 3)
g_i.arrayr(borehole1_g, 3, 1, 5)
boreholes_g = g_i.Boreholes

print([item for item in boreholes_g])
```

---

```python
# Alternative 2
# Creates an array from a selected object, with a specified number of new objects at a specified interval

# Creates an array from a point object with 2 newly created points at an interval of (1, 5, 0).
point_g = g_i.point(1, 1, 1)
points_g = g_i.arrayr(point_g, 2, (1, 5, 0))

print(g_i.tabulate(point_g, points_g))
```

---

```python
# Alternative 3
# Creates an array from a selected object, with a specified number of rows and columns at the specified intervals

# Creates a point, and then copies and arranges it in a rectangular array in two directions (2x3 elements). Displays new points' details
point_g = g_i.point(2, 3, 4)
points_g = g_i.arrayr(point_g, 2, (1, 5, 0), 3, (6, 4, 8))

print(g_i.tabulate(points_g))
```

---

```python
# Alternative 4
# Creates a three-dimensional array from a selected object, with a specified number of rows, columns and pages at the specified intervals

# Creates point and then creates a three-dimensional array from it with 2 rows at an interval of (1, 5, 0), 3 columns at an interval of (6, 4, 8) and 5 levels at an interval of (7, 10, 9).
point_g = g_i.point(2, 3, 4)
points_g = g_i.arrayr(point_g, 2, (1, 5, 0), 3, (6, 4, 8), 5, (7, 10, 9))

print(g_i.tabulate(points_g))
```

# Python wrapper commands [BEAM]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## beam
Adds beam features to lines.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds beam features to one or more existing lines in the geometry

# Example 1
# Creates two points and a line, gets a line (last object = [-1]). Displays beam's details
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
beam_g = g_i.beam(line_g)

print(g_i.echo(beam_g))

# Example 2
# Creates two points and a line, gets the line (lastly created object = [-1]). Then creates two more lines, adds all line type objects into group of Lines (lines_g)
line1_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']

# Assigns beam feature to mentioned lines. Displays beam's details
beams_g = g_i.beam(line1_g, lines_g[-2], lines_g[-1])

print(g_i.echo(beams_g))

# Example 3
# Creates two lines, assigns beam feature to mentioned lines. Displays beam's details
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1] 
beams_g = g_i.beam((line1_g, line2_g))

print(g_i.echo(beams_g))

# Example 4
# Creates two lines and then groups them. Assigns beam feature to a group (elements in a group). Displays beam's details
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
group_g = g_i.group(line1_g, line2_g)
beams_g = g_i.beam(group_g)

print(g_i.echo(beams_g))
```

---

```python
# Alternative 2
# Creates a line between two points (which may either exist or will be created) and adds a beam feature to it

# Example 1
# Creates a point, then creates multiple objects, last two are Line and Beam objects respectively (beam assigned to a line). Displays beam's and line's details
point1_g = g_i.point(3, 4, 9)
line_g, beam_g = g_i.beam(point1_g, (5, 6, 7))[-2:]

print(g_i.echo(line_g, beam_g))

# Example 2
# Creates two points, then creates multiple objects, last two are Line and Beam objects respectively (beam assigned to a line)
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
line_g, beam_g = g_i.beam(point1_g, point2_g)

print(g_i.echo(line_g, beam_g))

# Example 3
# Creates two points, then creates multiple objects, last two are Line and Beam objects respectively (beam assigned to a line)
line_g, beam_g = g_i.beam((1, 4, 0), (6, 5, 8))[-2:]

print(g_i.echo(line_g, beam_g))
```

---

```python
# Alternative 3
# Creates lines between three or more points (which may either exist or will be created) and add beam features to them

# Example 1
# Creates two points, then creates two lines (point1_g-(5.1, 6.4, 7.2), and (5.1, 6.4, 7.2)-point2_g) and assigns beams to those lines
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 5)
g_i.beam(point1_g, (5.1, 6.4, 7.2), point2_g)

# Stores all line type objects in lines_g, and all beams type objects in beams_g. Displays lines' and beam's details
lines_g = g_i.Lines
beams_g = g_i.Beams

print(g_i.echo([item for item in lines_g]))
print(g_i.echo([item for item in beams_g]))
```

---

```python
# Alternative 4
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect
# to the XY- and the XZ-plane and a length or a vector describing the direction and a length and add beam features to them.

# Example 1
# Creates multiple objects, last two are Line and Beam objects respectively, assigns beams to the line
line_g, beam_g = g_i.beam((1, 2, 0), "relative", (3, 4, 8))[-2:]
print(line_g, beam_g)

# Example 2
# Creates a point, then creates two lines (point_g-(6,8,17), and (6,8,17)-(1,-1,27), and (1,-1,27)-(14,86,-1,35)) and assigns beams to those lines
point_g = g_i.point(3, 4, 9)
res = g_i.beam(point_g, "relative", (3, 4, 8), (-5, -9, 10), "angles", 0, 30, 16)

# Stores all line type objects in lines_g, and all beams type objects in beams_g. Displays lines' and beam's addresses in the memory
lines_g = [item for item in res if item._plx_type == 'Line']
beams_g = [item for item in res if item._plx_type == 'Beam']
print(lines_g, beams_g)

# Example 3
# Creates two lines and assigns beams to them. Displays their addresses in the memory
res = g_i.beam((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
beams_g = [item for item in res if item._plx_type == 'Beam']
print(lines_g, beams_g)

# Example 4
# Creates a point, volume and soil objects, the first one is the volume object ([0])
point_g = g_i.point(1, 2, 1)
volume_g = g_i.sphere(5)[0]

# Creates a line (point_g, angles, and snaps to a volume) and a beam. Assigns the beam to the line.
line_g, beam_g = g_i.beam(point_g, "angles", 90, 0, volume_g)[-2:]
print(line_g, beam_g)

# Obtain ApplyStrengthReduction property value assigned for all beams in a list and display them
beams_strength_reduction = g_i.Beams.ApplyStrengthReduction.value
print(f'Beams strength reduction property: {beams_strength_reduction}')

# Example 5
# Creates a beam starting from an existing point and with a vector towards an existing volume
point_g, line_g, beam_g = g_i.beam(g_i.Points[-4], "vector", (-1, -1, -1), volume_g)
print(point_g, line_g, beam_g)
```

---

```python
# Alternative 5
# Adds beam features to one or more existing lines in the geometry and directly set their properties

# Example 1
# Creates multiple objects, the last one is the Line object. Then creates beam material, and in using one functions assigns beam to the line and created material to the beam
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
beammaterial_i = g_i.beammat()
beam_g = g_i.beam(line_g, "Material", beammaterial_i)

print(beam_g)

# Example 2
# Creates two lines, creates beam material, and in using one functions assigns beam to those lines and created material to the beam
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
beammaterial_i = g_i.beammat()
beams_g = g_i.beam((line1_g, line2_g), "Material", beammaterial_i)

print(beams_g)

# Obtain Materials assigned for all beams in a list and display them
beam_materials_assigned = [material.Name.value for material in g_i.Beams.Material.value if material]
print(f'Beam Materials assigned: {beam_materials_assigned}')
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Creates a line between two points, add a beam feature to it and directly set its properties

# Creates a point and a beam material. Then, using one function creates a line from an existing point and point (5, 6, 7), assigns beam feature to this line, and assigns material to the beam
point_g = g_i.point(3, 4, 9)
beammaterial_i = g_i.beammat()
line_g, beam_g = g_i.beam(point_g, (5, 6, 7), 
                          "Material", beammaterial_i)[-2:]
print(g_i.echo(line_g, beam_g))
```

---

```python
# Alternative 7
# Creates lines between three or more points, add beam features to them and directly set their properties

# Creates two points and a beam material
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 2, 1)
beammaterial_i = g_i.beammat()
# Using one function, creates two lines (point1_g-(5.1, 6.4, 7.2), and (5.1, 6.4, 7.2)-point2_g), assigns beam features to those lines, and assigns material to the beams
res = g_i.beam(point1_g, (5.1, 6.4, 7.2), point2_g, "Material", beammaterial_i)

# Assigns all lines to lines_g and all beams to beams_g. Displays their addresses in the memory
lines_g = [item for item in res if item._plx_type == 'Line']
beams_g = [item for item in res if item._plx_type == 'Beam']

print(lines_g, beams_g)
```

---

```python
# Alternative 8
# Creates one or more lines by giving absolute coordinates or relative coordinates, by giving the angles with respect to the XY- and the XZ-plane and a length or a vector describing the direction and a length, add beam features to them and directly set their properties

# Creates a beam material, and then using one function, creates a line using relative coordinates assigns beam feature to this line, and assigns material to the beam
beammaterial_i = g_i.beammat()
line_g, beam_g = g_i.beam((1, 2, 0), "relative", (3, 4, 8), 
                          "Material", beammaterial_i)[-2:]
print(line_g, beam_g)
```

# Python wrapper commands [BEAMMAT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## beammat
Creates a beam material set.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a beam material set with no specified properties. It is not possible to calculate with this material before editing it to make its properties valid

g_i.beammat("Identification", "Strut", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5)
```

# Python wrapper commands [BOREHOLE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## borehole
Creates a borehole.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a borehole.

# Creates a borehole at coordinates (1, 4).
borehole_g = g_i.borehole(1, 4)

print(g_i.echo(borehole_g))
```

# Python wrapper commands [CABLE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## cable
Adds cable features to lines.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds cable features to one or more existing lines in the geometry.

# Example 1
# Adds a cable feature to Line_1
line_g = g_i.line((0, 0, 0), (1, 1, 0))[-1]
cable_g = g_i.cable(line_g)
print(cable_g)

# Example 2
# Adds cable features to two lines created
line1_g = g_i.line((0, 2, 0), (2, 2, 0))[-1]
line2_g = g_i.line((2, 2, 0), (2, 0, 0))[-1]
cables_g = g_i.cable(line1_g, line2_g)
print(cables_g)

# Example 3
# Creates a new line between two points with coordinates (1, 4) and (2, 3) and adds a cable feature to it. The last object created is the Cable object ([-1])
cables_g = g_i.cable(1, 4, 0, 2, 3, 0)[-1]
print(cables_g)

# Example 3
# Creates a new line between two points with coordinates (1, 4) and (2, 3) and adds a cable feature to it. The last object created is the Cable object ([-1])
point_g = g_i.point(0, 0, 2)
cable_g = g_i.cable(g_i.Points[0], 3, 4, 2)[-1]
print(cable_g)

# Example 4
# Creates a line from a new point with coordinates (1, 2) to another new point which is 3 in the x- and 4 in the y-direction relatively to the previous point and adds a cable feature to it. The last object created is the Cable object ([-1])
cable_g = g_i.cable((1, 2, 3), "relative", (3, 4, 3))[-1]
print(cable_g)

# Example 5
point_g = (1, 2)
res = g_i.cable((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
cables_g = [item for item in res if item._plx_type == 'Cable']
print(cables_g)

# Example 6
# Creates lines between three or more points (which may either exist, or will be created) and add cable features to them.
point_g = (1, 2, 5)
res = g_i.cable(point_g, "relative", (3, 4, 8), (-5, -9, 10), "angles", 0, 30, 16)
cables_g = [item for item in res if item._plx_type == 'Cable']
print(cables_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Adds cable features to one or more existing lines in the geometry and directly set their properties.

# Example 1
# Adds a cable feature to a created line and sets the material, the last object created is the cable object 
line_g = g_i.line((2, 2, 0), (3, 3, 0))[-1] 
material_i = g_i.cablemat()
cable_g = g_i.cable(line_g, "Material", material_i)
print(cable_g)

# Example 2
# Creates multiple objects, the last one is the cable object list
line1_g = g_i.line((2, 4, 0), (3, 4, 0))[-1]
line2_g = g_i.line((0, 2, 0), (1, 2, 0))[-1]
material_i = g_i.cablemat()
cables_g = g_i.cable((line1_g, line2_g), "Material", material_i)
print(cables_g)

# Example 3
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect 
# to the xy-plane and a length or a vector describing the direction and a length, add cable features to them and directly set their properties.
# Creates multiple objects, the last one is the Cable object ([-1])
material_i = g_i.cablemat()
cable_g = g_i.cable((1, 2, 5), "relative", (3, 4, 8), "Material", material_i)[-1]
print(cable_g)
```

# Python wrapper commands [EMBEDDEDBEAMMAT]
The remote scripting server in PLAXIS 2D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## cablemat
Creates a cable material set.

---

```python
s_i.new()
```

---

```python
# Alternative 1
g_i.cablemat("Identification", "Cable", "MaterialType", "Elastoplastic", "Diameter", 0.0125, "E", 98600000, "Nptens", 232.1, "KsBond", 11200, "CohesiveStrengthBond", 175)
```

# Python wrapper commands [CALCULATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## calculate
Calculates all phases that are currently marked for calculation.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Calculates all phases that are currently marked for calculation

# Example 1
# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes mode to structures and creates a line load. Then in mesh mode, generates mesh
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Changes mode to staged construction and creates a phase. Then, activates a line load in a created phase. Calculates the project
g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
g_i.LineLoads[-1].Active[phase1_s] = True
g_i.calculate()

# Obtain identification values for each phase in a list and display them
phase_ids = g_i.Phases.Identification.value

print(f'Phase Identification values: {phase_ids}')
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Calculates one or more explicitly specified phases, regardless of whether they are currently marked for calculation

# Example 1
# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes mode to structures and creates two line loads. Then in mesh mode, generates mesh
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.lineload((4, 4, 0), (7, 8, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Changes mode to staged construction and creates 5 phases. Then, activates a line load in a created phase. Calculates the project
g_i.gotostages()
phases_s = [g_i.phase(g_i.Phases[i]) for i in range(5)]

# Creates one more phase that starts from Phase_1. Assigns the second line load from the end to lineload1_s, and the last to lineload2_s
phases_s.append(g_i.phase(g_i.Phases[1]))
lineload1_s = g_i.LineLoads[-2]
lineload2_s = g_i.LineLoads[-1]

# Activates line loads in different phases. Calculates initial phase, and then the first and the last (that starts from the first)
lineload1_s.Active[phases_s[0]] = True
lineload2_s.Active[phases_s[5]] = True
g_i.calculate(g_i.Phases[0])
g_i.calculate(phases_s[0], phases_s[5])

# Obtain identification values for each phase in a list and display them
phase_ids = g_i.Phases.Identification.value

print(f'Phase Identification values: {phase_ids}')
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Calculates all phases that are currently marked for calculation with the possibility to also calculate the phases that are currently not marked for calculation

# Example 1
# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes mode to structures and creates a line load. Then in mesh mode, generates mesh
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Changes mode to staged construction and creates a phase. Then, activates a line load in a created phase.
g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
g_i.LineLoads[-1].Active[phase1_s] = True
# Calculates all phases regardless of whether they are currently marked for calculation 
print(g_i.calculate(True))

# Example 2
# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
s_i.new()
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes mode to structures and creates a line load. Then in mesh mode, generates mesh
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Changes mode to staged construction and creates a phase. Then, activates a line load in a created phase. Calculates the project
g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
g_i.LineLoads[-1].Active[phase1_s] = True

# Calculates only phases that are currently marked for calculation 
g_i.calculate(False)

# Obtain identification values for each phase in a list and display them
phase_ids = g_i.Phases.Identification.value

print(f'Phase Identification values: {phase_ids}')
```

# Python wrapper commands [CALCULATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## calculate
Calculates all phases that are currently marked for calculation.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Calculates all phases that are currently marked for calculation

# Example 1
# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes mode to structures and creates a line load. Then in mesh mode, generates mesh
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Changes mode to staged construction and creates a phase. Then, activates a line load in a created phase. Calculates the project
g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
g_i.LineLoads[-1].Active[phase1_s] = True
g_i.calculate()

# Obtain identification values for each phase in a list and display them
phase_ids = g_i.Phases.Identification.value

print(f'Phase Identification values: {phase_ids}')
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Calculates one or more explicitly specified phases, regardless of whether they are currently marked for calculation

# Example 1
# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes mode to structures and creates two line loads. Then in mesh mode, generates mesh
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.lineload((4, 4, 0), (7, 8, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Changes mode to staged construction and creates 5 phases. Then, activates a line load in a created phase. Calculates the project
g_i.gotostages()
phases_s = [g_i.phase(g_i.Phases[i]) for i in range(5)]

# Creates one more phase that starts from Phase_1. Assigns the second line load from the end to lineload1_s, and the last to lineload2_s
phases_s.append(g_i.phase(g_i.Phases[1]))
lineload1_s = g_i.LineLoads[-2]
lineload2_s = g_i.LineLoads[-1]

# Activates line loads in different phases. Calculates initial phase, and then the first and the last (that starts from the first)
lineload1_s.Active[phases_s[0]] = True
lineload2_s.Active[phases_s[5]] = True
g_i.calculate(g_i.Phases[0])
g_i.calculate(phases_s[0], phases_s[5])

# Obtain identification values for each phase in a list and display them
phase_ids = g_i.Phases.Identification.value

print(f'Phase Identification values: {phase_ids}')
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Calculates all phases that are currently marked for calculation with the possibility to also calculate the phases that are currently not marked for calculation

# Example 1
# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes mode to structures and creates a line load. Then in mesh mode, generates mesh
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Changes mode to staged construction and creates a phase. Then, activates a line load in a created phase.
g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
g_i.LineLoads[-1].Active[phase1_s] = True
# Calculates all phases regardless of whether they are currently marked for calculation 
print(g_i.calculate(True))

# Example 2
# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
s_i.new()
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes mode to structures and creates a line load. Then in mesh mode, generates mesh
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Changes mode to staged construction and creates a phase. Then, activates a line load in a created phase. Calculates the project
g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
g_i.LineLoads[-1].Active[phase1_s] = True

# Calculates only phases that are currently marked for calculation 
g_i.calculate(False)

# Obtain identification values for each phase in a list and display them
phase_ids = g_i.Phases.Identification.value

print(f'Phase Identification values: {phase_ids}')
```

# Python wrapper commands [checkcalculationconditions]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## checkcalculationconditions
Performs the pre-calculation checks on conditions and settings of the defined phases.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Performs the pre-calculation checks on conditions and settings of the defined phases.

# Creates a borehole, soillayer, assigns material to the soil and creates lineload, anchor and plate features
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 0, 0), (7, 0, 0))
g_i.n2nanchor((3, 2, 0), (7, 2, 0))
g_i.plate((0, 0, 0), (1, 1, 0), (2, 0, 0))

# Generates the mesh, defines the phases, activates the line load
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.LineLoads[-1].Active[phase1_s] = True

print(g_i.checkcalculationconditions())
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Performs the pre-calculation checks on conditions and settings of the specified phases.

# Creates a borehole, soillayer, assigns material to the soil and creates lineload, anchor and plate features
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 0, 0), (7, 0, 0))
g_i.n2nanchor((3, 2, 0), (7, 2, 0))
g_i.plate((0, 0, 0), (1, 1, 0), (2, 0, 0))

# Generates the mesh, defines the phases, activates the line load
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.LineLoads[-1].Active[phase1_s] = True

print(g_i.checkcalculationconditions(phase1_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Performs the pre-calculation checks on conditions and settings of the phases and reports the selected level of check: errors, warnings, hints and tips.

# Creates a borehole, soillayer, assigns material to the soil and creates lineload, anchor and plate features
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 0, 0), (7, 0, 0))
g_i.n2nanchor((3, 2, 0), (7, 2, 0))
g_i.plate((0, 0, 0), (1, 1, 0), (2, 0, 0))

# Generates the mesh, defines the phases, activates the line load
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.LineLoads[-1].Active[phase1_s] = True

print(g_i.checkcalculationconditions(phase1_s, "errors"))
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Performs the pre-calculation checks on conditions and settings of all phases and reports the selected level of check: errors, warnings, hints and tips.

# Creates a borehole, soillayer, assigns material to the soil and creates lineload, anchor and plate features
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 0, 0), (7, 0, 0))
g_i.n2nanchor((3, 2, 0), (7, 2, 0))
g_i.plate((0, 0, 0), (1, 1, 0), (2, 0, 0))

# Generates the mesh, defines the phases, activates the line load
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.LineLoads[-1].Active[phase1_s] = True

print(g_i.checkcalculationconditions("warnings"))
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Performs the pre-calculation checks on conditions and settings of the phases listable.

# Creates a borehole, soillayer, assigns material to the soil and creates lineload, anchor and plate features
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 0, 0), (7, 0, 0))
g_i.n2nanchor((3, 2, 0), (7, 2, 0))
g_i.plate((0, 0, 0), (1, 1, 0), (2, 0, 0))

# Generates the mesh, defines the phases, creates a group of multiple phases
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phases_s = [g_i.phase(phase0_s) for i in range(4)]
group_s = g_i.group(phase0_s, phases_s[0], phases_s[1])

print(g_i.checkcalculationconditions(group_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Performs the pre-calculation checks on conditions and settings of the phases listable and reports the selected level of check: errors, warnings, hints and tips.

# Creates a borehole, soillayer, assigns material to the soil and creates lineload, anchor and plate features
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 0, 0), (7, 0, 0))
g_i.n2nanchor((3, 2, 0), (7, 2, 0))
g_i.plate((0, 0, 0), (1, 1, 0), (2, 0, 0))

# Generates the mesh, defines the phases, creates a group of multiple phases
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phases_s = [g_i.phase(phase0_s) for i in range(4)]
group_s = g_i.group(phase0_s, phases_s[2])

print(g_i.checkcalculationconditions(group_s, "errors"))
```

# Python wrapper commands [CHECKGEOMETRY]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## checkgeometry
Checks geometry consistency. Checks if objects overlap or are adjacent and then returns them.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Checks if objects overlap or are adjacent and then returns them

# Creates a surface and two points and then check geometry, and returns them
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
g_i.point((0.01, 0.01, 0.01), (0.01, 2.01, 0.01))

print(g_i.checkgeometry())
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Checks geometry consistency. Checks if objects overlap or are adjacent to a maximum distance between two objects and then returns them

# Creates a surface and two points and then check geometry with a maximum distance of 5, and returns them
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
g_i.point((1, 2, 3), (2, 1, 3))

print(g_i.checkgeometry(5))
```

# Python wrapper commands [CLEAR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## clear
Deletes all objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Deletes all objects that were created in the Soil mode and in the Structures mode. This action cannot be undone.

g_i.point(3, 4, 1)
g_i.line((5, 6, 7), (8, 9, 10))
g_i.clear()
```

# Python wrapper commands [CLEARMATERIAL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## clearmaterial
Clears the assignment of the Material property of any Soil or Structure object in any mode.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Clears the assignment of the Material property of a specific Soil object in Structures mode.

# Creates a borehole, soillayer, assigns material to the soil and clears the assignement of that Soil object.
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.clearmaterial(g_i.Soils[0])
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Clears the assignment of the Material property of a specific Structure object in Structures mode.

# Creates a borehole, soillayer, assigns material to the soil, creates a plate, creates the plate material, assigns the plate material to the plate and clears the assignement of that Structure object.
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

g_i.gotostructures()
plate_g = g_i.plate(0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 3, 0)
plate_mat = g_i.platemat()
plate_mat.setproperties("Identification", "Footing", "MaterialType", "Elastic", "Gamma", 25, "E1", 20000000, "D3d", 0.4, "StructNu12", 0.2)
g_i.Plates[0].Material = plate_mat
g_i.clearmaterial(g_i.Plates[0])
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Clear the assignment of the Material property of a Structure object in Structures mode.

# # Creates a borehole, soillayer, assigns material to the soil, creates two plates, creates one plate material, assigns the plate material to both Structure objects and clears the assignement of both Structure objects.
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

g_i.gotostructures()
plate1_g = g_i.plate(0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 3, 0)
plate2_g = g_i.plate(3, 0, 0, 5, 0, 0, 5, 3, 0, 3, 3, 0)
plate_mat = g_i.platemat()
plate_mat.setproperties("Identification", "Footing", "MaterialType", "Elastic", "Gamma", 25, "E1", 20000000, "D3d", 0.4, "StructNu12", 0.2)
g_i.Plates[0].Material = plate_mat
g_i.Plates[1].Material = plate_mat
g_i.clearmaterial(g_i.Plates[0], g_i.Plates[1])
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Clear the assignment of the Material property of a Soil and Structure object in two phases in Staged construction mode.

# Creates a borehole, soillayer, assigns material to the soil, creates two plates, creates one plate material and assigns the plate material to both Structure objects.
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

g_i.gotostructures()
plate1_g = g_i.plate(0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 3, 0)
plate2_g = g_i.plate(3, 0, 0, 5, 0, 0, 5, 3, 0, 3, 3, 0)
plate_mat = g_i.platemat()
plate_mat.setproperties("Identification", "Footing", "MaterialType", "Elastic", "Gamma", 25, "E1", 20000000, "D3d", 0.4, "StructNu12", 0.2)
g_i.Plates[0].Material = plate_mat
g_i.Plates[1].Material = plate_mat

# Generates the mesh, defines the phases, and clears the assignement of the Soil and one of the Structure objects in both phases in Staged construction mode.
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.clearmaterial((g_i.Soils[0], g_i.Plates[1]), (g_i.Phases[0], g_i.Phases[1]))
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Clear the assignment of the Material property of a Soil and Structure object in multiple phases in Staged construction mode.

# Creates a borehole, a soillayer, assigns the material to the soil, creates a plate, creates a plate material and assigns the plate material to the Structure objects.
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)

material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

g_i.gotostructures()
plate_g = g_i.plate(0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 3, 0)
plate_mat = g_i.platemat()
plate_mat.setproperties("Identification", "Footing", "MaterialType", "Elastic", "Gamma", 25, "E1", 20000000, "D3d", 0.4, "StructNu12", 0.2)
g_i.Plates[0].Material = plate_mat

# Generates the mesh, defines the phases, creates a group of both phases and clears the assignement of the group in Staged construction mode.
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.group(phase0_s, phase1_s)
g_i.clearmaterial((g_i.Soils[0], g_i.Plates[0]), (g_i.Groups[0]))
```

# Python wrapper commands [CLOSE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## close
Closes a polycurve.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Closes a polycurve by adding a line segment

# Creates multiple objects, the first one is the Polycurve object. Then, closes the polycurve and displays polycurve's details
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
segment_g = polycurve_g.close()

print(g_i.tabulate(polycurve_g))
```

---

```python
# Alternative 2
# Closes a polycurve by adding a line segment

# Creates multiple objects, the first one is the Polycurve object. Then, closes the polycurve using "line" parameter and displays polycurve's details
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
segment_g = polycurve_g.close("line")

print(g_i.tabulate(polycurve_g))
```

---

```python
# Alternative 3
# Closes a polycurve by adding an arc segment with a specified radius

# Creates a polycurve and then closes the polycurve with an arc with a radius of 5. Displays polycurve's details
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "arc", 45, 90, 3)[0]
segment_g = polycurve_g.close("arc", 5)
print(g_i.tabulate(polycurve_g))
```

# Python wrapper commands [COARSEN]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## coarsen
Requests a coarser mesh for a meshable object.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Requests a coarser mesh for a meshable object.

# Creates Volume and Soil objects, the first one is the Volume object
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]
g_i.gotomesh()

g_i.coarsen(volume_g)
```

# Python wrapper commands [COMBINE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## combine
Combines a number of objects to create a new object.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Combines two or more surfaces to create one new surface

polygon1_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
polygon2_g = g_i.surface((0, 0, 0), (0, 4, 0), (4, 4, 0), (4, 0, 0))
polygon_g = g_i.combine(polygon1_g, polygon2_g)

print(g_i.tabulate(polygon_g))
```

---

```python
# Alternative 2
# Combines two or more surfaces to create one new surface and optionally keep the original surfaces

polygon1_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
polygon2_g = g_i.surface((0, 0, 0), (0, 4, 0), (4, 4, 0), (4, 0, 0))
polygon_g = g_i.combine((g_i.Polygon_1, g_i.Polygon_2), True)

print(g_i.tabulate(polygon_g))
```

---

```python
# Alternative 3
# Combines two or more volumes to create one new volume

# Creates Volume and Soil objects; the first one is the Volume object ([0]). Then combines the volumes
volume1_g = g_i.cuboid(5)[0]
volume2_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
volume_g = g_i.combine(volume1_g, volume2_g)[0]

print(g_i.echo(volume_g))
```

---

```python
# Alternative 4
# Combines two or more volumes to create one new volume and optionally keep the original volumes

# Creates Volume and Soil objects; the first one is the Volume object. Then combines the volumes and keeps the original entities
volume1_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]
volume2_g = g_i.sphere(5)[0]
volume_g = g_i.combine((volume1_g, volume2_g), True)[0]

print(volume_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Combines two or more lines or polycurves to create new lines or polycurves and optionally keep the original entities

# Example 1
# Creates multiple objects, the last one is the Line object, then combines two lines creating a new line
line1_g = g_i.line((0, 0, 0), (2, 0, 0))[-1]
line2_g = g_i.line((2, 0, 0), (6, 0, 0))[-1]
line_g = g_i.combine(line1_g, line2_g)[-1]

print(g_i.tabulate(line_g))

# Example 2
# Creates multiple objects; the last one is the object, then combines two lines creating a new line
polycurve1_g = g_i.polycurve((0, 0, 0), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "line", 90, 2, "line", 90, 2)[0]
polycurve2_g = g_i.polycurve((0, 2, 0), (0, 0, 1), (1, 0, 0), "line", 180, 2)[0]
polycurve_g = g_i.combine(polycurve1_g, polycurve2_g)[0]

print(g_i.tabulate(polycurve_g))
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Combines two or more lines or polycurves to create new lines or polycurves and optionally keeps the original entities

# Example 1
# Creates two lines. Combines them into one line and deletes the original entities 
line1_g = g_i.line((0, 0, 0), (2, 0, 0))[-1]
line2_g = g_i.line((2, 0, 0), (6, 0, 0))[-1]

# Creates multiple objects, the last one is the Line object ([-1])
line_g = g_i.combine((line1_g, line2_g), False)[-1]
print(g_i.tabulate(line_g))

# Example 2
# Creates two polycurves. Combines them into one line and keeps the original entities
polycurve1_g = g_i.polycurve((0, 0, 0), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "line", 90, 2, "line", 90, 2)[0]
polycurve2_g = g_i.polycurve((0, 2, 0), (0, 0, 1), (1, 0, 0), "line", 180, 2)[0]

polycurve_g = g_i.combine(polycurve1_g, polycurve2_g, True)[0]
print(g_i.tabulate(polycurve_g))
```

# Python wrapper commands [COMMANDS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## commands
Displays available commands and their signatures.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays all available global commands for the current working mode with their corresponding signature(s)

print(g_i.commands())
```

---

```python
# Alternative 2
# Displays the signatures of one or more global commands

point_g = g_i.point(1, 1, 1)
print(point_g.commands())
```

---

```python
# Alternative 3
# Displays all available commands for an object with their signatures

# Example 1
print(g_i.commands("undo"))

# Example 2
print(g_i.commands("d"))
```

---

```python
# Alternative 4
# Identifies commands by part of their name and display the signatures of a specific command

point_g = g_i.point(1, 1, 1)
print(point_g.commands("m"))
```

# Python wrapper commands [CONE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## cone
Creates a cone.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a cone with a specified base radius and height at the origin (0, 0, 0)

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cone(2, 5)[0]

print(volume_g)
```

---

```python
# Alternative 2
# Creates a cone with a specified base radius and height at a specified location (x, y, z)

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cone(2, 5, (1, 2, 3))[0]

print(volume_g)
```

---

```python
# Alternative 3
# Creates a cone with a specified base radius and height at a specified location (x, y, z) in a specified direction described by a vector

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cone(2, 5, (1, 2, 3), (5, 7, 12))[0]

print(volume_g)
```

---

```python
# Alternative 4
# Creates a truncated cone with a specified base radius, a specified top circle base and height at the origin (0, 0, 0)

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cone(1.2, 8, 0.8)[0]

print(volume_g)
```

---

```python
# Alternative 5
# Creates a truncated cone with a specified base radius, a specified top circle base and height at a specified location (x, y, z)

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cone(1.2, 8, 0.8, (1, 2, 3))[0]

print(volume_g)
```

---

```python
# Alternative 6
# Creates a truncated cone with a specified base radius, a specified top circle base and height at a specified location (x, y, z) in a specified direction described by a vector

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cone(1.2, 8, 0.8, (1, 2, 3), (5, 7, 12))[0]

print(volume_g)
```

# Python wrapper commands [CONNECTION]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## connection
Creates a connection between two objects: the custom part and the reference part.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a connection between two staged user features: the custom part and the reference part

# Creates two polygons and plate material. Then, using one function assigns plate features to surfaces and materials to plates.
polygon1_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
polygon2_g = g_i.surface((0, 0, 0), (0, 0, 2), (2, 0, 2), (2, 0, 0))
platematerial = g_i.platemat()
plate1_g = g_i.plate(polygon1_g, "Material", platematerial)
plate2_g = g_i.plate(polygon2_g, "Material", platematerial)

# Changes the mode, creates a new phase and creates a connection between two plates
g_i.gotostages()
phase_1 = g_i.phase(g_i.Phases[-1])
g_i.setcurrentphase(phase_1)
plate1_s = g_i.Plates[-2]
plate2_s = g_i.Plates[-1]
g_i.activate(g_i.Geometry, g_i.Phases[-1])

connection_s = g_i.connection(plate1_s, plate2_s)
print(g_i.tabulate(connection_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Creates a connection between two cut objects

# Creates two polygons and plate material. Then, using one function assigns plate features to surfaces and materials to plates.
polygon1_g = g_i.surface((0, -2, 0), (0, 2, 0), (2, 2, 0), (2, -2, 0))
polygon2_g = g_i.surface((0, 0, 0), (0, 0, 2), (2, 0, 2), (2, 0, 0))
platematerial = g_i.platemat()
plate1_g = g_i.plate(polygon1_g, "Material", platematerial)
plate2_g = g_i.plate(polygon2_g, "Material", platematerial)

# Changes the mode, creates a new phase and creates a connection between two polygons
g_i.gotostages()
phase_1 = g_i.phase(g_i.Phases[-1])
g_i.setcurrentphase(phase_1)
polygon1_s = g_i.Surfaces[-2]
polygon2_s = g_i.Surfaces[-1]
g_i.activate(g_i.Geometry, g_i.Phases[-1])

connection_s = g_i.connection(polygon1_s, polygon2_s)
print(g_i.tabulate(connection_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Creates a connection between a beam and a plate object

# Creates one polygon, a line along with a plate and a beam with their materials. Then, assigns the materials accordingly.
polygon1_g = g_i.surface((0, 0, 0), (0, 0, 2), (2, 0, 2), (2, 0, 0))
platematerial = g_i.platemat()
plate1_g = g_i.plate(polygon1_g, "Material", platematerial)
beam1_g = g_i.beam((1, 0, 1), (1, 2, 1))[-1]
beammaterial = g_i.beammat("MaterialType", "Elastic")
beam1_g.Material = beammaterial

# Changes the mode, creates a new phase and creates a connection between the beam and the plate object
g_i.gotostages()
phase_1 = g_i.phase(g_i.Phases[-1])
g_i.setcurrentphase(phase_1)
plate1_s = g_i.Surfaces[-1]
beam1_s = g_i.Lines[-1]
g_i.activate(g_i.Geometry, g_i.Phases[-1])

connection_s = g_i.connection(beam1_s, plate1_s)
print(g_i.tabulate(connection_s))
```

# Python wrapper commands [CONTRACTION]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## contraction
Adds contraction features to structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds contraction features to one or more existing structural surfaces in the geometry

# Example 1
# Creates a surface and adds a contraction feature to it
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
contraction_g = g_i.contraction(polygon_g)

print(g_i.tabulate(contraction_g))

# Example 2
# Creates two surfaces and adds a contraction features to them
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
contractions_g = g_i.contraction(polygon1_g, polygon2_g)

print(g_i.tabulate(contraction_g))

# Example 3
# Creates two surfaces and adds a contraction features to them
polygon1_g = g_i.surface((3, 2, 1), (6, 9, 11), (12, 11, 14))
polygon2_g = g_i.surface((0, 1, 0), (3, 7, 3), (9, 15, 12), (10, 8, 19))
contractions_g = g_i.contraction((polygon1_g, polygon2_g))

print(g_i.tabulate(contraction_g))

# Example 4
# Creates two surfaces, groups them, and adds a contraction features to all objects in the group
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
group_g  = g_i.group(polygon1_g, polygon2_g)
contractions_g = g_i.contraction(group_g)

print(g_i.tabulate(contraction_g))
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points and adds a contraction feature to it

# Creates two points, and then using one function, creates a surface from two existing points and one new, and adds a contraction feature to this surface
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
surface_g, contraction_g = g_i.contraction(point1_g, point2_g, (1, 0, 5))[-2:] # Creates multiple objects, last two are Surface and Contraction objects respectively

print(surface_g, contraction_g)
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and add a contraction feature to it

# Creates multiple objects; the first one is the Polycurve object. Then closes the polycurve and assigns contraction feature to it
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()
surface_g, contraction_g = g_i.contraction(polycurve_g)

print(surface_g, contraction_g)
```

---

```python
# Alternative 4
# Adds contraction features to one or more existing structural surfaces in the geometry and directly set their properties

# Example 1
# Creates a polygon and using one function adds a contraction feature to it and changes some properties
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
contraction_g = g_i.contraction(polygon_g, "Distribution", "Axial increment", 
                                "C_inc_axial", 2.1)
print(contraction_g)

# Example 2
# Creates two polygons and using one function adds a contraction features to them and changes some properties
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
contractions_g = g_i.contraction((polygon1_g, polygon2_g), "Distribution", 
                                "Axial increment", "C_inc_axial", 2.1)
print(contractions_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points, add a contraction feature to it and directly set its properties

# Creates two points and using one function adds a contraction features to a newly created polygon and changes some properties
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
surface_g, contraction_g = g_i.contraction(point1_g, point2_g, (1, 0, 5), "Distribution", 
                                           "Axial increment", "C_inc_axial", 2.1)
print(surface_g, contraction_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and add a contraction feature to it and directly set its properties

# Creates multiple objects; the first one is the Polycurve object. Then closes a polycurve, and adds contraction feature to it
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()
surface_g, contraction_g = g_i.contraction(polycurve_g, "Distribution", 
                                           "Axial increment", "C_inc_axial", 2.1)
print(surface_g, contraction_g)
```

# Python wrapper commands [COPYLAYERS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## copylayers
Copies the soil layer properties from one borehole to other boreholes.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and adds two soil layers to it. Then creates two more boreholes, and copies to them properties and layers of the first borehole
borehole1_g = g_i.borehole(1, 4)
g_i.soillayer(1)
g_i.soillayer(4)
soillayer1_g = g_i.Soillayers[-1]
soillayer2_g = g_i.Soillayers[-2]
borehole2_g = g_i.borehole(5, 0)
borehole3_g = g_i.borehole(10, 5)
g_i.soillayerheight(borehole1_g, soillayer1_g, 1)
g_i.soillayerheight(borehole1_g, soillayer2_g, 2)

g_i.copylayers(borehole1_g, (borehole2_g, borehole3_g))

print(g_i.tabulate(borehole1_g, borehole2_g, borehole3_g))
```

# Python wrapper commands [COUNT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## count
Displays the number of objects of a specified type that are present.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the number of objects of a specified type that are present

g_i.point(3, 4, 9)
g_i.point(5, 2, 10)
g_i.point(7, 3, 6)
points_g = g_i.Points
g_i.count(points_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Displays the number of objects of a specified type that are present and which fulfil a certain condition

# Example 1
# Creates points and counts point objects, which x > 0
g_i.point(3, 4, 9)
g_i.point(-4, 2, 10)
g_i.point(7, 3, 6)
points_g = g_i.Points
print(g_i.count(points_g, "x>0"))

# Example 2
# Creates surfaces and counts surface objects, which area < 0.05
g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfaces_g = g_i.Surfaces
print(g_i.count(surfaces_g, "Area<0.05"))
```

# Python wrapper commands [COUNTMESHNODES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## countmeshnodes
Displays the number of nodes at a specified location.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the number of nodes at a specified location.

# Creates multiple objects; the last one is the plate object
g_i.plate((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))[-1] 

g_i.gotomesh()
g_i.mesh(0.1)

# Display the number of nodes at (0, 0, 0).
g_i.countmeshnodes(0, 0, 0)
```

# Python wrapper commands [CREATEREACHEDWL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## createreachedwl
Creates a new water level at the position reached at the end of the previous phase. The location of the water level will be constant in the current phase.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Then changes a mode and sets some properties
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)

g_i.gotoflow()
refwaterlevel_s = g_i.waterlevel(1, 4, -5)
flowfunction_s = g_i.headfunction()
flowfunction_s.Signal = flowfunction_s.Signal.linear
flowfunction_s.Time = 5
flowfunction_s.Head = 5

# Sets water lever as time-dependent. Then changes the mode, creates 3 phases and changes time interval of Phase 2
refwaterlevel_s.TimeDependency = refwaterlevel_s.TimeDependency.timedependent
refwaterlevel_s.HeadFunction = flowfunction_s
g_i.gotostages()
phases_s = [g_i.phase(g_i.Phases[i]) for i in range(3)]
phases_s[0].TimeInterval = 5
phases_s[1].TimeInterval = 5

# Sets the position reached at the end of Phase_2. The location of the water level will be constant in Phase_3
waterlevel_s = g_i.createreachedwl(refwaterlevel_s, phases_s[1])

print(g_i.tabulate(waterlevel_s))
```

# Python wrapper commands [CREATEREACHEDWLANDCONTINUE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## createreachedwlandcontinue
Creates a new water level at the position reached at the end of the previous phase. The location of the water level in the current phase will change from that point on according to the flow function assigned to the original water level in the previous phase.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Then changes a mode and sets some properties
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)

g_i.gotoflow()
refwaterlevel_s = g_i.waterlevel(1, 4, -5)
flowfunction_s = g_i.headfunction()
flowfunction_s.Signal = flowfunction_s.Signal.linear
flowfunction_s.Time = 5
flowfunction_s.Head = 5

# Sets water lever as time-dependent. Then changes the mode, creates 3 phases and changes time interval of Phase 2
refwaterlevel_s.TimeDependency = refwaterlevel_s.TimeDependency.timedependent
refwaterlevel_s.HeadFunction = flowfunction_s
g_i.gotostages()
phases_s = [g_i.phase(g_i.Phases[i]) for i in range(3)]
phases_s[1].TimeInterval = 5

# Sets the position reached at the end of Phase_2. The location of the water level in Phase_2 will change from that point on according to the flow function assigned to the original water level in the previous phase
waterlevel_s = g_i.createreachedwlandcontinue(refwaterlevel_s, phases_s[2])

print(g_i.echo(waterlevel_s))
```

# Python wrapper commands [CUBOID]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## cuboid
Creates a cuboid.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a cuboid with side length at the origin (0, 0, 0)

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cuboid(2)[0] 
print(volume_g)
```

---

```python
# Alternative 2
# Creates a cuboid with a side length and at a specified location (x, y, z)

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cuboid(2, (1, 2, 3))[0]
print(volume_g)
```

---

```python
# Alternative 3
# Creates a cuboid with a side length at a specified location (x, y, z) in a specified direction described by a vector

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cuboid(2, (1, 2, 3), (5, 7, 12))[0]
print(volume_g)
```

---

```python
# Alternative 4
# Creates a cuboid with specified side lengths

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cuboid(2, 3, 5)[0]
print(volume_g)
```

---

```python
# Alternative 5
# Creates a cuboid with specified side lengths at a specified location (x, y, z)

# Creates Volume and Soil objects, the first one is the Volume object
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]
print(volume_g)
```

---

```python
# Alternative 6
# Creates a cuboid with specified side lengths at a specified location (x, y, z) in a specified direction described by a vector

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))[0]
print(volume_g)
```

# Python wrapper commands [CYLINDER]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## cylinder
Creates a cylinder.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a cylinder with a specified radius and a specified height at the origin (0, 0, 0)

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cylinder(2, 5)[0]
print(volume_g)
```

---

```python
# Alternative 2
# Creates a cylinder with a specified radius and height at a specified location (x, y, z)

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cylinder(2, 5, (1, 2, 3))[0]
print(volume_g)
```

---

```python
# Alternative 3 
# Creates a cylinder with a specified radius and height at a location (x, y, z) in a specified direction described by a vector

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
print(volume_g)
```

# Python wrapper commands [DEACTIVATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## deactivate
Deactivates features.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Deactivates one or more activatable objects in one or more phases

# Creates a polygon and assigns plate feature to it. Then changes the mode and creates phases, activates and deactivates plate in the chosen phases
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.plate(polygon_g)

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
plate_s = g_i.Plates[-1]
plate_s.activate(phase0_s, phase1_s)

plate_s.deactivate(phase0_s, phase1_s)
```

---

```python
# Alternative 2
# Deactivates list of activatable objects in one or more phases.

# Creates a cuboid and a volume extruded from a created surface. Next, creates phases, and activates all volumes in Phase_1
g_i.gotostructures()
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.extrude(polygon_g, (1, 0, 5))

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

volumes_s = g_i.Volumes
volumes_s.activate(phase1_s)
```

# Python wrapper commands [DECOMPOSEOUTL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## decomposeoutl
Creates an outline of one or more structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates a polygon and then decomposes it. Displays addresses in the memory of all created points, lines, and groups
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))

print(g_i.decomposeoutl(polygon_g))

# Example 2
# Creates two polygons and then decomposes them. Displays addresses in the memory of all created points, lines, and groups
polygon1_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
polygon2_g = g_i.surface((0, -2, 0), (0, 2, 0), (2, 2, 0), (2, -2, 0))

print(g_i.decomposeoutl(polygon1_g, polygon2_g))
```

# Python wrapper commands [DECOMPOSEPOLYCURVE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## decomposepolycurve
Decomposes one or more polycurves into separate segments.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates multiple objects; the first one is the Polycurve object. Displays addresses in the memory of all created points, lines, and groups
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
print(g_i.decomposepolycurve(polycurve_g))
```

# Python wrapper commands [DECOMPOSESRF]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## decomposesrf
Decomposes one or more volumes or structural surfaces into separate surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates two surfaces and decomposes them. Displays addresses in the memory of all created points, lines, and groups
polygon1_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
polygon2_g = g_i.surface((0, -2, 0), (0, 2, 0), (2, 2, 0), (2, -2, 0))

print(g_i.decomposesrf(polygon1_g, polygon2_g))

# Example 2
# Creates a volume and decomposes it into serapate surfaces
volume_g = g_i.cuboid(5)[0]

print(g_i.decomposesrf(volume_g))
```

# Python wrapper commands [DECOUPLEFROMGENERATOR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## decouplefromgenerator
Decouples one or more tunnels from the tunnel generator(s) into independent geometric objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a tunnel, adds sub-curve and sets some properties. Then adds trajectory segments and decouples the tunnel
tunnel_g = g_i.tunnel((-44, 29, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4
tunnel_g.Trajectory.add()
tunnel_g.Trajectory.Segments[0].LineProperties.Length = 25
g_i.generatetunnel(tunnel_g)
volume_g = g_i.Volumes[-1]

g_i.decouplefromgenerator(volume_g)
```

# Python wrapper commands [DELETE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## delete
Deletes objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Deletes one or more connections

# Creates a connection and then deletes it
polygon1_g = g_i.surface((0, -2, 0), (0, 2, 0), (2, 2, 0), (2, -2, 0))
polygon2_g = g_i.surface((0, 0, 0), (0, 0, 2), (2, 0, 2), (2, 0, 0))
platematerial = g_i.platemat()
plate1_g = g_i.plate(polygon1_g, "Material", platematerial)
plate2_g = g_i.plate(polygon2_g, "Material", platematerial)

g_i.gotostages()
polygon1_s = g_i.Surfaces[0]
polygon2_s = g_i.Surfaces[1]
connection_s = g_i.connection(polygon1_s, polygon2_s)

print(g_i.delete(connection_s))
```

---

```python
# Alternative 2
# Deletes a material

# Creates a material, sets its properties and then deletes it
material = g_i.soilmat()
material.setproperties("SoilModel", "Linear elastic", "gammaUnsat", 16, 
                       "gammaSat", 20, "Gref", 10000)
g_i.delete(material)
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Removes a tunnel part from a template tunnel cross section

# Creates a tunnel, tunnel cross section and tunnel parts and deletes a tunnel part
tunnel_g = g_i.tunnel((-44, 29, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.ShapeType.set("Template")
tunnel_g.CrossSection.add("Arc", 0, 180, 3, "Arc", 0, 180, 3)
tunnelpart_g = tunnel_g.SplittingDefinition.add()

tunnel_g.SplittingDefinition.delete(tunnelpart_g)
```

---

```python
# Alternative 4
# Deletes a time multiplier

# Example 1
displacementmultiplier_g = g_i.displmultiplier()
displacementmultiplier_g.setproperties("Signal", "Table")
displacementmultiplier_g.Table.add(6, 4)

g_i.delete(displacementmultiplier_g)

# Example 2
# Deletes load multiplier's table row with index 1, the target is a listable
loadmultiplier_g = g_i.loadmultiplier()
loadmultiplier_g.setproperties("Signal", "Table")
loadmultiplier_g.Table.insert(0)
loadmultiplier_g.Table.insert(1)
loadmultiplier_g.Table[0][1].set(7)

loadmultiplier_g.Table.delete(1)
```

---

```python
# Alternative 5

# Example 1
# Creates an empty load multiplier and adds one row to a table with values (0, 0). Finally, deletes the row's address in the memory
displacementmultiplier_g = g_i.displmultiplier()
displacementmultiplier_g.setproperties("Signal", "Table")
table_g = displacementmultiplier_g.Table
displacementmultiplier_g.Table.insert(0)
table_g.delete(0)
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Deletes a flow function

g_i.cuboid(5)
g_i.gotostages()
phase0_s = g_i.Phases[0]

phase1_s = g_i.phase(phase0_s)
g_i.delete(phase1_s)
```

---

```python
s_i.new()
```

---

```python
# Alternative 7
# Deletes one or more water levels

# Creates a volume, changes the mode. Then, creates a water level and deletes it
g_i.cuboid(10)
g_i.gotoflow()

waterlevel_s = g_i.waterlevel(1, 4, 6)
g_i.delete(waterlevel_s)
```

---

```python
s_i.new()
```

---

```python
# Alternative 8
# Deletes one or more features

# Example 1
# Creates a surface and assigns plate feature to it, then deletes the feature (leaving the surface)
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
plate_g = g_i.plate(polygon_g)
g_i.delete(plate_g)

# Example 2
point_g = g_i.point(3, 4, 9)
pointload_g = g_i.pointload(point_g)
g_i.delete(pointload_g)
```

---

```python
# Alternative 9
# Deletes one or more boreholes

borehole_g = g_i.borehole(1, 4)
g_i.delete(borehole_g)
```

---

```python
# Alternative 10
# Deletes a soil layer

# Creates a borehole and a soil layer, then deletes the soil layer
borehole_g = g_i.borehole(0,0)
g_i.soillayer(3)
soillayer_g = g_i.Soillayers[0]
g_i.delete(soillayer_g)
```

---

```python
# Altrnative 11
# Deletes a polycurve subsection from a template tunnel. 

# Creates an empty tunnel object and then adds a adds sub-curve to tunnel's cross section. Finally, deletes subsection's address in the memory
tunnel_g = g_i.tunnel(6, 2, 3)
subsectionpolycurve_g, segment_g = tunnel_g.CrossSection.addsubcurve()
tunnel_g.CrossSection.delete(subsectionpolycurve_g)
```

---

```python
# Alternative 12
# Deletes a movement function.

movementfunction_g = g_i.movementfunction()
g_i.delete(movementfunction_g)
```

---

```python
# Alternative 13
# Deletes one or more geometric entities

# Example 1
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
g_i.delete(polygon_g)

# Example 2
point_g = g_i.point((1, 2, 3))
g_i.delete(point_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 14
# Deletes a phase

# Goes to stages construction mode, creates a phase and deletes it
g_i.cuboid(5)
g_i.gotostages()
phase0_s = g_i.Phases[0]
phase1_s = g_i.phase(phase0_s)
g_i.delete(phase1_s)
```

---

```python
s_i.new()
```

---

```python
# Alternative 15
# Deletes a segment of a polycurve

# Creates a polycurve, assigns polycurve segments to a variable segment_g, and then deletes the first segment
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
segment_g = [polycurve_g.Segments[i] for i in range(2)]
g_i.delete(segment_g[0])
```

---

```python
# Alternative 16
# Deletes one ore more polycurve chains

tunnel_g = g_i.tunnel((-44, 29, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.add("arc", 0, 180, 3, "arc", 0, 180, 3)
polycurvechain_g = g_i.rockboltsperpendicular(tunnel_g.SliceSurfaces[0])[0]
g_i.delete(polycurvechain_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 17
# Deletes field data

fielddata_g = g_i.importfielddata(r"C:\PLAXIS3D\test.cpt")
g_i.delete(fielddata_g)
```

# Python wrapper commands [DELETEPOINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## deletepoint
Deletes a point of a polygon or water level.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Deletes a point of a polygon

polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
polygon_g.deletepoint(1)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Deletes a point of a water level

# Creates a cuboid od length 10 and then switches the mode to Flow conditions. Then, adds a waterlevel and deletes a point at index=1
g_i.cuboid(10)
g_i.gotoflow()
waterlevel_s = g_i.waterlevel((6, 4, 1),(1, 5, 5))
waterlevel_s.deletepoint(1)
```

# Python wrapper commands [DELRUNTIMETOGGLE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## delruntimetoggle
Removes a runtime toggle.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.delruntimetoggle("DISPLAY_BUILD_IN_CAPTION")
```

# Python wrapper commands [DISCHARGEFUNCTION]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dischargefunction
Adds a discharge function.

---

```python
s_i.new()
```

---

```python
# Alternative 1
for i in range(3):
    g_i.dischargefunction()

print(g_i.tabulate(g_i.FlowFunctions))

# Obtain Signal property value assigned for all discharge functions in a list and display them
dischargefunctions_signal = g_i.FlowFunctions.Signal.value
print(f'Discharge functions signal: {dischargefunctions_signal}')
```

# Python wrapper commands [DISPLMULTIPLIER]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## displmultiplier
Adds a displacement multiplier.

---

```python
s_i.new()
```

---

```python
# Alternative 1

for i in range(3):
    g_i.displmultiplier()

print(g_i.tabulate(g_i.DynamicMultipliers))

# Obtain Signal property value assigned for all discharge functions in a list and display them
displmultipliers_signal = g_i.DynamicMultipliers.Signal.value
print(f'Displacment multipliers signal: {displmultipliers_signal}')
```

# Python wrapper commands [DUMP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dump
Displays the details of an object.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays extended details of the project

print(g_i.dump())
```

---

```python
# Alternative 2
# Displays details of a specified object

# Creates multiple objects; the last one is the Line object
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]

print(line_g.dump())
```

---

```python
# Alternative 3
# Displays the details of one or more objects

point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))

print(g_i.dump(point1_g, point2_g))
```

# Python wrapper commands [DUMPBOREHOLES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpboreholes
Displays a list of all boreholes.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created boreholes

borehole1_g = g_i.borehole(1, 4)
borehole2_g = g_i.borehole(6, 4)

print(g_i.dumpboreholes())
```

# Python wrapper commands [DUMPCUTOBJECTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpcutobjects
Displays a list of all cut objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created cut objects

g_i.cuboid(5)
g_i.gotomesh()

print(g_i.dumpcutobjects())
```

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the bounding boxes of one or more specified cut objects in the staged construction

g_i.cuboid(5)
g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.gotostages()

surface_s = g_i.Surfaces[0]
volume_s = g_i.Volumes[0]

print(g_i.dumpcutobjects(surface_s, volume_s))
```

# Python wrapper commands [DUMPFIXEDENDANCHORS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpfixedendanchors
Displays a list of all fixed-end anchors

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created fixed-end anchors

point1_g = g_i.point(5, 6, 7)
point2_g = g_i.point(1, 2, 3)
fixedendanchor_g = g_i.fixedendanchor(point1_g, point2_g)

print(g_i.dumpfixedendanchors())
```

# Python wrapper commands [DUMPGEOGRIDS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpgeogrids
Displays a list of all geogrids

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created geogrids

polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
geogrids_g = g_i.geogrid(polygon1_g, polygon2_g)

print(g_i.dumpgeogrids())
```

# Python wrapper commands [DUMPGROUPS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpgroups
Displays a list of all groups

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created groups

# Creates a surface, then creates Volume and Soil objects, the first one is the Volume object ([0]), and a point
surface_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
volume_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0] 
point_g = g_i.point(2, 3, 4)

# Displays a list of all created groups
group_g = g_i.group(surface_g, volume_g, point_g)

print(g_i.dumpgroups())
```

# Python wrapper commands [DUMPLINEDISPLS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumplinedispls
Displays a list of all line displacements

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created line displacements

line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
linedisplacements_g = g_i.linedispl(line1_g, line2_g)

print(g_i.dumplinedispls())
```

# Python wrapper commands [DUMPLINELOADS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumplineloads
Displays a list of all line loads

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created line loads

point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
line_g = g_i.lineload(point1_g, point2_g)

print(g_i.dumplineloads())
```

# Python wrapper commands [DUMPLINES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumplines
Displays a list of all lines

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created lines

point1_g = g_i.point(5, 6, 7)
line1_g = g_i.line(point1_g, (8, 4, 12))[-1]

point2_g = g_i.point(2, 3, 4)
line2_g = g_i.line((1, 2, 3), point2_g)[-1]

line3_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]

print(g_i.dumplines())
```

# Python wrapper commands [DUMPMATERIALS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpmaterials
Displays a list of all materials

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created materials

g_i.soilmat("Identification", "Clay")
g_i.beammat("Identification", "Strut", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5) 

print(g_i.dumpmaterials())
```

# Python wrapper commands [DUMPMESHES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpmeshes
Displays the details of the mesh of a cut object.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the number of vertices and triangles in the mesh of a cut object

# Creates volume and soil objects; the last one is the soil object
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
volume_s = g_i.Volumes[-1]

print(volume_s.dumpmeshes())
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Displays the number of vertices and triangles in the mesh of a cut object and a list with all their details

# Creates volume and soil objects; the last one is the soil object
g_i.cuboid(5)
g_i.gotomesh()
volume_s = g_i.Volumes[-1]

print(volume_s.dumpmeshes(True))
```

# Python wrapper commands [DUMPN2NANCHORS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpn2nanchors
Displays a list of all node-to-node anchors

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created node-to-node anchors

line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
anchors_g = g_i.n2nanchor(line1_g, line2_g)

print(g_i.dumpn2nanchors())
```

# Python wrapper commands [DUMPNEGATIVEINTERFACES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpnegativeinterfaces
Displays a list of all negative interfaces

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created negative interfaces

polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
interfaces_g = g_i.neginterface(polygon1_g, polygon2_g)

print(g_i.dumpnegativeinterfaces())
```

# Python wrapper commands [DUMPPARAMOBJECT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpparamobject
Displays the details of parametric objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the type, number of faces, volume and area of a parametric object

# Creates multiple objects; the first one is the Volume object
volume_g = g_i.cuboid(5)[0]

print(volume_g.dumpparamobject())
```

---

```python
# Alternative 2
# Displays the type, number of faces, volume, area of a parametric object and detailed face data when set to true

# Creates multiple objects; the first one is the Volume object
volume_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
g_i.gotostages()
volume_s = g_i.Volumes[0]

print(volume_s.dumpparamobject(True))
```

# Python wrapper commands [DUMPPHASES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpphases
Displays the details of all phases

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created phases

volume_g = g_i.cuboid(5)
g_i.gotomesh()
volume_s = g_i.Volumes[0]
g_i.gotostages()
print(g_i.dumpphases())
```

# Python wrapper commands [DUMPPILES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumppiles
Displays the details of all embedded beams

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created embedded beams

line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
embeddedbeams_g = g_i.embeddedbeam(line1_g, line2_g)

print(g_i.dumppiles())
```

# Python wrapper commands [DUMPPOINTDISPLS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumppointdispls
Displays the details of all point displacements

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created point displacements

point1_g, point2_g = g_i.point((5, 4, 7), (6, 9, 10))
pointdisplacements_g = g_i.pointdispl((point2_g, point1_g))

print(g_i.dumppointdispls())
```

# Python wrapper commands [DUMPPOINTLOADS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumppointloads
Displays the details of all point loads

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created point loads

point1_g, point2_g = g_i.point((5, 4, 7), (6, 9, 10))
pointdisplacements_g = g_i.pointload((point2_g, point1_g))

print(g_i.dumppointloads())
```

# Python wrapper commands [DUMPPOINTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumppoints
Displays the details of all points

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created points

point1_g, point2_g = g_i.point((5, 4, 7), (6, 9, 10))

print(g_i.dumppoints())
```

# Python wrapper commands [DUMPPOSITIVEINTERFACES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumppositiveinterfaces
Displays a list of all positive interfaces

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created negative interfaces

polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
interfaces_g = g_i.posinterface(polygon1_g, polygon2_g)

print(g_i.dumppositiveinterfaces())
```

# Python wrapper commands [DUMPSOILLAYERS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpsoillayers
Displays the details of all soil layers

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created soil layers

borehole_g = g_i.borehole(1, 4)
boreholevolume_g = g_i.soillayer(3)

print(g_i.dumpsoillayers())
```

# Python wrapper commands [DUMPSOILVOLUMES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpsoilvolumes
Displays the details of all soil volumes

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created soil volumes

borehole_g = g_i.borehole(1, 4)
boreholevolume_g = g_i.soillayer(3)

print(g_i.dumpsoilvolumes())
```

# Python wrapper commands [DUMPSURFACES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpsurfaces
Displays the details of all surfaces

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created surfaces

point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
point3_g = g_i.point(5, 6, 7)
surface1_g = g_i.surface(point1_g, point2_g, point3_g)

surface2_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))

print(g_i.dumpsurfaces())
```

# Python wrapper commands [DUMPSURFACEDISPLS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpsurfdispls
Displays the details of all surface displacements

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created surface displacements

polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))
surfacedisplacements_g = g_i.surfdispl(polygon1_g, polygon2_g)

print(g_i.dumpsurfdispls())
```

# Python wrapper commands [DUMPSURFACELOADS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpsurfloads
Displays the details of all surface loads

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created surface loads
g_i.gotostructures()
polygon1_g = g_i.surface((1, 2, 2), (4, 6, 2), (10, 12, 2), (5, 8, 2))
polygon2_g = g_i.surface((1, 0, 1), (5, 7, 1), (8, 13, 1), (10, 9, 1))
surfaceloads_g = g_i.surfload(polygon1_g, polygon2_g)

print(g_i.dumpsurfloads())
```

# Python wrapper commands [DUMPVOLUMES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## dumpvolumes
Displays the details of all volumes

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of all created volumes

g_i.cuboid(5)

print(g_i.dumpvolumes())
```

# Python wrapper commands [DUPLICATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## duplicate
Duplicates water levels.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a cuboid, then changes to Flow conditions mode, creates water levels and duplicates them
g_i.cuboid(10)
g_i.gotoflow()
waterlevel1_s = g_i.waterlevel((6, 4, 1), 2)
waterlevel2_s = g_i.waterlevel(1, 4, 6)

print(g_i.echo(g_i.duplicate(waterlevel1_s, waterlevel2_s)))
```

# Python wrapper commands [ECHO]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## echo
Displays the details of an object.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays extended details of the project.

print(g_i.echo())
```

---

```python
# Alternative 2
# Displays extended details of the material in a specified phase

material = g_i.soilmat()
material.setproperties("SoilModel", "Linear elastic", "gammaUnsat", 16, 
                       "gammaSat", 20, "Gref", 10000)
g_i.cuboid(5)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

print(g_i.echo(material, phase1_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Displays details of a specified object

# Example 1
# Creates multiple objects; the last one is the Line object
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]

print(line_g.echo())

# Example 2
# Displays details of the beam feature of a line object.
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
g_i.beam(line_g)

print(line_g.Beam.echo())

# Example 3
# Displays length of a line object.
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]

print(line_g.Length.echo())

# Example 4
# Displays details of the first object of Group_1.
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
group_g = g_i.group(point1_g, point2_g)

print(group_g[0].echo())
```

---

```python
# Alternative 4
# Displays details of one or more specified objects. 

# Example 1
# Creates multiple objects, the last one is the Line object
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]

print(g_i.echo(line1_g, line2_g))

# Example 2
# Displays the x-coordinates of point1_g and point2_g object
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)

print(g_i.echo(point1_g.x, point2_g.x))

# Example 3
# Displays details of all created points
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
point2_g = g_i.point(0, 0, 0)
point2_g = g_i.point(1, 6, 3)
point2_g = g_i.point(1, 10, 2)

print(g_i.echo([obj for obj in g_i.Points]))
```

# Python wrapper commands [ECHOTUNNELVALIDATION]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## echotunnelvalidation
Displays the errors, warnings and tips related to cross-section, properties, trajectory and sequencing of a tunnel in the tunnel designer

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the errors, warnings and tips for the design of a tunnel object

tunnel_g = g_i.tunnel(6, 2, 3)

print(g_i.echotunnelvalidation(tunnel_g))
```

# Python wrapper commands [EMBEDDEDBEAM]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## embeddedbeam
Adds embedded beam features to lines.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds embedded beam features to one or more existing lines in the geometry

# Example 1
# Creates multiple objects; the last one is the Line object. Assigns the embedded beam feature to the line
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
embeddedbeam_g = g_i.embeddedbeam(line_g)

print(g_i.echo(embeddedbeam_g))

# Example 2
# Creates multiple object;, the last one are the Line objects ([-1]). Assigns the embedded beam features to the lines
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
embeddedbeams_g = g_i.embeddedbeam(line1_g, line2_g)

print(g_i.echo(embeddedbeam_g))

# Example 3
# Creates multiple objects; the last one are the Line objects ([-1]). Assigns the embedded beam features to the lines
line_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
embeddedbeams_g = g_i.embeddedbeam((line_g, lines_g[-2], lines_g[-1]))

print(g_i.echo(embeddedbeam_g))

# Example 4
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
group_g = g_i.group(line1_g, line2_g)
embeddedbeams_g = g_i.embeddedbeam(group_g)

print(g_i.echo(embeddedbeam_g))
```

---

```python
# Alternative 2
# Creates a line between two points (which may either exist or will be created) and adds an embedded beam feature to it

# Example 1
# Creates multiple objects; last two are Line and Embedded Beam objects respectively
point_g = g_i.point(3, 4, 9)
line_g, embeddedbeam_g = g_i.embeddedbeam(point_g, (5, 6, 7))[-2:]

print(line_g, embeddedbeam_g)

# Example 2
point1_g = g_i.point(4, 6, 9)
point2_g = g_i.point(2, 6, 7)
line_g, embeddedbeam_g = g_i.embeddedbeam(point1_g, point2_g)

print(line_g, embeddedbeam_g)

# Example 3
line_g, embeddedbeam_g = g_i.embeddedbeam((1, 4, 0), (6, 5, 8))[-2:]

print(g_i.echo(line_g, embeddedbeam_g))
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Creates lines between three or more points (which may either exist or will be created) and adds embedded beam features to them

# Creates two points and uses them to create two lines (point1_g-(5.1, 6.4, 7.2) and (5.1, 6.4, 7.2)-point2_g), to which an embedded beam is assigned
point1_g = g_i.point(4, 6, 9)
point2_g = g_i.point(2, 6, 7)
res = g_i.embeddedbeam(point1_g, (5.1, 6.4, 7.2), point2_g)

# To a variable lines_g assigns all objects of type line and all beams to a variable embeddedbeams_g
lines_g = [item for item in res if item._plx_type == 'Line']
embeddedbeams_g = [item for item in res if item._plx_type == 'EmbeddedBeam']

print(g_i.echo(lines_g + embeddedbeams_g))
```

---

```python
# Alternative 4
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by providing the angles concerning the XY- and the XZ-plane and a length or a vector describing the direction and a length and add embedded beam features to them

# Example 1
# Creates multiple objects; last two are Line and Embedded Beam objects respectively
line_g, embeddedbeam_g = g_i.embeddedbeam((1, 2, 0), "relative", (3, 4, 8))[-2:]

print(g_i.echo(line_g, embeddedbeam_g))

# Example 2
point_g = g_i.point(4, 6, 9)
res = g_i.embeddedbeam(point_g, "relative", (3, 4, 8), (-5, -9, 10),
                       "angles", 0, 30, 16)
lines_g = [item for item in res if item._plx_type == 'Line']
embeddedbeams_g = [item for item in res if item._plx_type == 'EmbeddedBeam']

print(g_i.echo(lines_g + embeddedbeams_g))

# Example 3
res = g_i.embeddedbeam((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))

# To a variable lines_g assigns all objects of type line and all beams to a variable embeddedbeams_g
lines_g = [item for item in res if item._plx_type == 'Line']
embeddedbeams_g = [item for item in res if item._plx_type == 'EmbeddedBeam']

print(g_i.echo(lines_g + embeddedbeams_g))

# Example 4
# Creates Volume and Soil objects; the first one is the Volume object, and next creates multiple objects, last two are Line and Embedded Beam objects respectively
point_g = g_i.point(1, 2, 1)
volume_g = g_i.sphere(5)[0]
line_g, embeddedbeam_g = g_i.embeddedbeam(point_g, "angles", 90, 0, volume_g)[-2:]

print(g_i.echo(line_g, embeddedbeam_g))
```

---

```python
# Alternative 5
# Adds embedded beam features to one or more existing lines in the geometry and directly set their properties

# Example 1
# Creates multiple objects, the last one is the Line object and using one function assigned beam feature to a line and sets some properties
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
embeddedbeam_g = g_i.embeddedbeam(line_g, "Connection", "Hinged")

print(g_i.echo(embeddedbeam_g))

# Example 2
line_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))

# To a variable lines_g assigns all objects of type line
lines_g = [item for item in res if item._plx_type == 'Line']

embeddedbeams_g = g_i.embeddedbeam((line_g, lines_g[-2], lines_g[-1]), 
                                   "Connection", "Hinged")
print(g_i.echo(embeddedbeams_g))

# Obtain ConnectionPoint property value assigned for all embeddedbeams in a list and display them
embeddedbeams_connection_points = g_i.EmbeddedBeams.ConnectionPoint.value
print(f'Embedded beams connection points value: {embeddedbeams_connection_points}')
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Creates a line between two points, adds an embedded beam feature to it and directly set its properties

# Creates multiple objects; last two are Line and Embedded Beam objects respectively and using one function assigned beam feature to a line and sets some properties
point_g = g_i.point(4, 5, 9)
line_g, embeddedbeam_g = g_i.embeddedbeam(point_g, (5, 6, 7), "Connection", "Hinged")[-2:]

print(g_i.echo(line_g, embeddedbeam_g))
```

---

```python
# Alternative 7
# Creates lines between three or more points, adds embedded beam features to them and directly set their properties

point1_g = g_i.point(4, 6, 9)
point2_g = g_i.point(2, 6, 7)
res = g_i.embeddedbeam(point1_g, (5.1, 6.4, 7.2), point2_g, 
                       "Connection", "Hinged")

# To a variable lines_g assigns all objects of type line and all beams to a variable embeddedbeams_g
lines_g = [item for item in res if item._plx_type == 'Line']
embeddedbeams_g = [item for item in res if item._plx_type == 'EmbeddedBeam']

print(g_i.echo(lines_g + embeddedbeams_g))
```

---

```python
# Alternative 8
# Creates one or more lines by giving absolute coordinates or relative coordinates, by providing the angles concerning the XY- and the XZ-plane and a length or a vector describing the direction and a length, add embedded beam features to them and directly set their properties
line_g, embeddedbeam_g = g_i.embeddedbeam((1, 2, 0), "relative", (3, 4, 8), 
                                          "Connection", "Hinged")[-2:]
print(g_i.echo(line_g, embeddedbeam_g))
```

# Python wrapper commands [EMBEDDEDBEAMMAT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## embeddedbeammat
Creates an embedded beam material set.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates an embedded beam material set with no specified properties. It is not possible to calculate with this material before editing it to make its properties valid

g_i.embeddedbeammat()
```

---

```python
# Alternative 2
# Creates an embedded beam material set with specified properties

g_i.embeddedbeammat("Identification", "Piles", "MaterialType", "Elastic", "Gamma", 24, "E", 10000000, "Diameter", 0.25, "TSkinStartMax", 1, "TSkinEndMax", 100, "FMax", 100)
```

# Python wrapper commands [EXPORT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## export
Exports 3D models, structural entities, geometries, cutobjects, as CAD file formats (.step, .stp, .dxf, .brep)

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Exports a defined 3D model to a specified location in a specified file format

g_i.cuboid(2)
g_i.export("C:\data\CADgeometry.step")
```

---

```python
# Alternative 2
# Exports selected geometric objects to a specified location in a specified file format

# Example 1
# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.cuboid(5)[0]
surfaces_g = g_i.decomposesrf(volume_g)
g_i.export("C:\data\CADgeometry.dxf", surfaces_g[-2], surfaces_g[-1])

# Example 2
volume_g = g_i.cylinder(2, 5)[0]
g_i.export("C:\data\CADgeometry.brep", volume_g)
```

---

```python
# Alternative 3
# Exports selected cut objects to a specified location in a specified file format

# Creates Volume and Surface objects; the first one is the Volume object
volume_g = g_i.cylinder(2, 5)[0]
surfaces_g = g_i.decomposesrf(volume_g)

g_i.gotostages()
surface_s = g_i.Surfaces[0]

g_i.export("C:\data\CADgeometry.brep", surface_s)
```

# Python wrapper commands [EXTENDTOSYMMETRYAXIS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## extendtosymmetryaxis
Extends a polycurve to its symmetry axis by adding a new segment.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates multiple objects; the first one is the polycurve object
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), "line", 0, 2, "arc", 45, 90, 3)[0]
segment_g = polycurve_g.extendtosymmetryaxis()

print(g_i.echo(polycurve_g))
```

# Python wrapper commands [Extrude]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## extrude
Extrudes an object along a vector.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Extrudes one or more objects along a specified vector.

# Example 1
# Creates Line and Point objects; the last one is the Line object
point_g = g_i.point(1, 0, 0)
line_g = g_i.extrude(point_g, 1, 0, 5)[-1]
print(line_g)

# Example 2
polygon_g = g_i.extrude(line_g, 1, 2, 6)
print(polygon_g)

# Example 3
# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.extrude(polygon_g, 10, 0, 0)[0]
print(volume_g)

# Example 4
g_i.extrude((point_g, line_g, polygon_g), -2, 2, 0)
```

---

```python
# Alternative 2
# Extrudes one or more objects along a line or polycurve specifying the trajectory.

# Example 1
# Creates Line and Point objects; the last one is the Line object
line_g = g_i.line((2, 0, 0), (5, 0, 0))[-1]
polygon_g = g_i.surface((2, 2, 0), (2, 2, 5), (2, 5, 5), (2, 5, 0))

# Creates Volume and Soil objects; the first one is the Volume object
volume_g = g_i.extrude(polygon_g, line_g)
print(volume_g)

# Example 2
# Creates two polygons, 1 polycurve and extrudes the polygons along the polycurve
# Creates Polycurve and Segment objects; the first one is the Polycurve object
polycurve_g = g_i.polycurve((0, 0, 0), (1, 0, 0), (0, 1, 0), "Arc", 45, 90, 3)[0]
polygon1_g = g_i.surface((0, 0, 0), (0, 1, 0), (0, 1, 5), (0, 0, 5))
polygon2_g = g_i.surface((2, 0, 0), (2, 1, 0), (2, 1, 5), (2, 0, 5))
g_i.extrude(polygon1_g, polygon2_g, polycurve_g)
```

# Python wrapper commands [FILTER]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## filter
Displays a list of objects matching a specified criterion.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a list of specified objects.

g_i.point(3, 4, 9)
g_i.point(5, 2, 10)
g_i.point(7, 3, 6)
points_g = g_i.Points

print(g_i.filter(points_g))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Displays an object at a specified index from a list of objects.

g_i.point(3, 4, 9)
g_i.point(5, 2, 10)
g_i.point(7, 3, 6)
points_g = g_i.Points

print(g_i.filter(points_g, -1))
```

---

```python
# Alternative 3
# Displays a number of objects from a specified list of objects starting from a specified index.

g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfaces_g = g_i.Surfaces

print(g_i.filter(surfaces_g, 1, 1))
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Displays a list of objects that fulfill a specified criterion.

# Example 1
# Displays a list of all points that have an x-coordinate with a value lesser than 2.
g_i.point(3, 4, 9)
g_i.point(1, 2, 10)
g_i.point(3, 3, 6)
points_g = g_i.Points

print(g_i.filter(points_g, "x<2"))

# Example 2
g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfaces_g = g_i.Surfaces

print(g_i.filter(surfaces_g, "Area<0.5"))

# Example 3
g_i.clear()
g_i.cylinder(2, 5) 
g_i.sphere(0.02)
volumes_g = g_i.Volumes

print(g_i.filter(volumes_g, "Volume<0.01"))

# Example 4
g_i.clear()
# Creates multiple objects, the last one is the Line object ([-1])
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
beammaterial_i = g_i.beammat()
g_i.beam(line1_g, "Material", beammaterial_i)
g_i.beam(line2_g)

print(g_i.filter(g_i.Beams, "Material="))

# Example 5
g_i.clear()
polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
g_i.surfload(polygon1_g, polygon2_g)
surfaceloads_i = g_i.SurfaceLoads
surfaceloads_i[-1].sigx = 5

print(g_i.filter(surfaceloads_i, "sigx<>5"))

# Example 6
g_i.clear()
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
g_i.plate(polygon1_g, polygon2_g)
platematerial_i = g_i.platemat()
plates_g = g_i.Plates
plates_g[-2].Material = platematerial_i 

print(g_i.filter(plates_g, "Material!="))

# Example 7
g_i.clear()
# Creates multiple objects, the last one is the Line object ([-1])
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
g_i.lineload(line1_g, line2_g)
lines_g = g_i.Lines

print(g_i.filter(lines_g, "LineLoad<>"))

# Example 8
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(5, 2, 10)
# Creates multiple objects, the last one is the Line object ([-1])
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
group_g = g_i.group(line1_g, line2_g, point1_g, point2_g)

print(g_i.filter(group_g, "Point"))
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Displays a list of specified staged construction features in a specified phase.

# Creates a borehole, a soillayer of specified height and two embeddedbeams
g_i.borehole(0, 0)
g_i.soillayer(2)
g_i.gotostructures()

g_i.embeddedbeam((1, 3, -1), (5, 3, -1))
g_i.embeddedbeam((1, 1, -1), (5, 1, -1))

g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
phase2_s = g_i.phase(g_i.InitialPhase)

embeddedbeam1_s, embeddedbeam2_s = g_i.EmbeddedBeams

g_i.filter(embeddedbeam1_s, embeddedbeam2_s, phase2_s)
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Displays a list of staged construction features at a specified index in a specified phase.

# Creates a borehole, a soillayer of specified height and four beams
g_i.borehole(0, 0)
g_i.soillayer(2)
g_i.gotostructures()

for i in range(4):
    g_i.beam((1, i, -1), (5, i, -1))

g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
phase2_s = g_i.phase(g_i.InitialPhase)

beams_s = g_i.Beams

g_i.filter(beams_s, phase1_s, 0)
```

---

```python
s_i.new()
```

---

```python
# Alternative 7
# Displays a specified number of staged construction features in a specified phase starting from a specified index.

# Creates a borehole, a soillayer of specified height and six beams
g_i.borehole(0, 0)
g_i.soillayer(2)
g_i.gotostructures()

for i in range(6):
    g_i.beam((1, i, -1), (5, i, -1))

g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
phase2_s = g_i.phase(g_i.InitialPhase)

beams_s = g_i.Beams

g_i.filter(beams_s, phase1_s, 0, 3)
```

---

```python
s_i.new()
```

---

```python
# Alternative 8
# Displays a list of staged construction features that fulfil a condition in a specified phase.

# Creates a borehole, a soillayer of specified height and six beams
g_i.borehole(0, 0)
g_i.soillayer(2)
g_i.gotostructures()

for i in range(6):
    g_i.beam((1, i, -1), (5, i, -1))

g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
phase2_s = g_i.phase(g_i.InitialPhase)

beams_s = g_i.Beams

g_i.activate(beams_s[0], beams_s[1], phase1_s)

g_i.filter(beams_s, phase1_s,"Active=True")
```

---

```python
s_i.new()
```

---

```python
# Alternative 9
# Displays a list of staged construction features that fulfil a condition in a specified phase.

# Creates a borehole, a soillayer of specified height and a beam
g_i.borehole(0, 0)
g_i.soillayer(2)
g_i.gotostructures()

g_i.beam((1, 3, -1), (5, 3, -1))

g_i.gotostages()

for i in range(4):
    g_i.phase(g_i.InitialPhase)

beam_s = g_i.Beams[-1]
phases_s = g_i.Phases

print(g_i.filter(beam_s, phases_s[0], phases_s[1]))
```

---

```python
s_i.new()
```

---

```python
# Alternative 10
# Displays a phase at the specified index, in which the staged construction feature is present.

# Creates a borehole, a soillayer of specified height and a pointload
g_i.borehole(0, 0)
g_i.soillayer(2)
g_i.gotostructures()

g_i.pointload(2, 2, 0)

g_i.gotostages()

for i in range(5):
    g_i.phase(g_i.InitialPhase)

pointload_s = g_i.PointLoads[-1]
phases_s = g_i.Phases

print(g_i.filter(pointload_s, phases_s, 1))
```

---

```python
s_i.new()
```

---

```python
# Alternative 11
# Displays a list of phases (starting from a specified index), in which the staged construction feature is present.

# Creates a borehole, a soillayer of specified height and a pointload
g_i.borehole(0, 0)
g_i.soillayer(2)
g_i.gotostructures()

g_i.pointload(2, 2, 0)

g_i.gotostages()

for i in range(5):
    g_i.phase(g_i.InitialPhase)

pointload_s = g_i.PointLoads[-1]
phases_s = g_i.Phases

print(g_i.filter(pointload_s, phases_s, 0, 3))
```

---

```python
s_i.new()
```

---

```python
# Alternative 12
# Displays phases, in which staged construction features fulfil the specified criterion.

# Creates a borehole, a soillayer of specified height and a pointload
g_i.borehole(0, 0)
g_i.soillayer(2)
g_i.gotostructures()

g_i.pointload(2, 2, 0)

# Creates 5 phases and activates the pointload in Phase_2 and Phase_5
g_i.gotostages()
for i in range(5):
    g_i.phase(g_i.InitialPhase)

pointload_s = g_i.PointLoads[-1]
phases_s = g_i.Phases

g_i.activate(pointload_s, (phases_s[2], phases_s[5]))
g_i.filter(pointload_s, phases_s, "Active=True")
```

# Python wrapper commands [FINDCUTOBJECT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## findcutobject
Finds the source entities of the specified cutobject or list of cutobjects in staged construction.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates Volume and Soil objects; the first one is the Volume object and polygons. Then creates plate material and two plates (from polygons)
volume_g = g_i.cuboid(5)[0]
polygon1_g = g_i.surface((0, -2, 0), (0, 2, 0), (2, 2, 0), (2, -2, 0))
polygon2_g = g_i.surface((0, 0, 0), (0, 0, 2), (2, 0, 2), (2, 0, 0))
platematerial = g_i.platemat()
plate1_g = g_i.plate(polygon1_g, "Material", platematerial)
plate2_g = g_i.plate(polygon2_g, "Material", platematerial)

g_i.gotostages()
g_i.dumpcutobjects()
cutvolume_s = g_i.Volumes[-1]
cutpolygon_s = g_i.Surfaces[-1]

g_i.findcutobject((cutvolume_s, cutpolygon_s))
```

# Python wrapper commands [FINDSTAGEDFEATURE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## findstagedfeature
Finds a feature in the staged construction mode

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Finds and displays source entities of staged feature in staged construction

# Creates Volume and Soil objects; the first one is the Volume object and polygons. Then creates plate material and two plates (from polygons)
polygon_g = g_i.surface((0, -2, 0), (0, 2, 0), (2, 2, 0), (2, -2, 0))
g_i.surfload(polygon_g)

point_g = g_i.point((0,0,0))
g_i.pointdispl(point_g)

g_i.gotostages()
polygon_s = g_i.SurfaceLoads[0]
point_s = g_i.PointDisplacements[0]

print(g_i.echo(g_i.findstagedfeature(polygon_s, point_s)))
```

# Python wrapper commands [FIXEDENDANCHOR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## fixedendanchor
Adds fixed-end anchor features to points.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds fixed-end anchor features to one or more existing points in the geometry

# Example 1
point_g = g_i.point(5, 6, 7)
fixedendanchor_g = g_i.fixedendanchor(point_g)

print(fixedendanchor_g)

# Example 2
point1_g = g_i.point(5, 6, 7)
point2_g = g_i.point(1, 2, 3)
fixedendanchor_g = g_i.fixedendanchor(point1_g, point2_g)

print(fixedendanchor_g)

# Example 3
# Creates three points and then groups them. Assigns fixed-end anchor features to elements in a group
point1_g = g_i.point(0, 2, 3.2)
point2_g = g_i.point(1, 2, 0)
point3_g = g_i.point(0, 0, 0)
group_g = g_i.group(point1_g, point2_g, point3_g)
fixedendanchors_g = g_i.fixedendanchor(group_g)

print(fixedendanchors_g)
```

---

```python
# Alternative 2
# Creates a new point and adds a fixed-end anchor feature to it

# Creates multiple objects, last one is the FixedEndAnchor object
fixedendanchor_g = g_i.fixedendanchor(1, 2 ,3)[-1]

print(g_i.echo(fixedendanchor_g))
```

---

```python
# Alternative 3
# Creates several new points and adds fixed-end anchor features to them

res = g_i.fixedendanchor((1, 2, 3), (4, 5, 6))
fixedendanchors_g = [item for item in res if item._plx_type == 'FixedEndAnchor']

print(g_i.echo(fixedendanchors_g))
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Adds fixed-end anchor features to one or more existing points in the geometry and directly set their properties

# Example 1
# Adds a fixed-end anchor feature to a point and sets the Directionx to 3, the Directiony to 7 and the Directionz to 2
point_g = g_i.point(1, 2, 3)
fixedendanchor_g = g_i.fixedendanchor(point_g, "Direction_x", 3, "Direction_y", 7, "Direction_z", 2)

print(g_i.echo(fixedendanchor_g))

# Example2
# Adds a fixed-end anchor feature to two points and sets the Directionx to 3, the Directiony to 7 and the Directionz to 2
point1_g = g_i.point(2, 3, 4)
point2_g = g_i.point(3, 4, 5)
fixedendanchors_g = g_i.fixedendanchor(point1_g, point2_g, "Direction_x", 3, "Direction_y", 7, "Direction_z", 2)

print(g_i.echo(fixedendanchors_g))
```

---

```python
# Alternative 5
# Creates a new point, adds a fixed-end anchor feature to it and directly set its properties

# Creates multiple objects, last one is the FixedEndAnchor object
fixedendanchor_g = g_i.fixedendanchor((1, 2, 3), "Direction_x", 3, "Direction_y", 7, "Direction_z", 2)[-1]

print(g_i.echo(fixedendanchor_g))
```

---

```python
# Alternative 6
# Creates several new points, adds fixed-end anchor features to them and directly set their properties
res = g_i.fixedendanchor((1, 2, 3), (4, 5, 6), "Direction_x", 3, "Direction_y", 7, "Direction_z", 2)
fixedendanchors_g = [item for item in res if item._plx_type == 'FixedEndAnchor']

print(g_i.echo(fixedendanchors_g))

# Obtain EquivalentLength property value for all fixed end anchors in a list and display them
anchors_equivalent_length = g_i.FixedEndAnchors.EquivalentLength.value
print(f'FixedEndAnchors EquivalentLength: {anchors_equivalent_length}')
```

# Python wrapper commands [GENERATEFROMFIELDDATA]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## generatefromfielddata
Generates the soil stratigraphy of a borehole based on assigned field data.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and imports a .cpt file. Then, assigns field data properties, generates field data and displays borehole volumes addresses in the memory
borehole_g = g_i.borehole(0, 0)
borehole_g.FieldData = g_i.importfielddata(r"C:\PLAXIS3D\test.cpt")
borehole_g.FieldDataInterpreter = "CUR 3 layers"

g_i.generatefromfielddata(borehole_g)
```

# Python wrapper commands [generatesplittunnel]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## generatetunnel
Splits a template tunnel.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Splits a tunnel.

# Creates a tunnel and adds cross section segments and sets tunnel properties to create split tunnel parts
tunnel_g = g_i.tunnel((0, 0, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.ShapeType = "Template"
tunnel_g.CrossSection.add()
tunnel_g.CrossSection.add()
tunnel_g.CrossSection.Segments[1].LineProperties.RelativeStartAngle1 = 90
tunnel_g.CrossSection.add()
tunnel_g.CrossSection.add()
tunnel_g.CrossSection.Segments[3].LineProperties.RelativeStartAngle1 = 90
tunnel_g.CrossSection.add()
tunnel_g.CrossSection.Segments[4].LineProperties.RelativeStartAngle1 = 90
tunnel_g.CrossSection.add()
tunnel_g.CrossSection.addsubcurve()
tunnel_g.CrossSection.Subsections[0].Offset2 = 1
tunnel_g.Trajectory.add()
tunnel_g.Trajectory.Segments[0].LineProperties.Length = 10
toptunnel_g = tunnel_g.SplittingDefinition.add(g_i.TunnelPartCurve_5, g_i.TunnelPartCurve_4, g_i.TunnelPartCurve_3, g_i.TunnelPartCurve_7)
bottomtunnel_g = tunnel_g.SplittingDefinition.add(g_i.TunnelPartCurve_2, g_i.TunnelPartCurve_1, g_i.TunnelPartCurve_6, g_i.TunnelPartCurve_7)

g_i.generatesplittunnel(tunnel_g)
```

# Python wrapper commands [GENERATETHICKLINING]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## generatethicklining
Generates a thick lining for a tunnel.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a tunnel and adds sub-curves and sets other tunnel properties. Then generates tunnel thick lining
tunnel_g = g_i.tunnel(0, 0, 0)
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4

g_i.generatethicklining(tunnel_g.CrossSection, 0.1)
```

# Python wrapper commands [GENERATETUNNEL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## generatetunnel
Generates the geometry based on the tunnel description.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a tunnel and adds sub-curves and sets other tunnel properties
tunnel_g = g_i.tunnel((-44, 29, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4
tunnel_g.Trajectory.add()
tunnel_g.Trajectory.Segments[0].LineProperties.Length = 25

# Creates Volume and Soil objects; the first one is the Volume object. Displays volume's address in the memory
tunnelvolume_g = g_i.generatetunnel(tunnel_g)[0]
print(tunnelvolume_g)
```

# Python wrapper commands [GEOGRID]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## geogrid
Adds geogrid features to structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds geogrid features to one or more existing structural surfaces in the geometry

# Example 1
# Creates a surface and assingns a geogrid feature to it. Then, displays geogrid's address in the memory
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
geogrid_g = g_i.geogrid(polygon_g)

print(geogrid_g)

# Example 2
# Creates two surfaces and assigns geogrid features to it. Then, displays geogrids' address in the memory
polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
geogrids_g = g_i.geogrid(polygon1_g, polygon2_g)

print(geogrids_g)

# Example 3
polygon1_g = g_i.surface((12, 15, 0), (3, 6, 3), (9, 15, 12), (8, 9, 9))
polygon2_g = g_i.surface((3, 7, 8), (7, 8, 3), (9, 1, 11), (10, 14, 15))
geogrids_g = g_i.geogrid((polygon1_g, polygon2_g))

print(geogrids_g)

# Example 4
# Creates two surfaces and groups them. Then, assigns geogrid features to the group. Displays group's address in the memory
polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
group_g = g_i.group(polygon1_g, polygon2_g)
geogrids_g = g_i.geogrid(group_g)

print(geogrids_g)
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points and adds a geogrid feature to it

point1_g = g_i.point(5, 4, 7)
point2_g = g_i.point(6, 9, 10)
surface_g, geogrid_g = g_i.geogrid(point1_g, point2_g, (1, 0, 5))

print(surface_g, geogrid_g)
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and add a geogrid feature to it

# Creates multiple objects, the first one is the Polycurve object and closes the polycurve
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()

# Assigns geogrid feature to a polycurve creating a surface and geogrid.Displays object's addressess in the memory
surface_g, geogrid_g = g_i.geogrid(polycurve_g)
print(surface_g, geogrid_g)
```

---

```python
# Alternative 4
# Adds geogrid features to one or more existing structural surfaces in the geometry and directly set their properties

# Example 1
# Creates a surface. Then creates geogrid material, and in using one functions assigns geogrid feature to the surface and created material to the geogrid
polygon_g = g_i.surface((12, 15, 0), (3, 6, 3), (9, 15, 12), (8, 9, 9))
geogridmaterial_i = g_i.geogridmat()
geogrid_g = g_i.geogrid(polygon_g, "Material", geogridmaterial_i)

print(geogrid_g)

# Example 2
# Creates two surfaces. Then creates geogrid material, and in using one functions assigns geogrid features to the surfaces and created material to the geogrids
polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
geogridmaterial_i = g_i.geogridmat()
geogrids_g = g_i.geogrid((polygon1_g, polygon2_g), "Material", geogridmaterial_i)

print(geogrids_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points, add a geogrid feature to it and directly set its properties

# Creates two points. Then creates geogrid material
point2_g = g_i.point(6, 9, 10)
geogridmaterial_i = g_i.geogridmat()

# Using one function assigns geogrid feature to the surface (from three points) and created material to the geogrid
point1_g = g_i.point(5, 4, 7)
surface_g, geogrid_g = g_i.geogrid(point1_g, point2_g, (1, 0, 5), 
                                   "Material", geogridmaterial_i)
print(surface_g, geogrid_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and add a geogrid feature to it and directly set its properties

# Creates multiple objects; the first one is the Polycurve object
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()
geogridmaterial_i = g_i.geogridmat()

surface_g, geogrid_g = g_i.geogrid(polycurve_g, "Material", geogridmaterial_i)
print(surface_g, geogrid_g)

# Obtain ApplyStrengthReduction property value assigned for all geogrids in a list and display them
geogrids_strength_reduction = g_i.Geogrids.ApplyStrengthReduction.value
print(f'Geogrids strength reduction property: {geogrids_strength_reduction}')
```

# Python wrapper commands [GEOGRIDMAT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## geogridmat
Creates a geogrid material set.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a geogrid material set with no specified properties. It is not possible to calculate with this material before editing it to make its properties valid

g_i.geogridmat()
```

---

```python
# Alternative 2
# Creates a geogrid material set with specified properties

g_i.geogridmat("Identification", "Geomembrane", "MaterialType", "Elastic", "EA1", 585)
```

# Python wrapper commands [GETCOMMONMESHNODES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getcommonmeshnodes
Displays the number of shared nodes of two cut objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the number of shared nodes of two cut objects

# Creates multiple objects, the last one is the Line object. Then, changes the mode and gets the common mesh nodes for two cut objects
line_g = g_i.line((0, 0, 0), (0, 2, 0))[-1] 
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
g_i.cuboid(2)

g_i.gotomesh()
g_i.mesh()
line_s = g_i.Lines[-1]
polygon_s = g_i.Surfaces[-1]

g_i.getcommonmeshnodes(line_s, polygon_s)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Displays the number of shared nodes of two cut objects with the possibility to display the positions of the shared nodes

# Creates multiple objects; the last one is the Line object. Then, changes the mode and gets the common mesh nodes for two cut objects
line_g = g_i.line((0, 0, 0), (1, 1, 1))[-1]
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
g_i.cuboid(2)

g_i.gotomesh()
g_i.mesh()
line_s = g_i.Lines[-1]
polygon_s = g_i.Surfaces[-1]

g_i.getcommonmeshnodes(line_s, polygon_s, True)
```

# Python wrapper commands [GETCURVERESULTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getcurveresults
Displays the calculated values of a particular block of the specified phase.

---

```python
s_i.new()

# Import new_server function from plxscripting module to connect to PLAXIS 3D Output application
from plxscripting.easy import *
```

---

```python
# Alternative 1
# Displays the values of the calculation results of a specified block in a phase. The values shown are the values in the last step of the calculation

# Creates a soil contour and a borehole, then adds a soil layer (from 0 to -10). Creates soil material and sets its properties, then assigns this material to created soil
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
borehole_g.Head = -1
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[-1].Material = material

g_i.gotomesh()
g_i.mesh(0.2)
# Connect to the PLAXIS 3D Output application with the correct port for the remote scripting server
output_port = g_i.selectmeshpoints()
s_o, g_o = new_server("localhost", port=output_port, password=s_i.connection._password)

for i in range (15):
    g_o.addcurvepoint("node", (i/4, 0, -i/4))
g_o.update()

g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])

g_i.calculate()
g_i.getcurveresults(phase1_s, "PPRESS_R")
```

---

```python
# Alternative 2
# Displays a specific calculation result of a specified block in a phase

print(g_i.getcurveresults(phase1_s, "PPRESS_R", 4))
```

---

```python
# Alternative 3
# Displays the values of the calculation results of column of a specified block in a phase

g_i.getcurveresults(phase1_s, "PPRESS_R", 0, 3)
```

# Python wrapper commands [GETLOCALAXES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getlocalaxes
Displays the local axes at a specified point on a surface or polygon or nearest to a specified point.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a polygon and displays the local axes at the point (1.5 2 2)
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (6, 7, 9))

print(polygon_g.getlocalaxes((1.5, 2, 2)))
```

# Python wrapper commands [GETMESHLOCALAXES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getmeshlocalaxes
Displays the local axes closest to the given coordinate of a mesh triangle in the cutobject.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a polygon, generates a mesh and displays the local axes of a mesh triangle at (0 0 0)
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (6, 7, 9))

g_i.gotomesh()
polygon_s = g_i.Surfaces[-1]

print(g_i.getmeshlocalaxes(polygon_s, (0, 0, 0)))
```

# Python wrapper commands [GETNORMAL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getnormal
Displays the normal of a planar surface or polygon.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the normal of a planar surface or polygon

# Example 1
# Creates multiple objects; the first one is the Polycurve object
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
print(polycurve_g.getnormal())

# Example 2
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (6, 7, 9))

print(polygon_g.getnormal())
```

---

```python
# Alternative 2
# Displays the normal of a surface or polygon at a specified point

polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (6, 7, 9))

polygon_g.getnormal(3, 2, 0)
```

# Python wrapper commands [GETRESULTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getresults
Displays calculation results.

---

```python
s_i.new()

# Import new_server function from plxscripting module to connect to PLAXIS 3D Output application
from plxscripting.easy import *
```

---

```python
# Alternative 1
# Displays the minimum and maximum value of the calculation results of a specified block in a phase

# Creates a soil contour, borehole, soil layer, and soil material. Then sets material properties
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
borehole_g.Head = -1
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Creates a lineload between two points
g_i.lineload((2, 2, 0), (8, 2, 0), "qz_start", -1000)

# Changes the mode, selects mesh points and selects 14 points for curves
g_i.gotomesh()
g_i.mesh()

# Connect to the PLAXIS 3D Output application with the correct port for the remote scripting server
output_port = g_i.selectmeshpoints()
s_o, g_o = new_server("localhost", port=output_port, password=s_i.connection._password)

for i in range (15):
    g_o.addcurvepoint("node", (i/4, 0, -i/4))
g_o.update()

# Changes the mode, adds a phase and activates the line load in Phase_1. Then, calculates the project and displays selected results
g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.getresults(phase1_s, "UTOT___R")
```

---

```python
# Alternative 2
# Displays a specific calculation result of a specified block in a phase

g_i.getresults(phase1_s, "UTOT___R", 8)
```

---

```python
# Alternative 3
# Displays all of the calculation results of column of a specified block in a phase

g_i.getresults(phase1_s, "UTOT___R", "all")
```

---

```python
# Alternative 4
# Displays the minimum and maximum or uniform value of the calculation results of rows of a specified block in a phase

g_i.getresults(phase1_s, "UTOT___R", "rows", 0, 3)
```

---

```python
# Alternative 5
# Displays the minimum and maximum or uniform value of the calculation results of columns of a specified block in a phase

g_i.getresults(phase1_s, "UTOT___R", "columns", 0, 3)
```

# Python wrapper commands [GETSOILLAYERLEVEL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getsoillayerlevel
Returns the location of a soil layer boundary at a borehole.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer. Then returns the location of the soil layer with index 0
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)

g_i.getsoillayerlevel(borehole_g, 0)
```

# Python wrapper commands [GETSOILLAYERPOREPRESSURE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getsoillayerporepressure
Returns the pore pressures of a soil layer.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer. Then assigns the last soil layer from the list of soil layers to a variable soillayer_g
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
soillayer_g = g_i.SoilLayers[-1]

# Returns the pore pressure at the top and bottom of Soillayer_1
g_i.getsoillayerporepressure(borehole_g, soillayer_g)
```

# Python wrapper commands [GETTOGGLE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## gettoggle
Returns true or false depending on whether the toggle is set to true or false. If a toggle is absent, it returns false.

---

```python
s_i.new()
```

---

```python
# Alternative 1
g_i.gettoggle("NO_CONTROLLERS")
```

# Python wrapper commands [GETVALUE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## getvalue
Displays the value of a surface load or displacement at a specified location.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates a surface and assigns a surface load to it and displays load's value in the specified location
polygon_g = g_i.surface((0, 0, 0), (9.1, 3.4, 2.1), (6, 7, 9))
surfaceload_g = g_i.surfload(polygon_g)

print(surfaceload_g.getvalue(4, 6, 5))

# Example 2
polygon_g = g_i.surface((0, 0, 0), (1, 2, 3), (6, 7, 9))
surfacedisplacement_g = g_i.surfdispl(polygon_g, "Displacement_x", "Fixed", 
                                      "Displacement_y", "Prescribed")

print(surfacedisplacement_g.getvalue(1, 2, 3))
```

# Python wrapper commands [GOTOFLOW]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## gotoflow
Switches to flow conditions mode.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Switches from the current working mode to flow conditions mode. There has to be at least one volume or surface in the geometry

g_i.cuboid(7, 3, 10, (0, 0, 1))
g_i.gotoflow()
```

---

```python
# Alternative 2
# Switches from the current working mode to flow condiitons mode with the possibility to create a new intersection regardless
# of whether there are any geometric changes. There has to be at least one volume or surface in the geometry.

g_i.gotosoil()
g_i.cuboid(7, 3, 10, (0, 0, 1))
g_i.gotoflow(True)
```

# Python wrapper commands [GOTOMESH]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## gotomesh
Switches to Mesh mode.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Switches from the current working mode to Mesh mode. There has to be at least one volume or surface in the geometry

g_i.cuboid(7, 3, 10, (0, 0, 1))
g_i.gotomesh()
```

---

```python
# Alternative 2
# Switches from the current working mode to Mesh mode with the possibility to create a new intersection regardless of
# whether there are any geometric changes. There has to be at least one volume or surface in the geometry

g_i.gotosoil()
g_i.cuboid(7, 3, 10, (0, 0, 1))
g_i.gotomesh(True)
```

# Python wrapper commands [GOTOSOIL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## gotosoil
Switches to Soil mode.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.gotosoil()
```

# Python wrapper commands [GOTOSTAGES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## gotostages
Switches to Staged construction mode.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Switches from the current working mode to Staged construction mode. There has to be at least one volume or surface in the geometry

g_i.cuboid(7, 3, 10, (0, 0, 1))
g_i.gotostages()
```

---

```python
# Alternative 2
# Switches from the current working mode to Staged construction mode with the possibility to create a new intersection regardless
# of whether there are any geometric changes. There has to be at least one volume or surface in the geometry

g_i.gotosoil()
g_i.cuboid(7, 3, 10, (0, 0, 1))
g_i.gotostages(True)
```

# Python wrapper commands [GOTOSTRUCTURES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## gotostructures
Switches to Structures mode.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.gotostructures()
```

# Python wrapper commands [GOTOWATER]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## gotowater
Switches to flow conditions mode.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Switches from the current working mode to flow conditions mode. There has to be at least one volume or surface in the geometry

g_i.cuboid(7, 3, 10, (0, 0, 1))
g_i.gotowater()
```

---

```python
# Alternative 2
# Switches from the current working mode to flow conditions mode with the possibility to create a new intersection regardless of whether there are any geometric changes. There has to be at least one volume or surface in the geometry

g_i.gotosoil()
g_i.cuboid(7, 3, 10, (0, 0, 1))
g_i.gotowater(True)
```

# Python wrapper commands [GROUP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## group
Makes a group of one or more objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Makes a group of one or more objects

# Creates a surface, then creates Volume and Soil objects, the first one is the Volume object ([0]), and a point
surface_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
volume_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0] 
point_g = g_i.point(2, 3, 4)

# Groups created objects and displays their addresses in the memory
group_g = g_i.group(surface_g, volume_g, point_g)
print(group_g), print(group_g[:])
```

---

```python
# Alternative 2
# Makes a group of specified features of one or more objects

# Creates multiple objects; the last one are the Line objects ([0]).
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))

# Assigns all line type objects to a variable lines_g. Then assigns beam features to all listed lines
lines_g = [item for item in res if item._plx_type == 'Line']
g_i.beam(line1_g, line2_g, lines_g[-2], lines_g[-1])

# Groups all line objects that have beam features assigned to them. Displays group's and beams' addresses in the memory
group_g = g_i.group(line1_g, line2_g, lines_g[-2], lines_g[-1], "beam")
print(group_g), print(group_g[:])
```

# Python wrapper commands [HEADFUNCTION]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## headfunction
Adds a head function.

---

```python
s_i.new()
```

---

```python
# Alternative 1

for i in range(3):
    g_i.headfunction()

print(g_i.tabulate(g_i.FlowFunctions))

# Obtain Signal property value assigned for all head functions in a list and display them
headfunctions_signal = g_i.FlowFunctions.Signal.value
print(f'Head functions signal: {headfunctions_signal}')
```

# Python wrapper commands [HELP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## help
Displays a short help for the command line functionality.

---

```python
s_i.new()
```

---

```python
# Alternative 1

print(g_i.help())
```

# Python wrapper commands [IMPORT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## import
Imports points, polycurves, surfaces, structural or soil volumes.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Imports an object from a specified location into the geometry

g_i.import_(r"C:\PLAXIS3D\Importables\topsurface.obj")
```

---

```python
# Alternative 2
# Imports geometric objects from a file into the geometry using specific import configuration

g_i.import_(r"C:\PLAXIS3D\Importables\excavation.stp", "ImportType", "structures", "ImportFilter", "surfaces|volumes", "Scaling", 1.5, "Offset", (-1, 2.5, 0.0), "AxisTransformation", "zms")
```

---

```python
# Alternative 3
# Imports all objects from multiple files.

g_i.import_("Files", (r"C:\PLAXIS3D\Importables\excavation.stp", r"C:\PLAXIS3D\Importables\topsurface.obj"))
```

# Python wrapper commands [IMPORTCROSSSECTION]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## importcrosssection
Imports one or more polycurves into the cross-section of a tunnel

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Imports one or more polycurves into the cross-section of a tunnel.

tunnel_g = g_i.tunnel(6, 2, 3)
g_i.importcrosssection(tunnel_g, r"C:\PLAXIS3D\Importables\polylineXY.dxf")
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Imports one or more polycurves into the cross-section of a tunnel considering additional settings.

tunnel_g = g_i.tunnel(6, 2, 3)
g_i.importcrosssection(tunnel_g, "C:\PLAXIS3D\crosssection.dxf","Scale", 2.0, "Tolerance", 1.0E-4, "Segments", (0, 1, 2, 3, 4, 5, 6, 7, 8), "SegmentsOrigin", (7, "EndPoint"), "Intersect", True)
```

# Python wrapper commands [IMPORTFIELDDATA]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## importfielddata
Imports field data.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.importfielddata(r"C:\PLAXIS3D\test.cpt")
```

# Python wrapper commands [IMPORTIFC]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## importifc
Imports IFC data.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Imports all supported IFC structures from the project.ifc file
g_i.importifc("structures", r"C:\Users\User\project.ifc", "")

# Example 2
# Imports all supported IFC points from the project.ifc file
g_i.importifc("point", r"C:\Users\User\project.ifc", "ifcslab")

# Example 3
# Imports all supported IFC soil surface top from the project.ifc file
g_i.importifc("soilsurfacetop", r"C:\Users\User\project.ifc", "ifcwall ifcroof ifcslab")
```

# Python wrapper commands [IMPORTPOINTCLOUD]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## importpointcloud
 Importsa points cloud and creates a surface that matches those points.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Imports a points cloud and creates a NURBS surface that matches those points. It detects a best-fitting plane so it can be used to arbitrarily oriented surfaces. 

# Imports a points cloud and creates a surface that matches those points
g_i.importpointcloud(r"C:\Users\User\mypoints.txt")
```

---

```python
# Alternative 2
# Imports a points cloud and creates a surface

# Imports points from the file and places it at the pointed coordinates with 10 grid points in x- and 10 in y-direction
g_i.importpointcloud((0, 0, 0), (50, 50, 0), 10, 10, r"C:\Users\User\mypoints.txt")
```

---

```python
# Alternative 3
# Imports a points cloud and creates a surface

# Imports a points cloud, creates a surface and places it at the pointed coordinates with 10 grid points in x- and 10 in y-direction, minimum and maximum polynomial degrees and specified continuity code
g_i.importpointcloud((0, 0, 0), (50, 50, 0), 10, 10, 1, 2, "c1", r"C:\Users\User\mypoints.txt")
```

# Python wrapper commands [IMPORTTRAJECTORY]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## importtrajectory
 Imports a polycurve as the trajectory of a tunnel. The polycurve can only contain lines and arcs, and they should be positioned on the XY-plane.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Imports a polycurve as the trajectory of a tunnel

g_i.gotostructures()
tunnel_g = g_i.tunnel(0, 0, 0)
g_i.importtrajectory(tunnel_g, r"C:\Users\User\polyline.dxf")
```

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Imports one or more polycurves into the cross-section of a tunnel considering additional settings.

g_i.gotostructures()
tunnel_g = g_i.tunnel(0, 0, 0)
g_i.importtrajectory(tunnel_g, r"C:\PLAXIS3D\trajectory.dxf", "Scale", 1, "Tolerance", 0.0001, "Segments", (0, 1, 2, 3), "SegmentsOrigin", (0, "StartPoint"))
```

# Python wrapper commands [INFO]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## info
Displays all commands and attributes for an object.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays all available commands and attributes for the project

print(g_i.info())
```

---

```python
# Alternative 2
# Displays all available commands and attributes for the project

print(g_i.Colours.info())
```

---

```python
# Alternative 3
# Displays all available commands and attributes for an existing object

# Creates multiple objects; the last one is the Line object ([-1])
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
print(line_g.info())
```

---

```python
# Alternative 4
# Displays all available commands and attributes for one or more existing objects

# Creates multiple objects; the last one is the Line objects ([-1])
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
print(g_i.info(line1_g, line2_g))
```

# Python wrapper commands [INITIALIZERECTANGULAR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## initializerectangular
Changes the coordinates of the rectangular soil contour.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.SoilContour.initializerectangular(1, 5, 18, 7)
```

# Python wrapper commands [INSERT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## insert
Inserts a segment into a polycurve or a row into an advanced table.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Inserts a line segment with a length of 1 into a polycurve

# Creates multiple objects; the first one is the Polycurve object ([0]) and inserts 
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
segment_g = polycurve_g.insert(2)

print(segment_g)
```

---

```python
# Alternative 2
# Inserts a segment with specified properties into a polycurve

# Example 1
# Creates multiple objects; the first one is the Polycurve object ([0]) and then inserts a segment
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]

segment_g = polycurve_g.insert(2, "arc", 90, 45, 2)
print(segment_g)

# Example 2
# Creates multiple objects; the first one is the Polycurve object ([0]) and then inserts a segment
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]

segment_g = polycurve_g.insert(0, "line", 0, 5)
print(segment_g)
```

---

```python
# Alternative 3
# Inserts a row into an advanced table

loadmultiplier_g = g_i.loadmultiplier()
loadmultiplier_g.Table.insert(0)
```

# Python wrapper commands [INSERTPHASE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## insertphase
Creates a new phase and inserts it before an existing phase.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a cuboid and changes the mode. Adds two phases and then inserts a new phase that starts from phase0_s
g_i.cuboid(5)
g_i.gotostages()
phase0_s = g_i.Phases[0]
phase1_s = g_i.phase(phase0_s)

phase2_s = g_i.insertphase(phase1_s)
print(phase2_s)
```

# Python wrapper commands [INSERTPOINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## insertpoint
Inserts a new point to an existing polygon or water level.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Inserts a new point to an existing polygon before a specified point of the polygon

# Inserts a surface and then inserts one additional (5th) point to it
polygon_g = g_i.surface((0, 0, 2), (3, 5, 4), (7, 11, 13), (9, 8, 15))
polygon_g.insertpoint(5, (1, 2, 3))

print(g_i.echo(polygon_g))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Inserts a new point to an existing water level before a specified point of the water level without specifying pressure increment

# Creates a cuboid and changes the mode. Adds a water level and then inserts a new point before the point with index 3
g_i.cuboid(5)
g_i.gotoflow()
waterlevel_s = g_i.waterlevel(1, 4, 6)

waterlevel_s.insertpoint(3, (2, 6, 4))
```

# Python wrapper commands [INSERTSOILLAYER]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## insertsoillayer
Creates a new soil layer above an existing soil layer.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer. Then, inserts a soil layer above the last layer in the list of soil layers
borehole_g = g_i.borehole(1, 4)
g_i.soillayer(3)

soillayer_g = g_i.insertsoillayer(g_i.Soillayers[-1])
print(soillayer_g)
```

# Python wrapper commands [INSERTWATERPOINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## insertwaterpoint
Inserts a new point to an existing water level.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a cuboid and changes the mode and adds a water level
g_i.cuboid(10)
g_i.gotoflow()
waterlevel_s = g_i.waterlevel((6, 4, 1), 2)

# Inserts a new point before the point with index 3 to the existing water lever with pressure increment -5
waterlevel_s.insertwaterpoint(3, (2, 6, 4), -5)
```

# Python wrapper commands [INTERSECT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## intersect
Intersects a number of objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Intersects two or more objects and remove the original objects

# Creates Volume and Soil objects; the first one is the Volume object (multiple times for cuboid, cylinder, and cuboid)
volume1_g = g_i.cuboid(5)[0]
volume2_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
volume3_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]

g_i.intersect(volume1_g, volume2_g, volume3_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Intersects two or more objects and optionally keep the original objects

# Creates Volume and Soil objects; the first one is the Volume object (multiple times for cuboid, cylinder, and cuboid)
volume1_g = g_i.cuboid(5)[0]
volume2_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
volume3_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]

g_i.intersect((volume1_g, volume2_g, volume3_g), True)
```

# Python wrapper commands [intersectsegments]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## intersectsegments
Intersects two or more segments or subsection polycurves and removes the original objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Intersects two or more segments or subsection polycurves and removes the original objects.

# Creates a tunnel and adds cross section segments and a subcurve to intersect one of the segments
tunnel_g = g_i.tunnel((0, 0, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.add()
tunnelsegment_g = tunnel_g.CrossSection.add()
tunnel_g.CrossSection.Segments[1].LineProperties.RelativeStartAngle1 = 90
tunnel_g.CrossSection.Segments[1].LineProperties.Length = 2
tunnelsubcurve_g = tunnel_g.CrossSection.addsubcurve()[-1]
tunnel_g.CrossSection.Subsections[0].Offset2 = 1
tunnel_g.CrossSection.intersectsegments(tunnelsubcurve_g, tunnelsegment_g)
```

# Python wrapper commands [INVERT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## invert
Inverts the custom part and the reference part for a connection.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Changes the mode and creates two polygons. Then, creates plate material and assigns plate features to polygons and materials to plates
g_i.gotostructures()

polygon1_g = g_i.surface((0, -2, 0), (0, 2, 0), (2, 2, 0), (2, -2, 0))
polygon2_g = g_i.surface((0, 0, 0), (0, 0, 2), (2, 0, 2), (2, 0, 0))

platematerial = g_i.platemat()

plate1_g = g_i.plate(polygon1_g, "Material", platematerial)
plate2_g = g_i.plate(polygon2_g, "Material", platematerial)

# Changes the mode and creates a connection between two polygons. Then, inverts the reference to the connection
g_i.gotostages()
polygon1_s = g_i.Surfaces[-2]
polygon2_s = g_i.Surfaces[-1]
connection_s = g_i.connection(polygon1_s, polygon2_s)

connection_s.invert()
```

# Python wrapper commands [INVERTDIRECTION]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## invertdirection
Inverts the direction of a line.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates multiple objects; the last one is the Line object ([-1])
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]

g_i.invertdirection(line_g)
```

# Python wrapper commands [INVERTNORMAL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## invertnormal
Inverts the direction of the normal of a surface.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a polygon and inverts its normal
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))

g_i.invertnormal(polygon_g)
```

# Python wrapper commands [LINE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## line
Creates a line.

---

```python
s_i.new()
```

---

```python
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
print(line_g)
```

---

```python
# Alternative 1
# Creates a line between two points

# Example 1
# Creates multiple objects; the last one is the Line object ([-1]). Displays the line's address in the memory
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
print(line_g)

# Example 2
# Creates a point and then creates a line from the existing and a new point
point_g = g_i.point(2, 3, 4)
line_g = g_i.line((1, 2, 3), point_g)[-1]
print(line_g)

# Example 3
point_g = g_i.point(5, 6, 7)
line_g = g_i.line(point_g, (8, 4, 12))[-1]
print(line_g)

# Example 4
# Creates two points and then creates a line from two existing points
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
line_g = g_i.line(point1_g, point2_g)
print(line_g)
```

---

```python
# Alternative 2
# Creates a line between two or more points

# Example 1
# Creates three points and then creates two lines from the existing points
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
point3_g = g_i.point(5, 6, 7)

# Assigns all objects with type "line" to a variable res. Displays objects' addresses in the memory
res = g_i.line(point1_g, point2_g, point3_g)
lines_g = [item for item in res if item._plx_type == 'Line']
print(lines_g)

# Example 2
# Creates two points and then creates two lines from the existing points and one new point
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
res = g_i.line(point1_g, (1, 2, 3), point2_g)
lines_g = [item for item in res if item._plx_type == 'Line']

print(lines_g)

# Example 3
# Creates one point and then creates three lines from the existing point and three new points
point_g = g_i.point(3, 4, 9)
res = g_i.line((1, 0, 2), (9, 4, 5), (8, 6, 7), point_g)
lines_g = [item for item in res if item._plx_type == 'Line']

print(lines_g)
```

---

```python
# Alternative 3
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect to the XY- and the XZ-plane and a length or a vector describing the direction and a length

# Example 1
# Creates multiple objects; the last one is the Line object ([-1]). Displays objects' addresses in the memory
line_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
print(line_g)

# Example 2
# Creates a point and the two lines
point_g = g_i.point(2, 2, 2)
res = g_i.line(point_g, "relative", (3, 4, 8), (-5, -9, 10), "angles", 0, 30, 16)

# Assigns all objects with type "line" to a variable res. Displays objects' addresses in the memory
lines_g = [item for item in res if item._plx_type == 'Line']
print(lines_g)

# Example 3
# Creates two lines and assigns all objects with type "line" to a variable res
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']

print(lines_g)

# Example 4
# Creates two lines and assigns all objects with type "line" to a variable res
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "vector", (8, 2, 5), 14)
lines_g = [item for item in res if item._plx_type == 'Line']

print(lines_g)

# Example 5
# Creates a point and then multiple objects; the last one is the volume object ([0])
point_g = g_i.point(1, 1, 1)
volume_g = g_i.cuboid(5)[0] 
line_g = g_i.line(point_g, "angles", 90, 0, volume_g)[-1]

print(line_g)

# Obtain Length property value for all lines in a list and display them
lines_length = g_i.Lines.Length.value
print(f'Lines length: {lines_length}')
```

# Python wrapper commands [LINEANGLES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## lineangles
Creates lines in directions specified using angles.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates a point and then multiple objects; the last one is the Line object ([-1]). Then, creates a line using angles and displays line's address in the memory
point_g = g_i.point(2, 2, 2)
line_g = g_i.lineangles(point_g, 0, 30, 16)[-1]
print(line_g)

# Example 2
line_g = g_i.lineangles((1, 2, 0), 30, 0, 9)[-1]
print(line_g)

# Example 3
# Creates a point and then Volume and Soil objects; the first one is the Volume object ([0])
point_g = g_i.point(1, 1, 1)
volume_g = g_i.cuboid(5)[0]

# Creates a line using angles and snaps it to volume_g object
line_g = g_i.lineangles(point_g, 90, 0, volume_g)[-1]
print(line_g)
```

# Python wrapper commands [LINEDISPL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## linedispl
Adds line prescribed displacement features to lines.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds line prescribed displacement features to one or more existing lines in the geometry

# Example 1
# Creates multiple objects, the last one is the Line object and assigns displacement feature to it. Displays line's address in the memory
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
linedisplacement_g = g_i.linedispl(line_g)

print(linedisplacement_g)

# Example 2
# Creates two lines and assigns line displacement feature to them
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
linedisplacements_g = g_i.linedispl(line1_g, line2_g)

print(linedisplacements_g)

# Example 3
# Creates multiple objects, the last one are the Line objects ([-1]) and assigns displacement feature to those lines
line1_g = g_i.line((6, 8, 3), (5, 9, 8))[-1]
line2_g = g_i.line((2, 3, 0), "relative", (3, 4, 8))[-1]
linedisplacements_g = g_i.linedispl((line1_g, line2_g))

print(linedisplacements_g)

# Example 4
# Creates two lines and groups them, then assigns displacement features to the objects in the group
line1_g = g_i.line((5, 9, 7), (8, 8, 10))[-1]
line2_g = g_i.line((1, 2, 3), "relative", (3, 4, 8))[-1]
group_g = g_i.group(line1_g, line2_g)
linedisplacements_g = g_i.linedispl(group_g)

print(linedisplacements_g)
```

---

```python
# Alternative 2
# Creates a line between two points and add a line prescribed displacement feature to it

# Example 1
# Creates a point and then multiple objects, last two are Line and LineDisplacement objects respectively
point_g = g_i.point(3, 4, 9)
line_g, linedisplacement_g = g_i.linedispl(point_g, (5, 6, 7))[-2:]
print(line_g, linedisplacement_g)

# Example 2
# Creates two points and then using one function creates a line from those points, and then assigns displacement feature to the line
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
line_g, linedisplacement_g = g_i.linedispl(point1_g, point2_g)
print(line_g, linedisplacement_g)

# Example 3
line_g, linedisplacement_g = g_i.linedispl((1, 4, 0), (6, 5, 8))[-2:]
print(line_g, linedisplacement_g)
```

---

```python
# Alternative 3
# Creates lines between three or more points and add line prescribed displacement features to them

# Creates two points, and then two lines. Then assigns all line objects to the variable lines_g and all displacement objects to linedisplacements_g
point1_g, point2_g = g_i.point((3, 4, 9), (5, 2, 10))
res = g_i.linedispl(point1_g, (5.1, 6.4, 7.2), point2_g)
lines_g = [item for item in res if item._plx_type == 'Line']
linedisplacements_g = [item for item in res if item._plx_type == 'LineDisplacement']

print(lines_g, linedisplacements_g)
```

---

```python
# Alternative 4
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect to the XY- and the XZ-plane and a length or a vector describing the direction and a length and add line prescribed displacement features to them

# Example 1
# Creates multiple objects; last two are Line and LineDisplacement objects respectively
line_g, linedisplacement_g = g_i.linedispl((1, 2, 0), "relative", (3, 4, 8))[-2:]
print(line_g, linedisplacement_g)

# Example 2
# Creates a point and then using one function creates two lines (using existing point), and assigns displacement features to them
point_g = g_i.point(3, 4, 9)
res = g_i.linedispl(point_g, "relative", (3, 4, 8), (-5, -9, 10), "angles", 0, 30, 16)

# Then assigns all line objects to the variable lines_g and all displacement objects to linedisplacements_g
lines_g = [item for item in res if item._plx_type == 'Line']
linedisplacements_g = [item for item in res if item._plx_type == 'LineDisplacement']
print(lines_g, linedisplacements_g)

# Example 3
res = g_i.linedispl((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
linedisplacements_g = [item for item in res if item._plx_type == 'LineDisplacement']
print(lines_g, linedisplacements_g)

# Example 4
# Creates multiple objects; the last one are the Line objects ([-1]), assigns displacement features to those lines, and snaps them to the volume
point_g = g_i.point(1, 1, 1)
volume_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]
line_g, linedisplacement_g = g_i.linedispl(point_g, "angles", 90, 0, volume_g)[-2:]
print(line_g, linedisplacement_g)
```

---

```python
# Alternative 5
# Adds line prescribed displacement features to one or more existing lines in the geometry and directly set their properties

# Example 1
# Creates multiple objects, the last one is the Line object and assigns displacement feature to it, setting some properties
line_g = g_i.line((8, 9, 7), (8, 8, 10))[-1]
linedisplacement_g = g_i.linedispl(line_g, "Displacement_x", "Fixed",
                                   "Displacement_y", "Prescribed")
print(linedisplacement_g)

# Example 2
# Creates multiple objects, the last one are the Line objects and assigns displacement features to them, setting some properties
line1_g = g_i.line((3, 2, 7), (5, 6, 10))[-1] 
line2_g = g_i.line((4, 2, 3), "relative", (3, 4, 8))[-1]
linedisplacements_g = g_i.linedispl((line1_g, line2_g), "Displacement_x", 
                                    "Fixed", "Displacement_y", "Prescribed")
print(linedisplacements_g)
```

---

```python
# Alternative 6
# Creates a line between two points, add a line prescribed displacement feature to it and directly set its properties

point_g = g_i.point(3, 4, 9)
line_g, linedisplacement_g = g_i.linedispl(point_g, (5, 6, 7), "Displacement_x", "Fixed", 
                                           "Displacement_y", "Prescribed")[-2:]
print(line_g, linedisplacement_g)
```

---

```python
# Alternative 7
# Creates lines between three or more points, add line prescribed displacement features to them and directly set their properties

# Creates multiple objects; the last one are the Line objects and assigns displacement features to them, setting some properties
point1_g, point2_g = g_i.point((5, 7, 9), (5, 4, 10))
res = g_i.linedispl(point1_g, (5.1, 6.4, 7.2), point2_g, "Displacement_x", "Fixed",
                    "Displacement_y", "Prescribed")

# Then assigns all line objects to the variable lines_g and all displacement objects to linedisplacements_g
lines_g = [item for item in res if item._plx_type == 'Line']
linedisplacements_g = [item for item in res if item._plx_type == 'LineDisplacement']
print(lines_g, linedisplacements_g)
```

---

```python
# Alternative 8
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect to the XY- and the XZ-plane and a length or a vector describing the direction and a length, add line prescribed displacement features to them and directly set their properties

# Creates multiple objects; the last two are the Line and LineDisplacement objects
line_g, linedisplacement_g = g_i.linedispl((1, 2, 0), "relative", (3, 4, 8), 
                                           "Displacement_x", "Fixed", 
                                           "Displacement_y", "Prescribed")[-2:]
print(line_g, linedisplacement_g)

# Obtain Displacement_z property value assigned for all line displacements in a list and display them
linedispls_disp_z = g_i.LineDisplacements.Displacement_z.value
print(f'Line displacements Displacement_z property: {linedispls_disp_z}')
```

# Python wrapper commands [LINEDRAIN]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## linedrain
Adds line drain features to lines.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds line drain features to one or more existing lines in the geometry

# Example 1
# Creates multiple objects, the last one is the Line object and assigns drain feature to it. Displays line's address in the memory
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
linedrain_g = g_i.linedrain(line_g)

print(linedrain_g)

# Example 2
# Creates two lines and assigns line drain feature to them
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
linedrains_g = g_i.linedrain(line1_g, line2_g)

print(linedrains_g)

# Example 3
# Creates multiple objects, the last one are the Line objects ([-1]) and assigns drain feature to those lines
line1_g = g_i.line((6, 8, 3), (5, 9, 8))[-1]
line2_g = g_i.line((2, 3, 0), "relative", (3, 4, 8))[-1]
linedrains_g = g_i.linedrain((line1_g, line2_g))

print(linedrains_g)

# Example 4
# Creates two lines and groups them, then assigns drain features to the objects in the group
line1_g = g_i.line((5, 9, 7), (8, 8, 10))[-1]
line2_g = g_i.line((1, 2, 3), "relative", (3, 4, 8))[-1]
group_g = g_i.group(line1_g, line2_g)
linedrains_g = g_i.linedrain(group_g)

print(linedrains_g)
```

---

```python
# Alternative 2
# Creates a line between two points and add a line drain feature to it

# Example 1
# Creates a point and then multiple objects, last two are Line and LineDrain objects respectively
point_g = g_i.point(3, 4, 9)
line_g, linedrain_g = g_i.linedrain(point_g, (5, 6, 7))[-2:]

print(line_g, linedrain_g)

# Example 2
# Creates two points and then using one function creates a line from those points, and then assigns drain feature to the line
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
line_g, linedrain_g = g_i.linedrain(point1_g, point2_g)
print(line_g, linedrain_g)

# Example 3
# Creates multiple objects, the last two are the Line and LineDrain objects
line_g, linedrain_g = g_i.linedrain((1, 4, 0), (6, 5, 8))[-2:]
print(line_g, linedrain_g)
```

---

```python
# Alternative 3
# Creates lines between three or more points and add line drain features to them

# Creates two points, and then two lines. Then assigns all line objects to the variable lines_g and all drain objects to linedrains_g
point1_g, point2_g = g_i.point((3, 4, 9), (5, 2, 10))
res = g_i.linedrain(point1_g, (5.1, 6.4, 7.2), point2_g)
lines_g = [item for item in res if item._plx_type == 'Line']
linedrains_g = [item for item in res if item._plx_type == 'LineDrain']

print(lines_g, linedrains_g)
```

---

```python
# Alternative 4
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect to the XY- and the XZ-plane and a length or a vector describing the direction and a length and add line drain features to them

# Example 1
# Creates multiple objects, last two are Line and LineDrain objects respectively
line_g, linedrain_g = g_i.linedrain((1, 2, 0), "relative", (3, 4, 8))[-2:]
print(line_g, linedrain_g)

# Example 2
# Creates a point and then using one function creates two lines (using existing point), and assigns drain features to them
point_g = g_i.point(3, 4, 9)
res = g_i.linedrain(point_g, "relative", (3, 4, 8), (-5, -9, 10), "angles", 0, 30, 16)

# Then assigns all line objects to the variable lines_g and all drain objects to linedrains_g
lines_g = [item for item in res if item._plx_type == 'Line']
linedrains_g = [item for item in res if item._plx_type == 'LineDrain']

print(lines_g, linedrains_g)

# Example 3
res = g_i.linedrain((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
linedrains_g = [item for item in res if item._plx_type == 'LineDrain']
print(lines_g, linedrains_g)

# Example 4
# Creates multiple objects; the last one are the Line objects ([-1]) and assigns drain feature to those lines
point_g = g_i.point(1, 1, 1)
volume_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]

line_g, linedrain_g = g_i.linedrain(point_g, "angles", 90, 0, volume_g)[-2:]
print(line_g, linedrain_g)
```

---

```python
# Alternative 5
# Adds line drain features to one or more existing lines in the geometry and directly set their properties

# Example 1
# Creates multiple objects, the last one is the Line object and assigns displacement feature to it, setting some properties
line_g = g_i.line((8, 9, 7), (8, 8, 10))[-1]
linedrain_g = g_i.linedrain(line_g, "h", 1.2)

print(linedrain_g)

# Example 2
# Creates multiple objects; the last one are the Line objects and assigns drain features to them, setting some properties
line1_g = g_i.line((3, 2, 7), (5, 6, 10))[-1]
line2_g = g_i.line((4, 2, 3), "relative", (3, 4, 8))[-1]

linedrains_g = g_i.linedrain((line1_g, line2_g), "h", 1.2)
print(linedrains_g)
```

---

```python
# Alternative 6
# Creates a line between two points, add a line drain feature to it and directly set its properties
point_g = g_i.point(3, 4, 9)

# Creates multiple objects, the last two are the Line and LineDrain objects
line_g, linedrain_g = g_i.linedrain(point_g, (5, 6, 7), "h", 1.2)[-2:]
print(line_g, linedrain_g)
```

---

```python
# Alternative 7
# Creates lines between three or more points, add line drain features to them and directly set their properties

# Creates multiple objects, the last one are the Line objects and assigns drain features to them, setting some properties
point1_g, point2_g = g_i.point((5, 7, 9), (5, 4, 10))
res = g_i.linedrain(point1_g, (5.1, 6.4, 7.2), point2_g, "h", 1.2)

# Then assigns all line objects to the variable lines_g and all drain objects to linedrain_g
lines_g = [item for item in res if item._plx_type == 'Line']
linedrains_g = [item for item in res if item._plx_type == 'LineDrain']
print(lines_g, linedrains_g)
```

---

```python
# Alternative 8
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect
# to the XY- and the XZ-plane and a length or a vector describing the direction and a length, add line drain features to them and directly set their properties

# Creates multiple objects, the last two are the Line and LineDrain objects
line_g, linedrain_g = g_i.linedrain((1, 2, 0), "relative", (3, 4, 8), "h", 1.2)[-2:]
print(line_g, linedrain_g)

# Obtain Behaviour property value assigned for all line drains in a list and display them
linedrains_behaviour= g_i.LineDrains.Behaviour.value
print(f'Line Drains Behaviour property: {linedrains_behaviour}')
```

# Python wrapper commands [LINELOAD]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## lineload
Adds line load features to lines.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds line load features to one or more existing lines in the geometry

# Example 1
# Creates multiple objects, the last one is the Line object and assigns load feature to it. Displays line's address in the memory
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
lineload_g = g_i.lineload(line_g)

print(lineload_g)

# Example 2
# Creates two lines and assigns line load feature to them
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
lineloads_g = g_i.lineload(line1_g, line2_g)

print(lineloads_g)

# Example 3
# Creates multiple objects; the last one are the Line objects ([-1]) and assigns load feature to those lines
line1_g = g_i.line((6, 8, 3), (5, 9, 8))[-1] 
line2_g = g_i.line((2, 3, 0), "relative", (3, 4, 8))[-1]
lineloads_g = g_i.lineload((line1_g, line2_g))

print(lineloads_g)

# Example 4
# Creates two lines and groups them, then assigns load features to the objects in the group
line1_g = g_i.line((5, 9, 7), (8, 8, 10))[-1]
line2_g = g_i.line((1, 2, 3), "relative", (3, 4, 8))[-1]
group_g = g_i.group(line1_g, line2_g)
lineloads_g = g_i.lineload(group_g)

print(lineloads_g)
```

---

```python
# Alternative 2
# Creates a line between two points (which may either exist or will be created) and add a line load feature to it

# Example 1
# Creates a point and then multiple objects, last two are Line and LineLoad objects respectively
point_g = g_i.point(3, 4, 9)
line_g, lineload_g = g_i.lineload(point_g, (5, 6, 7))[-2:]

print(line_g, lineload_g)

# Example 2
# Creates two points and then using one function creates a line from those points, and then assigns load feature to the line
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
line_g, lineload_g = g_i.lineload(point1_g, point2_g)

print(line_g, lineload_g)

# Example 3
# Creates multiple objects, the last two are the Line and LineDrain objects
line_g, lineload_g = g_i.lineload((1, 4, 0), (6, 5, 8))[-2:]
print(line_g, lineload_g)
```

---

```python
# Alternative 3
# Creates lines between three or more points (which may either exist or will be created) and add line load features to them

# Creates two points, and then two lines. Then assigns all line objects to the variable lines_g and all load objects to lineloads_g
point1_g, point2_g = g_i.point((3, 4, 9), (5, 2, 10))
res = g_i.lineload(point1_g, (5.1, 6.4, 7.2), point2_g)
lines_g = [item for item in res if item._plx_type == 'Line']
lineloads_g = [item for item in res if item._plx_type == 'LineLoad']

print(lines_g, lineloads_g)
```

---

```python
# Alternative 4
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect to the XY- and the XZ-plane and a length or a vector describing the direction and a length and add line load features to them

# Example 1
# Creates multiple objects; last two are Line and LineLoad objects respectively
line_g, lineload_g = g_i.lineload((1, 2, 0), "relative", (3, 4, 8))[-2:]

print(line_g, lineload_g)

# Example 2
# Creates a point and then using one function creates two lines (using existing point), and assigns load features to them
point_g = g_i.point(3, 4, 9)
res = g_i.lineload(point_g, "relative", (3, 4, 8), (-5, -9, 10), "angles", 0, 30, 16)

# Then assigns all line objects to the variable lines_g and all load objects to lineloads_g
lines_g = [item for item in res if item._plx_type == 'Line']
lineloads_g = [item for item in res if item._plx_type == 'LineLoad']

print(lines_g, lineloads_g)

# Example 3
res = g_i.lineload((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
lineloads_g = [item for item in res if item._plx_type == 'LineLoad']

print(lines_g, lineloads_g)

# Example 4
# Creates multiple objects, the last one are the Line objects ([-1]), assigns load features to those lines, and snaps them to the volume
point_g = g_i.point(1, 1, 1)
volume_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]
line_g, lineload_g = g_i.lineload(point_g, "angles", 90, 0, volume_g)[-2:]

print(line_g, lineload_g)
```

---

```python
# Alternative 5
# Adds line load features to one or more existing lines in the geometry and directly set their properties

# Example 1
# Creates multiple objects, the last one is the Line object and assigns load feature to it, setting some properties
line_g = g_i.line((8, 9, 7), (8, 8, 10))[-1]

lineload_g = g_i.lineload(line_g, "qx_start", 3, "qy_start", 7)
print(lineload_g)

# Example 2
# Creates multiple objects, the last one are the Line objects and assigns displacement features to them, setting some properties
line1_g = g_i.line((3, 2, 7), (5, 6, 10))[-1]
line2_g = g_i.line((4, 2, 3), "relative", (3, 4, 8))[-1]
lineloads_g = g_i.lineload((line1_g, line2_g), "qx_start", 3, "qy_start", 7)

print(lineloads_g)
```

---

```python
# Alternative 6
# Creates a line between two points, add a line load feature to it and directly set its properties

point_g = g_i.point(3, 4, 9)
line_g, lineload_g = g_i.lineload(point_g, (5, 6, 7), "qx_start", 3, "qy_start", 7)[-2:]

print(line_g, lineload_g)
```

---

```python
# Alternative 7
# Creates lines between three or more points, add line load features to them and directly set their properties

# Creates multiple objects, the last one are the Line objects and assigns load features to them, setting some properties
point1_g, point2_g = g_i.point((5, 7, 9), (5, 4, 10))
res = g_i.lineload(point1_g, (5.1, 6.4, 7.2), point2_g, "qx_start", 3, "qy_start", 7)

# Then assigns all line objects to the variable lines_g and all load objects to lineloads_g
lines_g = [item for item in res if item._plx_type == 'Line']
lineloads_g = [item for item in res if item._plx_type == 'LineLoad']

print(lines_g, lineloads_g)
```

---

```python
# Alternative 8
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by giving the angles with respect to the XY- and the XZ-plane and a length or a vector describing the direction and a length, add line load features to them and directly set their properties

# Creates multiple objects, the last two are the Line and LineLoad objects
line_g, lineload_g = g_i.lineload((1, 2, 0), "relative", (3, 4, 8), 
                                  "qx_start", 3, "qy_start", 7)[-2:]
print(line_g, lineload_g)

# Obtain Distribution property value assigned for all line loads in a list and display them
lineloads_distribution = g_i.LineLoads.Distribution.value
print(f'Line Loads Distribution property: {lineloads_distribution}')
```

# Python wrapper commands [LINEMOVEMENT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## linemovement
Creates a line movement

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates line movement on line or line movement objects

# Example 1
# Creates multiple objects, the last one is the Line object and assigns movement feature to it. Displays movement's address in the memory
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
linemovement_g = g_i.linemovement(line_g)[-1]

print(linemovement_g)

# Example 2
# Creates two lines and assigns line movement feature to them
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
linemovements_g = g_i.linemovement(line1_g, line2_g)

print(linemovements_g)

# Example 3
# Creates multiple objects, the last one are the Line objects ([-1]) and assigns movement feature to those lines
line1_g = g_i.line((6, 8, 3), (5, 9, 8))[-1]
line2_g = g_i.line((2, 3, 0), "relative", (3, 4, 8))[-1]
linemovements_g = g_i.linemovement((line1_g, line2_g))

print(linemovements_g)

# Example 4
# Creates two lines and groups them, then assigns movement features to the objects in the group
line1_g = g_i.line((5, 9, 7), (8, 8, 10))[-1]
line2_g = g_i.line((1, 2, 3), "relative", (3, 4, 8))[-1]
group_g = g_i.group(line1_g, line2_g)
linemovements_g = g_i.linemovement(group_g)

print(linemovements_g)
```

---

```python
# Alternative 2
# Creates a line movement between two points

# Example 1
# Creates a point and then multiple objects, last two are Line and LineMovement objects respectively
point_g = g_i.point(3, 4, 9)
line_g, linemovement_g = g_i.linemovement(point_g, (5, 6, 7))[-2:]
print(line_g, linemovement_g)

# Example 2
# Creates two points and then using one function creates a line from those points, and then assigns movement feature to the line
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
line_g, linemovement_g = g_i.linemovement(point1_g, point2_g)[-2:]
print(line_g, linemovement_g)

# Example 3
line_g, linemovement_g = g_i.linemovement((1, 4, 0), (6, 5, 8))[-2:]
print(line_g, linemovement_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Creates one or more line movements between two or more points

# Creates two points, and then two lines. Then assigns all line objects to the variable lines_g and all movement objects to linemovements_g
point1_g, point2_g = g_i.point((3, 4, 9), (5, 2, 10))
res = g_i.linemovement(point1_g, (5.1, 6.4, 7.2), point2_g)
lines_g = [item for item in res if item._plx_type == 'Line']
linemovement_g = [item for item in res if item._plx_type == 'LineMovement']

print(lines_g, linemovement_g)
```

---

```python
# Alternative 4
# Creates one or more line movement objects by either giving absolute coordinates or relative coordinates, by giving the angles with respect to the xz- and the xy-plane and a length or a vector describing the direction and a length

# Example 1
# Creates multiple objects; last two are Line and LineMovement objects respectively
line_g, linemovement_g = g_i.linemovement((1, 2, 0), "relative", (3, 4, 8))[-2:]
print(line_g, linemovement_g)

# Example 2
# Creates a point and then using one function creates two lines (using existing point), and assigns displacement features to them
point_g = g_i.point(3, 4, 9)
res = g_i.linemovement(point_g, "relative", (3, 4, 8), (-5, -9, 10), "angles", 0, 30, 16)

# Then assigns all line objects to the variable lines_g and all movement objects to linemovements_g
lines_g = [item for item in res if item._plx_type == 'Line']
linemovements_g = [item for item in res if item._plx_type == 'LineMovement']
print(lines_g, linemovements_g)

# Example 3
res = g_i.linemovement((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
linemovements_g = [item for item in res if item._plx_type == 'LineMovement']
print(lines_g, linemovements_g)

# Example 4
# Creates multiple objects; the last one are the Line objects ([-1]), assigns movement features to those lines, and snaps them to the volume
point_g = g_i.point(1, 1, 1)
volume_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]
line_g, linemovement_g = g_i.linemovement(point_g, "angles", 90, 0, volume_g)[-2:]
print(line_g, linemovement_g)
```

# Python wrapper commands [LINEPARALLEL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## lineparallel
Creates a line parallel to another line.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a line from a point (which may either exist or will be created) parallel to an existing line with the same length

# Creates a point, and then a line. And then from a defined points creates a new line parallel to the existing line
point_g = g_i.point(2, 2, 2)
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1] 
line_g = g_i.lineparallel(point_g, line1_g)[-1]

print(line_g)
```

---

```python
# Alternative 2
# Creates a line from a point (which may either exist or will be created) parallel to an existing line with a specified length

line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line_g = g_i.lineparallel((0, 1, 0), line1_g, 10)[-1]
print(line_g)
```

# Python wrapper commands [LINERELATIVE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## linerelative
Creates lines using relative coordinates.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates a point and then multiple objects, the last one is the Line object
point_g = g_i.point(2, 3, 4)
line_g = g_i.linerelative(point_g, (6, 4, 8))[-1]

print(line_g)

# Example 2
point_g = g_i.point(2, 3, 4)
res = g_i.linerelative(point_g, (6, 4, 8), (1, 5, 3))

# Assigns all line type objects to the variable lines_g
lines_g = [item for item in res if item._plx_type == 'Line']

print(lines_g)
```

# Python wrapper commands [LINEVECTOR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## linevector
Creates lines in directions specified using vectors.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates multiple objects; the last one is the Line object. Creates a line with direction defined by two points and length of 14
point_g = g_i.point(2, 3, 4)
line_g = g_i.linevector(point_g, (6, 4, 8), 14)[-1]
print(line_g)

# Example 2
res = g_i.linevector((1, 2, 3), (5, 4, 6), 12, (9, 7, 8), 10)

# Assigns all line type objects to the variable lines_g
lines_g = [item for item in res if item._plx_type == 'Line']
print(lines_g)

# Example 3
point_g = g_i.point(0, 0, 0)
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line_g = g_i.linevector(point_g, (-1, 2, 3.2), line1_g)[-1]
print(line_g)
```

# Python wrapper commands [LOADMULTIPLIER]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## loadmultiplier
Adds a load multiplier.

---

```python
s_i.new()
```

---

```python
# Alternative 1
for i in range(3):
    g_i.loadmultiplier()

print(g_i.tabulate(g_i.DynamicMultipliers))

# Obtain Signal property value assigned for all load multipliers in a list and display them
loadmultipliers_signal = g_i.DynamicMultipliers.Signal.value
print(f'Load multipliers signal: {loadmultipliers_signal}')
```

# Python wrapper commands [LOFT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## loft
Creates a surface passing through the list of polycurves specified in the commmand's parameter.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a surface passing through the two polycurves specified in the commmand's parameter.
g_i.gotostructures()

# Creates two polycurves at specific coordinates with a local first axis in the direction of the global z-axis, a local second axis in the direction of the global x-axis and adds an arc segment to each.
polycurve1_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), "arc", 45, 90, 3)[0]
polycurve2_g = g_i.polycurve((4, 0, 6), (0, 0, 1), (1, 0, 0), "arc", 45, 90, 3)[0]

lofted_surface = g_i.loft(polycurve1_g, polycurve2_g)
print(lofted_surface)
```

---

```python
# Alternative 2
# Creates a surface passing through the three polycurves specified in the commmand's parameter.
g_i.gotostructures()

# Creates three polycurves at specific coordinates with a local first axis in the direction of the global z-axis, a local second axis in the direction of the global x-axis and adds an arc segment to each.
polycurve1_g = g_i.polycurve((10, 5, 6), (0, 0, 1), (1, 0, 0), "arc", 45, 90, 3)[0]
polycurve2_g = g_i.polycurve((10, 0, 6), (0, 0, 1), (1, 0, 0), "arc", 45, 90, 3)[0]
polycurve3_g = g_i.polycurve((10.5, 10, 6), (0, 0, 1), (1, 0, 0), "arc", 45, 90, 2)[0]

lofted_surface = g_i.loft(polycurve1_g, polycurve2_g, polycurve3_g)
print(lofted_surface)
```

# Python wrapper commands [MATERIALCOMMAND]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## materialcommand
Generates the PLAXIS command that can be used to define an equivalent soil material and its properties.

---

```python
s_i.new()
```

---

```python
# Alternative 1
g_i.soilmat("Identification", "Sand", "SoilModel", "Hardening Soil", "gammaUnsat", 17, "gammaSat", 20, "E50Ref", 40000, "cRef", 0.1, "phi", 32)
material_command = g_i.Materials[-1].materialcommand()
print(material_command)
```

# Python wrapper commands [MERGEEQUIVALENTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## mergeequivalents
Merges geometric objects with a default tolerance value of 0.001 or with an optional tolerance parameter. This command removes existing objects and creates new features. The specified objects are used as initial merge set. It is possible that the merge operation will also affect objects that are directly or indirectly connected to the initial merge set (e.g. the lines connected to explicitly specified points will implicitly be taken into account during the merge operation).

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Merges geometric objects with a default tolerance value of 0.001

# Creates three points and then merges objects which are close to each other. This command removes existing objects (point2_g)
point1_g, point2_g = g_i.point((3, 4, 9), (3, 4, 9))

print(g_i.mergeequivalents(point1_g, point2_g))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Merges geometric objects with tolerance. This command removes existing objects and creates new features

# Creates three points, and two lines then merges all equivalent geometry (deletes third point, Line_2, and its points)
g_i.point((3, 4, 9), (1, 1, 1), (3, 4, 9))
g_i.line((5, 6, 7), (8, 9, 10))
g_i.line((5, 6, 7), (8, 9, 10))

g_i.gotostructures()

print(g_i.mergeequivalents(g_i.Geometry))
```

# Python wrapper commands [MESH]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## mesh
Generates a mesh.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Generates a mesh of the available meshable objects

# Creates a cuboid, changes the mode and generates the mesh
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.mesh()
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Generates a mesh of the available meshable objects with a defined relative element size factor

# Changes the mode, creates a cuboid, changes the mode again and generates the mesh with a relative element size factor of 0.1
g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.mesh(0.1)
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Generates a mesh of the available meshable objects with a defined relative element size factor and enhanced mesh refinements (EMR)

g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.mesh("Coarseness", 0.1, "UseEnhancedRefinements", True)
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Generates a mesh of the available meshable objects with a defined relative element size factor, with enhanced mesh refinements (EMR) and a global EMR scale factor

g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.mesh("Coarseness", 0.1, "UseEnhancedRefinements", True, "EMRGlobalScale", 1.2)
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Generates a mesh of the available meshable objects with a defined relative element size factor, with enhanced mesh refinements (EMR), a global EMR scale factor, and an EMR minimum size factor

g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.mesh("Coarseness", 0.1, "UseEnhancedRefinements", True, "EMRGlobalScale", 1.2, "EMRMinElementSize", 0.005)
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Generates a mesh of the available meshable objects with a defined relative element size factor, with enhanced mesh refinements (EMR), a global EMR scale factor, a minimum size factor, and a proximity size factor

g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.mesh("Coarseness", 0.1, "UseEnhancedRefinements", True, "EMRGlobalScale", 1.2, "EMRMinElementSize", 0.005, "EMRProximity", 0.2)
```

---

```python
s_i.new()
```

---

```python
# Alternative 7
# Generates a mesh of the available meshable objects with a defined element size factor, with enhanced mesh refinements (EMR), a global EMR scale factor, a minimum size factor, a proximity size factor, and using swept meshing.

g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh(),
g_i.mesh("Coarseness", 0.1, "UseEnhancedRefinements", True, "EMRGlobalScale", 1.2, "EMRMinElementSize", 0.005, "EMRProximity", 0.2, "UseSweptMeshing", True)
```

# Python wrapper commands [MESHD]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## meshd
Generates a mesh based on element dimension specified in length units rather than as a factor.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Generates a mesh of the available meshable objects

# Creates a cuboid, then changes mode and generates mesh
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()

g_i.meshd()
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Generates a mesh of the available meshable objects with specified element dimension

# Generates the mesh with an element dimension of 0.1 project length units
g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.meshd(0.5)
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Generates a mesh of the available meshable objects with specified element dimension and maximum processor cores to use

# Generates the mesh with an element dimension of 0.5 project length units using four processor cores
g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.meshd(0.5, 4)
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Generates a mesh of the available meshable objects with specified element dimension, maximum processor cores to use and with enhanced mesh refinements

# Generates the mesh with an element dimension of 0.5 project length units using four processor cores and enhanced mesh refinements
g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.meshd(0.5, 4, True)
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Generates a mesh of the available meshable objects with specified element dimension, maximum processor cores to use and with enhanced mesh refinements 

g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.meshd(0.5, 4, True, 1.2)
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Generates a mesh of the available meshable objects with specified element dimension, maximum processor cores to use, enhanced mesh refinements, global scale factor, minimum size factor, and proximity size factor

g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.meshd(0.5, 4, True, 1.2, 0.005)
```

---

```python
s_i.new()
```

---

```python
# Alternative 7
# Generates a mesh of the available meshable objects with specified element dimension, maximum processor cores to use, enhanced mesh refinements, global scale factor, minimum size factor, and proximity size factor

g_i.gotostructures()
g_i.cuboid(2, 3, 5, (0, 0, 1), (5, 7, 12))
g_i.gotomesh()
g_i.meshd(0.5, 4, True, 1.2, 0.005, 0.2)
```

# Python wrapper commands [MOVE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## move
Moves an object.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Moves one or more objects in a specified direction

# Example 1
# Creates two lines and then moves them in the direction specified by the vector
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type=='Line']

print(g_i.move((lines_g[-2], lines_g[-1]), (0, 1, 5)))

# Example 2
# Creates a point and then multiple objects, the last one is the Line object ([-1]). Moves the objects
point_g = g_i.point(3, 4, 9)
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
g_i.move((line_g, point_g), (0, 1, 5))

print(g_i.echo(line_g, point_g))
```

---

```python
# Alternative 2
# Moves an object in a specified direction

point_g = g_i.point(1, 1, 1)
point_g.move(2, 3, 4)

print(g_i.echo(point_g))
```

---

```python
# Alternative 3
# Moves a water level along the z-axis over a specified distance

# Deletes all objects in the project, creates a cuboid, and changes the mode. Adds water level and the moves it one unit upward
g_i.clear()
g_i.cuboid(5)
g_i.gotoflow()
waterlevel_s = g_i.waterlevel(1, 4, 6)
waterlevel_s.move(1)

print(g_i.echo(waterlevel_s))
```

---

```python
# Alternative 4
# Moves a borehole in the (x,y)-plane over a specified distance

# Creates a borehole and moves it 3 units along the x-axis and 7 units along the y-axis
g_i.gotosoil()
borehole_g = g_i.borehole(0, 0)
borehole_g.move(3, 7)

print(g_i.echo(borehole_g))
```

# Python wrapper commands [MOVEMENTFUNCTION]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## movementfunction
Adds a movementfunction.

---

```python
s_i.new()
```

---

```python
# Alternative 1
for i in range(3):
    g_i.movementfunction()
    
print(g_i.tabulate(g_i.MovementFunctions))

# Obtain Signal property value assigned for all movement functions in a list and display them
movementfunctions_signal = g_i.MovementFunctions.Signal.value
print(f'Movement functions signal: {movementfunctions_signal}')
```

# Python wrapper commands [MOVEPOINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## movepoint
Moves a point of a polygon or water level.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Moves a point of a polygon to another location

# Creates a surface and moves the point with index 4 of the surface
polygon_g = g_i.surface((0, 0, 0), (1, 1, 1), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon_g.movepoint(4, (1, 2, 3))

print(g_i.echo(polygon_g))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Moves a point of a water level to another location and changes the zref (z-coordinate where the pore pressure is equal to zero)

# Creates a cuboid, changes the mode and adds a water level. Then moves point with index 3 of the water level
g_i.cuboid(5)
g_i.gotoflow()
waterlevel_s = g_i.waterlevel((1, 4, 6), (2, 4, 5), (7, 4, 6), (6, 2, 6))
waterlevel_s.movepoint(3, (1, 2, 3))

print(g_i.echo(waterlevel_s))
```

# Python wrapper commands [MULTIPLY]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## multiply
Multiplies properties of objects with a specified factor.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Multiplies properties of objects with a specified factor

# Creates a point and assigns a load feature to it and then multiplies them by 4 (point and features)
point_g = g_i.point(3, 4, 9)
pointload_g = g_i.pointload(point_g)

pointload_g.multiply(4)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Multiplies properties of objects with a specified factor

line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
lineload_g = g_i.lineload(line_g)
lineload_g.qx_start.set(5)
g_i.cuboid(5)

g_i.gotostages()
lineload_s = g_i.LineLoads[0]


phase0_s = g_i.Phases[0]
phase1_s = g_i.phase(phase0_s)
phase2_s = g_i.phase(phase1_s)
phase3_s = g_i.phase(phase2_s)

lineload_s.multiply("qx_start", phase3_s, 2)

print(g_i.tabulate(lineload_s, phase3_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Multiplies properties of objects with a specified factor

# Example 1
# Creates a point, assigns load to it and then creates multiple objects, the last one is the Line object ([-1]) and also assigns load feature to it
point_g = g_i.point(3, 4, 9)
pointload_g = g_i.pointload(point_g)
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
lineload_g = g_i.lineload(line_g)

# Multiplies all line load's force components by 2 and point load's y force component by 2
lineload_g.multiply(2), pointload_g.Fy.multiply(2)

# Example 2
point1_g, point2_g = g_i.point((3, 4, 9), (5, 2, 10))
pointload1_g = g_i.pointload(point1_g)
pointload2_g = g_i.pointload(point2_g)

pointload1_g.multiply("Fy", 2), pointload2_g.multiply("Fy", 2)

# Example 3
g_i.clear()
point1_g, point2_g = g_i.point((3, 4, 0), (1, 1, 1))
pointload1_g = g_i.pointload(point1_g)
pointload2_g = g_i.pointload(point2_g)
g_i.cuboid(10)

g_i.gotostages()
pointload1_s = g_i.Pointloads[-2]
pointload2_s = g_i.Pointloads[-1]
phase0_s = g_i.InitialPhase

pointload1_s.multiply("Fy", phase0_s, 2), pointload2_s.multiply("Fy", phase0_s, 2)
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Multiplies properties of objects with a specified factor

# Creates two lines and assigns load features to them and then multiplies qy_start component of line load by 2
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type=='Line']
lineload_g = g_i.lineload(lines_g[0], "qy_start", 1)

lineload_g.multiply("qy_start", 2)
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Multiplies properties of objects with a specified factor

# Creates multiple objects and then multiplies line load's and point load's force components by 2
point_g = g_i.point(5, 2, 10)
pointload_g = g_i.pointload(point_g)
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
lineload_g = g_i.lineload(line_g)

g_i.multiply((lineload_g, pointload_g), 2)
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Multiplies properties of objects with a specified factor

# Creates multiple objects and then multiplies line load's and point load's y force components by 2
point1_g, point2_g = g_i.point((3, 4, 0), (1, 1, 1))
pointload1_g = g_i.pointload(point1_g)
pointload2_g = g_i.pointload(point2_g)

g_i.multiply((pointload1_g, pointload2_g), "Fy", 2)
```

# Python wrapper commands [N2NANCHOR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## n2nanchor
Adds node-to-node anchor features to lines.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds node-to-node anchor features to one or more existing lines in the geometry

# Example 1
# Creates multiple objects, the last one is the Line object ([-1]) and assigns anchor feature to this line. Displays anchor's address in the memory
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
anchor_g = g_i.n2nanchor(line_g)

print(anchor_g)

# Example 2
# Creates multiple objects, the last one are the Line object and assigns anchor features to those lines
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
anchors_g = g_i.n2nanchor(line1_g, line2_g)

print(anchors_g)

# Example 3
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
anchors_g = g_i.n2nanchor((line1_g, line2_g))

print(anchors_g)

# Example 4
# Creates two lines and groups them, then assigns anchor features to the objects in the group
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
group_g = g_i.group(line1_g, line2_g)
anchors_g = g_i.n2nanchor(group_g)

print(anchors_g)
```

---

```python
# Alternative 2
# Creates a line between two points (which may either exist or will be created) and adds a node-to-node anchor feature to it

# Example 1
# Creates a point and then multiple objects; last two are Line and NodeToNodeAnchor objects respectively
point_g = g_i.point(3, 4, 9)
line_g, anchor_g = g_i.n2nanchor(point_g, (5, 6, 7))[-2:]

print(line_g, anchor_g)

# Example 2
# Creates two points and then using one function creates a line from those points, and then assigns anchor feature to the line
point1_g = g_i.point(5, 4, 7)
point2_g = g_i.point(6, 9, 10)
line_g, anchor_g = g_i.n2nanchor(point1_g, point2_g)

print(line_g, anchor_g)

# Example 3
line_g, anchor_g = g_i.n2nanchor((1, 4, 0), (6, 5, 8))[-2:]
print(line_g, anchor_g)
```

---

```python
# Alternative 3
# Creates lines between three or more points and adds node-to-node anchor features to them

# Creates two points, and then two lines with anchor features. Then assigns all line objects to the variable lines_g and all anchor objects to anchors_g
point1_g = g_i.point(3, 4, 6)
point2_g = g_i.point(7, 4, 12)
res = g_i.n2nanchor(point1_g, (5.1, 6.4, 7.2), point2_g)
lines_g = [item for item in res if item._plx_type == 'Line']
anchors_g = [item for item in res if item._plx_type == 'NodeToNodeAnchor']

print(lines_g, anchors_g)
```

---

```python
# Alternative 4
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by providing the angles concerning 
# the XZ- and the XY-plane and a length or a vector describing the direction and a length and add line prescribed displacement features to them

# Example 1
# Creates multiple objects; last two are Line and NodeToNodeAnchor objects respectively
line_g, anchor_g = g_i.n2nanchor((1, 2, 0), "relative", (3, 4, 8))[-2:]

print(line_g, anchor_g)

# Example 2
# Creates a point and then in one function creates two lines (using existing point), and assigns anchor features to them
point_g = g_i.point(5, 4, 7)
res = g_i.n2nanchor(point_g, "relative", (3, 4, 8), (-5, -9, 10), 
                    "angles", 0, 30, 16)

# Then assigns all line objects to the variable lines_g and all anchor objects to anchors_g
lines_g = [item for item in res if item._plx_type == 'Line']
anchors_g = [item for item in res if item._plx_type == 'NodeToNodeAnchor']
print(lines_g, anchors_g)

# Example 3
res = g_i.n2nanchor((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
anchors_g = [item for item in res if item._plx_type == 'NodeToNodeAnchor']

print(lines_g, anchors_g)

# Example 4
# Creates multiple objects, assigns anchor features to those lines, and snaps them to the volume
point_g = g_i.point(1, 1, 1)
volume_g = g_i.cuboid(5)[0]
line_g, anchor_g = g_i.n2nanchor(point_g , "angles", 90, 0, volume_g)[-2:]

print(line_g, anchor_g)
```

---

```python
# Alternative 5
# Adds node-to-node anchor features to one or more existing lines in the geometry and directly set their properties

# Example 1
# Creates multiple objects, the last one is the Line object and assigns anchor feature to it, setting some properties
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
anchormaterial_i = g_i.anchormat()
anchor_g = g_i.n2nanchor(line_g, "Material", anchormaterial_i)

print(anchor_g)

# Example 2
# Creates multiple objects, the last one are the Line objects and assigns anchor features to them. Then creates an anchor material
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
anchormaterial_i = g_i.anchormat()

# Using one function assigns anchor features to two lines and material to anchor feature
anchors_g = g_i.n2nanchor((line1_g, line2_g), "Material", anchormaterial_i)

print(anchors_g)
```

---

```python
# Alternative 6
# Creates a line between two points, add a node-to-node anchor feature to it and directly set its properties

point_g = g_i.point(3, 4, 6)
anchormaterial_i = g_i.anchormat()

line_g, anchor_g = g_i.n2nanchor(point_g, (5, 6, 7), 
                                 "Material", anchormaterial_i)[-2:]
print(line_g, anchor_g)
```

---

```python
# Alternative 7
# Creates lines between three or more points, add node-to-node anchor features to them and directly set their properties

# Creates two points and an anchor material. Using one function assigns anchor features to them, and material to anchor feature
point1_g = g_i.point(5, 4, 7)
point2_g = g_i.point(6, 9, 10)
anchormaterial_i = g_i.anchormat()
res = g_i.n2nanchor(point1_g, (5.1, 6.4, 7.2), point2_g, "Material", anchormaterial_i)

# Then assigns all line objects to the variable lines_g and all anchor objects to anchors_g
lines_g = [item for item in res if item._plx_type == 'Line']
anchors_g = [item for item in res if item._plx_type == 'NodeToNodeAnchor']

print(lines_g, anchors_g)
```

---

```python
# Alternative 8
# Creates one or more lines giving absolute coordinates or relative coordinates, by providing the angles concerning the XY- and
# the XZ-plane and a length or a vector describing the direction and a length, add node-to-node anchor features to them and directly set their properties

# Creates multiple objects, the last two are the Line and NodeToNodeAnchor objects
anchormaterial_i = g_i.anchormat()
line_g, anchor_g = g_i.n2nanchor((1, 2, 0), "relative", (3, 4, 8), 
                                 "Material", anchormaterial_i)[-2:]
print(line_g, anchor_g)

# Obtain Materials assigned for all node to node anchors in a list and display them
anchors_materials_assigned = [material.Name.value for material in g_i.NodeToNodeAnchors.Material.value if material]
print(f'Node-to-node anchors materials assigned: {anchors_materials_assigned}')

# Obtain ApplyStrengthReduction property value assigned for all node to node anchors in a list and display them
anchors_strength_reduction = g_i.NodeToNodeAnchors.ApplyStrengthReduction.value
print(f'Node-to-node anchors strength reduction property: {anchors_strength_reduction}')
```

# Python wrapper commands [NURBSCURVE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## nurbscurve
 Creates a nurbs curve.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates nurbs curve in a specified location from the specified points

point_g = g_i.point(-1, -2, -3)
nurbscurve_g = g_i.nurbscurve(point_g, 1, 2, 3, 0, 0, 0, 4, 4, 4)

print(g_i.echo(nurbscurve_g))
```

# Python wrapper commands [NURBSSURFACE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## nurbssurface
Creates a nurbs surface.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates nurbs surface in a specified location from the specified points. It detects a best-fitting plane so it can be used to arbitrarily oriented surfaces

nurbssurface_g = g_i.nurbssurface((0, 0, 0), (50, 50, 0), 10, 10, (0, 0, 0), (5, 2, 0), (5, 5, 0), (2, 5, 0), (2, 2, 2), (4, 5, 6), (7, 8, 9))

print(g_i.echo(nurbssurface_g))
```

---

```python
# Alternative 2
# Creates nurbs surface in a specified location from the specified points. It detects a best-fitting plane so it can be used to arbitrarily oriented surfaces

nurbssurface_g = g_i.nurbssurface((0, 0, 0), (50, 50, 0), 10, 10, 1, 2, "c1", (0, 0, 0), (5, 0, 0), (5, 5, 0), (0, 5, 0), (2, 2, 2))

print(g_i.echo(nurbssurface_g))
```

# Python wrapper commands [OBSERVERS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## observers
 Displays internal information about observers connected to an object, for debugging purposes

---

```python
s_i.new()
```

---

```python
# Alternative 1
#  Displays internal information about observers connected to an object, for debugging purposes

volume_g = g_i.cuboid(5)[0]

print(volume_g.observers())
```

# Python wrapper commands [PHASE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## phase
Creates a new phase.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a cuboid and changes the mode and creates a phase. Creates a phase that starts from InitialPhase. Displays phase's address in the memory
g_i.cuboid(5)
g_i.gotostages()
phase0_s = g_i.Phases[0]
phase1_s = g_i.phase(phase0_s)

print(phase1_s)

# Obtain identification values for each phase in a list and display them
phase_ids = g_i.Phases.Identification.value

print(f'Phase Identification values: {phase_ids}')
```

# Python wrapper commands [PLATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## plate
Adds plate features to structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds plate features to one or more existing structural surfaces in the geometry

# Example 1
# Creates a surface and assigns a plate feature to it. Displays plate's address in the memory
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
plate_g = g_i.plate(polygon_g)

print(plate_g)

# Example 2
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
plates_g = g_i.plate(polygon1_g, polygon2_g)

print(plates_g)

# Example 3
polygon1_g = g_i.surface((3, 2, 1), (6, 9, 11), (12, 11, 14))
polygon2_g = g_i.surface((0, 1, 0), (3, 7, 3), (9, 15, 12), (10, 8, 19))
plates_g = g_i.plate((polygon1_g, polygon2_g))

print(plates_g)

# Example 4
# Creates two polygons and groups them. Then, assigns plate feature to all objects in the group
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
group_g  = g_i.group(polygon1_g, polygon2_g)
plates_g = g_i.plate(group_g)

print(plates_g)
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points and add a plate feature to it

# Creates two points, and the creates multiple objects, last two are Surface and Plate objects respectively
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
surface_g, plate_g = g_i.plate(point1_g, point2_g, (1, 0, 5))[-2:]

print(surface_g, plate_g)
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and add a plate feature to it

# Creates multiple objects; the first one is the Polycurve object ([0]) and closes the polycurve
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()

# Assigns plate feature to the polygon. Displays surface's and plate's addresses in the memory
surface_g, plate_g = g_i.plate(polycurve_g)
print(surface_g, plate_g)
```

---

```python
# Alternative 4
# Adds plate features to one or more existing structural surfaces in the geometry and directly set their properties

# Example 1
# Creates a polygon and a plate material. Then, using one function, assigns plate feature to the polygon and material to the plate
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
platematerial_i = g_i.platemat()
plate_g = g_i.plate(polygon_g, "Material", platematerial_i)

print(plate_g)

# Example 2
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
platematerial_i = g_i.platemat()

plates_g = g_i.plate((polygon1_g, polygon2_g), "Material", platematerial_i)
print(plates_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points, add a plate feature to it and directly set its properties

# Creates two points a plate material. Then, in one function assigns plate feature to the polygon (created by points) and material to the plate
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
platematerial_i = g_i.platemat()

surface_g, plate_g = g_i.plate(point1_g, point2_g, (1, 0, 5), "Material", platematerial_i)
print(surface_g, plate_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and add a plate feature to it and directly set its properties

# Creates multiple objects, the first one is the Polycurve object ([0]) and closes the polycurve
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()

# Creates a plate material. In one function, assigns plate feature to the polygon (created by polycurve) and material to the plate
platematerial_i = g_i.platemat()
surface_g, plate_g = g_i.plate(polycurve_g, "Material", platematerial_i)

print(surface_g, plate_g)

# Obtain Materials assigned for all plates in a list and display them
plates_materials_assigned = [material.Name.value for material in g_i.Plates.Material.value if material]
print(f'Plates materials assigned: {plates_materials_assigned}')

# Obtain ApplyStrengthReduction property value assigned for all plates in a list and display them
plates_strength_reduction = g_i.Plates.ApplyStrengthReduction.value
print(f'Plates strength reduction property: {plates_strength_reduction}')
```

# Python wrapper commands [PLATEMAT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## platemat
Creates a plate material set.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a plate material set with no specified properties. It is not possible to calculate with this material before editing it to make its properties valid

g_i.platemat()
```

---

```python
# Alternative 2
# Creates a plate material set with specified properties

g_i.platemat("Identification", "BasementFloor", "MaterialType", "Elastic", "Gamma", 50, "E1", 30000000, "D3d", 0.3)
```

# Python wrapper commands [POINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## point
Creates a point.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a point with specified coordinates

point_g = g_i.point(5, 6, 7)
print(point_g)
```

---

```python
# Alternative 2
# Creates two or more points with specified coordinates

points_g = g_i.point((5, 6, 7), (8, 9, 10))
print(points_g)

# Obtain x coordinate value assigned for all points in a list and display them
points_x_value = g_i.Points.x.value
print(f'Points x coordinate value: {points_x_value}')
```

# Python wrapper commands [POINTDISPL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## pointdispl
Adds point prescribed displacement features to points.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds point prescribed displacement features to one or more existing points in the geometry

# Example 1
# Creates a point and assigns displacement feature to it. Displays line displacement's address in the memory
point_g = g_i.point(3, 4, 9)
pointdisplacement_g = g_i.pointdispl(point_g)

print(pointdisplacement_g)

# Example 2
# Creates two points and assigns point displacement feature to them
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
pointdisplacements_g = g_i.pointdispl(point1_g, point2_g)

print(pointdisplacements_g)

# Example 3
point1_g, point2_g = g_i.point((5, 4, 7), (6, 9, 10))
pointdisplacements_g = g_i.pointdispl((point2_g, point1_g))

print(pointdisplacements_g)

# Example 4
# Creates a few points and groups them. Assigns displacement feature to all object in the group
point1_g, point2_g, point3_g = g_i.point((3, 4, 9), (5, 2, 10), (7, 3, 6))
group_g = g_i.group(point1_g, point2_g, point3_g)
pointdisplacements_g = g_i.pointdispl(group_g)

print(pointdisplacements_g)
```

---

```python
# Alternative 2
# Creates a new point and add a point prescribed displacement feature to it

point_g, pointdisplacement_g = g_i.pointdispl(5, 6, 7)
print(point_g, pointdisplacement_g)
```

---

```python
# Alternative 3
# Creates several new points and add point prescribed displacement features to them

# Creates two point displacement features and assigns all point type objects to points_g variable and all displacement features to pointdisplacements_g
res = g_i.pointdispl((5, 6, 7), (8, 9, 10))
points_g = [item for item in res if item._plx_type == 'Point']
pointdisplacements_g = [item for item in res if item._plx_type == 'PointDisplacement']

print(points_g, pointdisplacements_g)
```

---

```python
# Alternative 4
# Adds point prescribed displacement features to one or more existing points in the geometry and directly set their properties

# Example 1
# Creates a point, then assigns displacement features to it and changes some properties
point_g = g_i.point(3, 4, 9)
pointdisplacement_g = g_i.pointdispl(point_g, "Displacement_x", "Fixed", 
                                     "Displacement_y", "Prescribed", "Displacement_z", "Free")
print(pointdisplacement_g)

# Example 2
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))

pointdisplacements_g = g_i.pointdispl((point1_g, point2_g), "Displacement_x", "Fixed", 
                                      "Displacement_y", "Prescribed", "Displacement_z", "Free")
print(pointdisplacements_g)
```

---

```python
# Alternative 5
# Creates a new point, add a point prescribed displacement feature to it and directly set its properties

# Creates multiple objects; Point and PointDisplacement objects and sets some of the displacement's properties
point_g, pointdisplacement_g = g_i.pointdispl((5, 6, 7), "Displacement_x", "Fixed", 
                                              "Displacement_y", "Prescribed", "Displacement_z", "Free")
print(point_g, pointdisplacement_g)
```

---

```python
# Alternative 6
# Creates several new points, add point prescribed displacement features to them and directly set their properties

# Creates multiple objects, Point and PointDisplacement objects and sets some of the displacement's properties
res = g_i.pointdispl((5, 6, 7), (8, 9, 10), "Displacement_x", "Fixed", 
                     "Displacement_y", "Prescribed", "Displacement_z", "Free")

# Assigns all point type objects to points_g variable and all point displacement object to pointdisplacements_g
points_g = [item for item in res if item._plx_type == 'Point']
pointdisplacements_g = [item for item in res if item._plx_type == 'PointDisplacement']
print(points_g, pointdisplacements_g)

# Obtain uz property value assigned for all point displacements in a list and display them
pointdispls_uz = g_i.PointDisplacements.uz.value
print(f'Point displacements uz property: {pointdispls_uz}')
```

# Python wrapper commands [POINTLOAD]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## pointload
Adds point load features to points.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds point load features to one or more existing points in the geometry

# Example 1
# Creates a point and assigns load feature to it. Displays line load's address in the memory
point_g = g_i.point(3, 4, 9)
pointload_g = g_i.pointload(point_g)

print(pointload_g)

# Example 2
# Creates two points and assigns point load feature to them
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
pointloads_g = g_i.pointload(point1_g, point2_g)

print(pointloads_g)

# Example 3
point1_g, point2_g = g_i.point((5, 4, 7), (6, 9, 10))
pointloads_g = g_i.pointload((point1_g, point2_g))

print(pointloads_g)

# Example 4
# Creates a few points and groups them. Assigns point load feature to all objects in the group
point1_g, point2_g, point3_g = g_i.point((3, 4, 9), (5, 2, 10), (7, 3, 6))
group_g = g_i.group(point1_g, point2_g, point3_g)
pointloads_g = g_i.pointload(group_g)

print(pointloads_g)
```

---

```python
# Alternative 2
# Creates a new point and add a point load feature to it

# Creates multiple objects; Point and PointLoad objects
point_g, pointload_g = g_i.pointload(5, 6, 7)

print(point_g, pointload_g)
```

---

```python
# Alternative 3
# Creates several new points and add point load features to them

# Creates two point load features and assigns all point type objects to points_g variable and all load features to pointloads_g
res = g_i.pointload((5, 6, 7), (8, 9, 10))
points_g = [item for item in res if item._plx_type == 'Point']
pointloads_g = [item for item in res if item._plx_type == 'PointLoad']

print(pointloads_g)
```

---

```python
# Alternative 4
# Adds point load features to one or more existing points in the geometry and directly set their properties

# Example 1
# Creates a point, then assigns load features to it and changes some properties
point_g = g_i.point(3, 7, 10)
pointload_g = g_i.pointload(point_g, "Fx", 3, "Fy", 7, "Fz", 2)

print(pointload_g)

# Example 2
point1_g = g_i.point(9, 6, 10)
point2_g = g_i.point(4, 1, 6)
pointloads_g = g_i.pointload((point1_g, point2_g), "Fx", 3, "Fy", 7, "Fz", 2)

print(pointloads_g)
```

---

```python
# Alternative 5
# Creates a new point, add a point load feature to it and directly set its properties

# Creates multiple objects; Point and PointLoad objects and sets some of the load's properties
point_g, pointload_g = g_i.pointload((5, 6, 7), "Fx", 3, "Fy", 7, "Fz", 2)

print(point_g, pointload_g)
```

---

```python
# Alternative 6
# Creates several new points, add point load features to them and directly set their properties

# Creates multiple objects; Point and PointLoad objects and sets some of the load's properties
res = g_i.pointload((5, 6, 7), (8, 9, 10), "Fx", 3, "Fy", 7, "Fz", 2)
points_g = [item for item in res if item._plx_type == 'Point']
pointloads_g = [item for item in res if item._plx_type == 'PointLoad']

print(points_g, pointloads_g)

# Obtain Force property value assigned for all point loads in a list and display them
pointloads_force = g_i.PointLoads.F.value
print(f'Point Loads F property: {pointloads_force}')
```

# Python wrapper commands [POINTMOVEMENT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## pointmovement
Adds point prescribed displacement features to points.

---

```python
s_i.new()
```

---

```python
# Alternative 1
#  Creates a point movement on a point or point load objects

# Example 1
# Creates a point and assigns movement feature to it. Displays point movement's address in the memory
point_g = g_i.point(3, 4, 9)
pointmovement_g = g_i.pointmovement(point_g)[-1]

print(pointmovement_g)

# Example 2
# Creates two points and assigns point movement feature to them
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
pointmovements_g = g_i.pointmovement(point1_g, point2_g)[-2:]

print(pointmovements_g)

# Example 3
point1_g, point2_g = g_i.point((5, 4, 7), (6, 9, 10))
pointmovements_g = g_i.pointmovement((point2_g, point1_g))[-2:]

print(pointmovements_g)

# Example 4
# Creates a few points and groups them. Assigns movement feature to all object in the group
point1_g, point2_g, point3_g = g_i.point((3, 4, 9), (5, 2, 10), (7, 3, 6))
group_g = g_i.group(point1_g, point2_g, point3_g)
pointmovements_g = g_i.pointmovement(group_g)[-3:]

print(pointmovements_g)
```

---

```python
# Alternative 2
# Creates a point movement with specified coordinates

pointmovement_g = g_i.pointmovement(5, 6, 7)[-1]

# Displays point movement's address in the memory
print(pointmovement_g)
```

---

```python
# Alternative 3
# Creates two or more point movement objects with specified coordinates

# Creates two point movements features and assigns all point type objects to points_g variable and all movements features to pointmovements_g
res = g_i.pointmovement((5, 6, 7), (8, 9, 10))
points_g = [item for item in res if item._plx_type == 'Point']
pointmovements_g = res[-2:]

print(points_g, pointmovements_g)
```

# Python wrapper commands [polycurvechain]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## polycurvechain 
Creates a polycurve chain inside the tunnel designer.

---

```python
s_i.new()
```

---

```python
# Alternative 1

s_i.new()
# Creates a circular tunnel cross-section and creates a polycurvechain for the second slice surface
tunnel_g = g_i.tunnel(0, 0, 0)
tunnel_g.CrossSection.setproperties("ShapeType", "Circular", "WholeHalfMode", "Whole")

g_i.polycurvechain(tunnel_g.SliceSurfaces[1])
```

# Python wrapper commands [POSINTERFACE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## posinterface
Adds positive interface features to structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds positive interface features to one or more existing structural surfaces in the geometry

# Example 1
# Creates a polygon and then assigns positive interface feature to it. Displays feature's address in the memory
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
interface_g = g_i.posinterface(polygon_g)

print(interface_g)

# Example 2
# Creates two polygons and then assigns positive interface features to them. Displays their address in memory
polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
interfaces_g = g_i.posinterface(polygon1_g, polygon2_g)

print(interfaces_g)

# Example 3
polygon1_g = g_i.surface((12, 15, 0), (3, 6, 3), (9, 15, 12), (8, 9, 9))
polygon2_g = g_i.surface((3, 7, 8), (7, 8, 3), (9, 1, 11), (10, 14, 15))
interfaces_g = g_i.posinterface((polygon1_g, polygon2_g))

print(interfaces_g)

# Example 4
# Creates two polygons and groups them. Then, assigns a positive interface feature to objects in the group
polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
group_g = g_i.group(polygon1_g, polygon2_g)
interfaces_g = g_i.posinterface(group_g)

print(interfaces_g)
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points and add a positive interface feature to it

# Creates two points and then a surface with positive interface feature assigned to it
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(5, 2, 10)
surface_g, interface_g = g_i.posinterface(point1_g, point2_g, (1, 0, 5))

print(surface_g, interface_g)
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and add a positive interface feature to it

# Creates multiple objects, the first one is the Polycurve object ([0]) and closes the polycurve. Assigns a feature to a resulting polygon
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()
surface_g, interface_g = g_i.posinterface(polycurve_g)

print(surface_g, interface_g)
```

---

```python
# Alternative 4
# Adds positive interface features to one or more existing structural surfaces in the geometry and directly set their properties

# Example 1
# Creates a surface and a soil material. Then in one function, assigns pos interface feature to the polygon and material to the feature
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
soilmaterial_i = g_i.soilmat()
interface_g = g_i.posinterface(polygon_g, "MaterialMode", "Custom", 
                               "Material", soilmaterial_i)
print(interface_g)

# Example 2
polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
soilmaterial_i = g_i.soilmat()
interfaces_g = g_i.posinterface((polygon1_g, polygon2_g), "MaterialMode", "Custom", 
                                "Material", soilmaterial_i)
print(interfaces_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points, add a positive interface feature to it and directly set its properties

# Creates two points and a soil material. Then in one function, assigns pos interface feature to a newly created polygon and material to the feature
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(5, 2, 10)
soilmaterial_i = g_i.soilmat()
surface_g, interface_g = g_i.posinterface(point1_g, point2_g, (1, 0, 5), "MaterialMode", 
                                          "Custom", "Material", soilmaterial_i)
print(surface_g, interface_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and add a positive interface feature to it and directly set its properties

# Creates multiple objects; the first one is the Polycurve object([0]), closes the polycurve and creates soil material
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()
soilmaterial_i = g_i.soilmat()

# Creates multiple objects; Surface and Interface objects respectively, then assigns neg interface to the polygon and material to pos interface
surface_g, interface_g = g_i.posinterface(polycurve_g, "MaterialMode", "Custom", 
                                          "Material", soilmaterial_i)
print(surface_g, interface_g)

# Obtain VirtualThicknessFactor property value assigned for all interfaces in a list and display them
interfaces_thicknessfactor = g_i.Interfaces.VirtualThicknessFactor.value
print(f'Interfaces thickness factors: {interfaces_thicknessfactor}')
```

# Python wrapper commands [PREDICT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## predict
Predicts whether a command will succeed or fail.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
print(g_i.predict("echo"))

# Example 2
print(g_i.predict("point (1 2 3)"))

# Example 3
print(g_i.predict("rename MyNotExistingLine 'line_342'"))
```

# Python wrapper commands [PREVIEW]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## preview
View the mesh in a specified phase.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a soil contour, borehole, soil layer, and assigns material to the layer
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material_i = g_i.soilmat()
material_i.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[-1].Material = material_i

# Changes the mode and creates a mesh, then in staged construction mode adds a phase and previews calculation results 
g_i.gotomesh()
g_i.mesh(0.2)

g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[-1])

g_i.preview(phase1_s)
```

# Python wrapper commands [PROJECTPOINTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## projectpoints
Projects the points of a non-flat surface onto its plane.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a polygon composing of 5 points and projects the points onto its plane
polygon_g = g_i.surface((0, 0, 0), (3, 4, 3), (6, 7, 9), (9, 11, 12), (15, 17, 19))
polygon_g.projectpoints()
```

# Python wrapper commands [RAISE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## raise
Generates an error in order to test the error catching functionality.

---

```python
s_i.new()
```

---

```python
# Alternative 1
try:
    g_i.raise_()
except:
    print("Exception raised!")
```

# Python wrapper commands [RAISEASYNC]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## raiseasync
Generates an error in an asynchronous thread in order to test the error catching functionality.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Generates an error in an asynchronous thread in order to test the error catching functionality
try:
    g_i.raiseasync()
except:
    print("Tried executing, but failed")
```

---

```python
# Alternative 2
# Generates an error in an asynchronous thread in order to test the error catching functionality with a number of milliseconds to wait before the exception is raised
try:
    g_i.raiseasync(1)
except:
    print("Tried executing, but failed")
```

# Python wrapper commands [RAISETHREADED]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## raisethreaded
Generates an error in a synchronous thread in order to test the error catching functionality.

---

```python
s_i.new()
```

---

```python
# Alternative 1
try:
    g_i.raisethreaded()
except:
    print("Exception raised!")
```

# Python wrapper commands [REDO]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## redo
Redo actions to which undo was applied.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole, then reverses the action and then does the last action (undo)
g_i.borehole(1,5)
g_i.undo()
g_i.redo()
```

---

```python
# Alternative 2

# Creates a borehole and two soil layers. Sets a soil layer's height, then reverses the action and then does the last action
borehole_g = g_i.borehole(0,0)
g_i.soillayer(3)
g_i.soillayer(5)
soillayer_g = g_i.Soillayers[-2]
g_i.soillayerheight(borehole_g, soillayer_g, 1)
g_i.undo(4)
g_i.redo(4)
```

# Python wrapper commands [REFINE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## refine
Requests a finer mesh for a meshable object.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates multiple objects, the first one is the Volume object ([0])
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]
g_i.gotomesh()

g_i.refine(volume_g)
```

# Python wrapper commands [REGENERATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## regenerate
Regenerates the staged construction properties of objects in particular phases. Regeneration consists of two steps: determining which properties in which phases should be reset, followed by finding out what the new values should be and applying those values.

---

```python
s_i.new()
```

---

```python
# Alternative 1
#  Regenerates the staged construction properties of an object in a particular phase

# Creates Volume and Soil objects; the first one is the Volume object ([0]), then changes the mode, adds a phase and regenerates a volume in a specified phase
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]

g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
volume_s = g_i.Volumes[-1]

g_i.regenerate(volume_s, phase1_s)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Regenerates the phase settings in one or more staged construction phases

point1_g = g_i.point(4, 6, 0)
point2_g = g_i.point(4, 10, 0)
point3_g = g_i.point(8, 10, 0)
geogrid1_g = g_i.geogrid(point1_g, point2_g, point3_g)

point4_g = g_i.point(3, 3, 0)
point5_g = g_i.point(3, 4, 6)
point6_g = g_i.point(3, 13, 6)
point7_g = g_i.point(3, 13, 0)
geogrid2_g = g_i.geogrid(point4_g, point5_g, point6_g, point7_g)

g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])
geogrid1_s = g_i.Geogrids[0]
geogrid2_s = g_i.Geogrids[1]

g_i.regenerate(geogrid1_s, geogrid2_s, phase1_s)
```

# Python wrapper commands [REINFORCEMENT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## reinforcement
Adds reinforcement features to one or more segments in a tunnel.

---

```python
s_i.new()
```

---

```python
# Alternative 1
#  Adds reinforcement elements (reinforcements) to a polycurve chain

# Creates a tunnel and adds segments to it. Then, creates a reinforcement with polycurve chain and deletes the reinforcement feature
tunnel_g = g_i.tunnel((-44, 29, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.add("arc", 0, 180, 3, "arc", 0, 180, 3)
polycurvechain_g, reinforcements_g = g_i.reinforcement(tunnel_g.SliceSurfaces[0])
g_i.delete(reinforcements_g)

# Adds reinforcement feature to a polycurve chain
g_i.reinforcement(polycurvechain_g)
```

---

```python
# Alternative 2
# Adds reinforcements to one or more segments in a tunnel

# Creates a tunnel and adds segments to it. Then, creates segments
tunnel_g = g_i.tunnel(0, 0, 0)
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4

# Adds reinforcements to a segment
g_i.reinforcement(tunnel_g.SliceSurfaces[0])
```

---

```python
# Alternative 3
# Adds reinforcements to a polycurve chain and changes the specified properties

# Creates a tunnel and adds segments to it. Then, adds a reinforcement feature to segments and changes its name
tunnel_g = g_i.tunnel((-44, 29, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.add("arc", 0, 180, 3, "arc", 0, 180, 3)
polycurvechain_g, reinforcements_g = g_i.reinforcement(tunnel_g.SliceSurfaces[0])
g_i.delete(reinforcements_g)
g_i.reinforcement(polycurvechain_g, "Name", "New_reinforcement_name")
```

---

```python
# Alternative 4
# Adds reinforcements to one or more segments in a tunnel and changes the specified properties

# Creates a tunnel and adds segments to it. Then, adds a reinforcement feature to segments and changes its comments
tunnel_g = g_i.tunnel((0, 0, 0))
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4
g_i.reinforcement(tunnel_g.SliceSurfaces[0], "Comments", "anchor")
```

# Python wrapper commands [REMOVEINTERMEDIATESTEPS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## removeintermediatesteps
Removes saved intermediate calculation steps.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Removes saved intermediate calculation steps in one or more phases. Only the last calculation step will not be removed

# Creates a soil contour, borehole, soil layer and soil material with some properties. Then adds a line with a line load
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(5)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))

# Changes the mode and generates the mesh. Adds two phases and sets some properties. Next, calculates the project, and removes intermediate steps
g_i.gotomesh()
g_i.mesh(0.1)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
phase1_s.Deform.TimeIntervalSeconds = 0.5
phase1_s.MaxStepsStored = 5
g_i.LineLoads[-1].Active[phase1_s] = True
g_i.calculate()
print(g_i.removeintermediatesteps())
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Removes saved intermediate calculation steps in all phases. Only the last calculation step of every phase will not be removed

# Creates a soil contour, borehole, soil layer and soil material with some properties. Then adds a line with a line load
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[-1].Material = material
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0), "qz_start", -100)

# Changes the mode and generates the mesh. Adds a few phases and sets some properties for each phase
g_i.gotomesh()
g_i.mesh(0.2)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phases_s = [g_i.phase(g_i.Phases[i]) for i in range(5)]

for phase in phases_s:
    phase.DeformCalcType = phase.DeformCalcType.dynamic
    phase.Deform.TimeIntervalSeconds = 0.5
    phase.MaxStepsStored = 5
    g_i.LineLoads[-1].Active[phase] = True

# Next, calculates the project and removes intermediate steps for a few phases at once
g_i.calculate()

print(g_i.removeintermediatesteps(phase0_s, phases_s[0], phases_s[4]))
```

# Python wrapper commands [REMOVETUNNELPHASEROUTINE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## removetunnelphaseroutine
Removes a phase routine from a tunnel sequence.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a tunnel and adds sub-curves and segments. Then, removes a phase routine
tunnel_g = g_i.tunnel(6, 2, 3)
tunnel_g.CrossSection.addsubcurve("Line", 2, 3, 180, 1)
tunnel_g.PhasesDefinition.addtunnelphaseroutine()

tunnel_g.PhasesDefinition.removetunnelphaseroutine(1)
```

# Python wrapper commands [REMOVETUNNELPHASESTEP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## removetunnelphasestep
Removes a phase step from a tunnel sequence.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a tunnel and adds sub-curves and segments. Then, removes a phase step
tunnel_g = g_i.tunnel(6, 2, 3)
tunnel_g.CrossSection.addsubcurve("Line", 2, 3, 180, 1)
tunnel_g.PhasesDefinition.addtunnelphasestep()

tunnel_g.PhasesDefinition.removetunnelphasestep(1)
```

# Python wrapper commands [RENAME]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## rename
Renames an object.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates Volume and Soil objects; the first one is the Volume object and renames it to Wall
volume_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]
volume_g.rename("Wall")
```

# Python wrapper commands [REPORTMEM]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## reportmem
Reports memory usage.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.reportmem()
```

# Python wrapper commands [RESET]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## reset
Clears the contents of a polycurve with the option to add one or more new segments.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Clears the contents of a polycurve

# Creates multiple objects, the first one is the Polycurve object and then resets all polycurve settings (removes segments too)
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                             "line", 0, 2, "arc", 45, 90, 3)[0]

print(polycurve_g.reset())
```

---

```python
# Alternative 2
# Clears the contents of a polycurve and add one or more new segments

# Creates multiple objects; the first one is the Polycurve object ([0]), then resets a polycurve and displays segments' addresses in the memory
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]

segments_g = polycurve_g.reset("arc", 0, 45, 1, "line", 90, 2)
print(segments_g)
```

# Python wrapper commands [RESETLOCAL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## resetlocal
Request a reset of the fineness of a mesh.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates Volume and Soil objects; the first one is the Volume object ([0]). Then, resets the fineness of a mesh
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]
g_i.gotomesh()
g_i.refine(volume_g)
g_i.resetlocal(volume_g)
```

# Python wrapper commands [RETRIEVESUGGESTEDPARAMETERS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## retrievesuggestedparameters
Retrieves suggested parameters for a phase.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a soil contour, borehole, soil layer and soil material with some properties. Then adds a line with a line load
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(5)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))[-1]

# Changes the mode and generates the mesh. Adds a few phases and sets some properties for each phase
g_i.gotomesh()
g_i.mesh(0.1)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
phase1_s.Deform.TimeIntervalSeconds = 0.5
phase1_s.MaxStepsStored = 5
g_i.LineLoads[-1].Active[phase1_s] = True

# Calculates one phase and retrieves parameters for a different phase
g_i.calculate(phase0_s)
g_i.retrievesuggestedparameters(phase1_s)
```

# Python wrapper commands [REVOLVE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## revolve
Creates a surface or volume by revolution of a line or surface around an axis.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates multiple objects; the first one is the Polycurve object. Revolves the polycurve 180 degrees around axis defined by two points
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
g_i.revolve(polycurve_g, (0, 0, 0), (0, 0, 1), 180)

# Example 2
# Creates a surface and revolves the surface 180 degrees around the axis defined by two points
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
g_i.revolve(polygon_g, (0, 0, 1), (0, 0, 10), 180)
```

# Python wrapper commands [RIGIDBODY]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## rigidbody
Creates a rigid body.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates a polygon and creates a rigid body from that. Displays rigid body's address in the memory
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
rigidbody_g = g_i.rigidbody(polygon_g)
print(rigidbody_g)

# Example 2
polygon1_g = g_i.surface((12, 15, 0), (3, 6, 3), (9, 15, 12), (8, 9, 9))
polygon2_g = g_i.surface((3, 7, 8), (7, 8, 3), (9, 1, 11), (10, 14, 15))
rigidbodies_g = g_i.rigidbody(polygon1_g, polygon2_g)
print(rigidbodies_g)

# Obtain Zref property value assigned for all rigid bodies in a list and display them
rigidbodies_zref = g_i.RigidBodies.Zref.value
print(f'Rigid bodies Zref property: {rigidbodies_zref}')
```

# Python wrapper commands [ROTATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## rotate
Rotates objects around a point.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates multiple objects; the last ones are the Line objects ([-1]). Then rotates those lines
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
g_i.rotate((line1_g, line2_g), (3, 1, 2), 45, 30, 5)
points_g = g_i.Points

print(g_i.tabulate(points_g))
```

---

```python
# Alternative 1

# Creates multiple objects; the first one is the Volume object ([0]). Then rotates those lines
volume_g = g_i.cuboid(5)[0]
g_i.rotate(volume_g, (4, 3, 1), 45, 30, 5)

print(g_i.echo(volume_g))
```

# Python wrapper commands [ROTATELINE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## rotateline
Rotates objects around a line.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Rotates one or more objects around a specified line

# Creates multiple objects; the last one is the Line object. Creates two more lines
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))

# Assigns all objects of type line to a variable lines_g. Then, rotates lines 45 degrees around axis given by two points
lines_g = [item for item in res if item._plx_type=='Line']

g_i.rotateline((line_g, lines_g[-2], lines_g[-1]), (4, 5, 6), (7, 8, 9), 45)

points_g = g_i.Points

print(g_i.tabulate(points_g))
```

---

```python
# Alternative 2
# Rotates one or more objects around a specified line

# Creates two points and then multiple objects; the last one is the Line object ([-1])
point1_g, point2_g = g_i.point((3, 4, 9), (1, 1, 1))
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
 
g_i.rotateline((point1_g, point2_g), line_g, 45)

points_g = g_i.Points

print(g_i.tabulate(points_g))
```

# Python wrapper commands [SAVE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## save
Saves the project.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer and saves the project as embankment.p3d
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
g_i.save("C:\PLAXIS3D\embankment.p3d")
```

---

```python
# Alternative 2
# Saves the project in a previously determined location. The project must have been previously saved. 

# Creates a borehole and a soil layer and saves the project as embankment.p3d
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
g_i.save()
```

# Python wrapper commands [SAVEOBJECTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## saveobjects 
Saves objects in the geometry to a file.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Example 1
# Creates a borehole and a soil layer, next multiple objects; the last one is the line object ([-1])
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
line_g = g_i.line((0, 0, 0), (1, 1, 1))[-1]

# Then creates a surface and a cuboid. Saves the objects under the following path as a .step file
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
g_i.cuboid(5)
g_i.saveobjects("step", "C:\PLAXIS3D\Objects")

# Example 2
# Creates a borehole, a soil layer and next multiple objects, the last one is the line object ([-1]), surface and a cuboid.
# Saves objects as a .brep file
g_i.clear()
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
line_g = g_i.line((0, 0, 0), (1, 1, 1))[-1]
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
g_i.cuboid(5)
g_i.saveobjects("brep", "C:\PLAXIS3D\Objects")

# Example 3
# Saves abjects as a .dxf file
g_i.clear()
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
line_g = g_i.line((0, 0, 0), (1, 1, 1))[-1]
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
g_i.cuboid(5)

g_i.saveobjects("dxf", "C:\PLAXIS3D\Objects")
```

# Python wrapper commands [SELECTMESHPOINTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## selectmeshpoints
Allows you to select points-of-interest in the mesh.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a soil contour, borehole, soil layer and soil material with some properties
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[-1].Material = material

# Then changes the mode, generates a mesh and selects mesh points
g_i.gotomesh()
g_i.mesh()
g_i.selectmeshpoints()
```

# Python wrapper commands [SET]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## set
Changes the properties of an object in the project.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Changes one or more properties of one or more objects. The properties must be of the same type

# Example 1
# Creates multiple objects; the last ones are the Line objects. Creates beam material and assigns beam feature to two lines, setting some materials
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
beammaterial_i = g_i.beammat()
beam1_g = g_i.beam(line1_g)
beam2_g = g_i.beam(line2_g, "Material", beammaterial_i)

# Then sets the same properties to beam_2 as beam_1 has
beam1_g.set(beam2_g)

# Example 2
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
point1_g.set(point2_g)
```

---

```python
# Alternative 2

# Creates a point and changes its x coordinate to 5.2
point_g = g_i.point(8, 4, 9)
point_g.x.set(5.2)
```

---

```python
# Alternative 3

# Creates two points and sets x coordinate of point_2 to the value of x coordinate of point_1
point1_g = g_i.point(8, 4, 9)
point2_g = g_i.point(4, 7, 6)
point1_g.x.set(point2_g.x)
```

---

```python
# Alternative 4

# Creates beam material and assigns a new colour to it
beammaterial_i = g_i.beammat()
beammaterial_i.Colour.set(646464)
```

---

```python
# Alternative 5

# Example 1
# Creates beam material and assigns a new colour to it
beammaterial_i = g_i.beammat()
colours = g_i.Colours
beammaterial_i.Colour.set(colours.Blue)

# Example 2
# Creates multiple objects; the last one is the Line object ([-1])
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line_g.AxisFunction.set(1)
```

---

```python
# Alternative 6

# Creates multiple objects; the last ones are the Line objects ([-1]). Then, sets axis function of point_2 the same as axis function of point_1
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]

line1_g.AxisFunction.set(line2_g.AxisFunction)
```

---

```python
# Alternative 7

# Example 1
g_i.Project.Title.set("Excavation")

# Example 2
# Creates multiple objects; the last one is the Line object ([-1])
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]

line_g.AxisFunction.set("Manual")
```

---

```python
s_i.new()
```

---

```python
# Alternative 8

# Creates a plate and a plate material. Then, changes the mode and creates 3 phases. Assigns plate materials to plates in the selected phases
plate_g = g_i.plate((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
platematerial_i = g_i.platemat()
g_i.gotostages()
phases_s = [g_i.phase(g_i.Phases[i]) for i in range(3)]
plate_s = g_i.Plates[-1]
plate_s.Material.set((phases_s[1], phases_s[2]), platematerial_i)
```

---

```python
# Alternative 9

# Adds 3 points, then sets points' coordinates to the specified values
g_i.gotosoil()
point1_g, point2_g, point3_g = g_i.point((3, 4, 9), (1, 1, 1), (0, 0, 0))
point1_g.x.set(2), point2_g.y.set(2), point3_g.z.set(2)
```

---

```python
# Alternative 10

# Example 1
# Creates a load multiplier and adds table values. Then, sets the multiplier value to 345
g_i.clear()
g_i.gotostructures()
loadmultiplier_i = g_i.loadmultiplier()
loadmultiplier_i.Table.add(5, 2)
advancedtablerow = loadmultiplier_i.Table[0]
advancedtablerow.Multiplier.set(345)

# Example 2
# Creates a load multiplier and adds table values. Then sets the table value of indexes [0][1] to 7
displacementmultiplier_i = g_i.displmultiplier()
displacementmultiplier_i.Table.add(6, 4)
displacementmultiplier_i.Table[0][1].set(7)
```

---

```python
# Alternative 11

# Creates multiple objects, the last one is the Plate object ([-1]), then changes the mode and created 3 phases.
g_i.clear()
g_i.plate((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))[-1]
g_i.gotostages()
phases_s = [g_i.phase(g_i.Phases[i]) for i in range(3)]

# Assigns all properties of the phase with index 1 to the phase with index 2
phases_s[1].set(phases_s[2])
```

# Python wrapper commands [SETCOLOUR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setcolour
Changes the colour of a material.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Changes the colour of a material

beammaterial_i = g_i.beammat()
beammaterial_i.setcolour(20, 200, 90)
```

---

```python
# Alternative 2

# Example 1
beammaterial_i = g_i.beammat()
beammaterial_i.setcolour(646464)

# Example 2
beammaterial_i = g_i.beammat()
colours = g_i.Colours
beammaterial_i.setcolour(colours.Blue)
```

# Python wrapper commands [SETCURRENTPHASE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setcurrentphase
Makes a phase the current phase.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a soil contour, borehole, soil layer and soil material with some properties
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes the mesh and generates a mesh, then creates two phases and sets phase_1s as a current phase
g_i.gotomesh()
g_i.mesh(0.2)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.setcurrentphase(phase1_s)
```

# Python wrapper commands [SETDEFAULTMATERIAL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setdefaultmaterial
 Forces an interface to use the material of the soil it is adjacent to.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Forces the interface of a surface to use the same material as the soil next to which it is located

interface_g = g_i.posinterface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))[-1]

interface_g.setdefaultmaterial()
```

---

```python
# Alternative 2
# Forces the interface of a surface to use the same material as the soil next to which it is located in one or more phases

# Creates an interface and changes the mode. Then, creates some phases and sets default material properties for interface in Phase_1 and Phase_3
interface_g = g_i.neginterface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))[-1]

g_i.gotostages()
interface_s = g_i.Interfaces[0]
phase1_s = g_i.phase(g_i.Phases[0])
phase2_s = g_i.phase(phase1_s)
phase3_s = g_i.phase(phase2_s)

interface_s.setdefaultmaterial(phase1_s, phase3_s)
```

# Python wrapper commands [SETGLOBALWATERLEVEL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setglobalwaterlevel
Changes the global water level.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a plate and changes the mode. Adds a water level. Then, creates a phase and sets a global water level in phase1_s to waterlevel_s
g_i.plate((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))

g_i.gotoflow()
waterlevel_s = g_i.waterlevel((1, 4, 6))

g_i.gotostages()
phase1_s = g_i.phase(g_i.Phases[0])

g_i.setglobalwaterlevel(waterlevel_s, phase1_s)
```

# Python wrapper commands [SETINSERTIONPOINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setinsertionpoint
Sets the insertion point for solids and surfaces without moving the object itself.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates Volume and Soil objects, the first one is the Volume object ([0]) and sets the insertion point
volume_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]
volume_g.setinsertionpoint(1, 2, 3)
```

# Python wrapper commands [SETMATERIAL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setmaterial
Assigns a material to features.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Assigns a material to one or more features

# Example 1
# Creates multiple objects; the last one is the Line object ([-1]). Creates a beam and the beam material. Then sets material to a beam
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
beam_g = g_i.beam(line_g)
beammaterial_i = g_i.beammat()
g_i.setmaterial(beam_g, beammaterial_i)

# Example 2
# Creates multiple objects; the last ones are the Line objects ([-1])
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))

# Assigns all objects with type line to lines_g. Assigns beam features to lines, creates a material and sets material to specified objects
lines_g = [item for item in res if item._plx_type=='Line']
line5_g = g_i.line((4, 4, 4), (8, 9, 10))[-1]
line6_g = g_i.line((6, 5, 5), (10, 11, 12))[-1]
beams_g = g_i.beam(line1_g, line2_g, lines_g[-2], lines_g[-1], line5_g, line6_g)
beammaterial_i = g_i.beammat()
g_i.setmaterial((beams_g[-2], beams_g[-1]), beammaterial_i)

# Example 2
# Creates points, lines, and beams from lines. Then groups beams, creates a material and assigns material to a group
points_g = g_i.point((0, 0, 0), (1, 2, 3), (4, 4, 5), (6, 8, 9))
line1_g = g_i.line(points_g[0], points_g[1])
line2_g = g_i.line(points_g[2], points_g[3])
beams_g = g_i.beam(line1_g, line2_g)
group_g = g_i.group(beams_g[-2], beams_g[-1])
beammaterial_i = g_i.beammat()
g_i.setmaterial(group_g, beammaterial_i)
```

---

```python
# Alternative 2
# Assigns a soil material to a specified soil layer

# Creates a borehole, soil layer and soil materials. Then assigns a soil material to a specific soil layer
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
soillayer_g = g_i.Soillayers[0]
soilmaterial1_g = g_i.soilmat()
soilmaterial2_g = g_i.soilmat()

g_i.setmaterial(soillayer_g, soilmaterial2_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Assigns a material to a feature (target is the feature)

# Example 1
# Creates multiple object;, the last one is the Line object ([-1]). Creates a beam and the material. Then, assigns material to a beam
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
beammaterial_i = g_i.beammat()
beam1_g = g_i.beam(line1_g)

beam1_g.setmaterial(beammaterial_i)
```

---

```python
# Alternative 4
# Assigns a material to a feature in one or more phases

polygon_g = g_i.surface(3, 4, 0, 8, 8, 0 ,11, 3, 0, 5, 0, 0)
geogrid_g = g_i.geogrid(polygon_g)
geogridmat_g = g_i.geogridmat()

g_i.gotostages()
geogrid_s = g_i.Geogrids[0]
phase1_s = g_i.phase(g_i.Phases[0])
phase2_s = g_i.phase(phase1_s)
phase3_s = g_i.phase(phase2_s)

geogrid_s.setmaterial(phase2_s, phase3_s, geogridmat_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Assigns a material to one or more features in one or more phases

polygon_g = g_i.surface(3, 4, 0, 8, 8, 0 ,11, 3, 0, 5, 0, 0)
plate_g = g_i.plate(polygon_g)
platemat_g = g_i.platemat()

g_i.gotostages()
plate_s = g_i.Plates[0]
phase1_s = g_i.phase(g_i.Phases[0])
phase2_s = g_i.phase(phase1_s)
phase3_s = g_i.phase(phase2_s)

g_i.setmaterial(plate_s, phase2_s, phase3_s, platemat_g)
```

# Python wrapper commands [SETPHYSICALCPUCOUNT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setphysicalcpucount
Displays or sets the amount of physical and logical CPUs.

---

```python
s_i.new()
```

---

```python
# Alternative 1

print(g_i.setphysicalcpucount())
```

---

```python
# Alternative 2

print(g_i.setphysicalcpucount(3))
```

# Python wrapper commands [SETPROPERTIES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

# setproperties
Changes properties of objects.

---

```python
s_i.new()
```

---

```python
# ALternative 1

# Example 1
# Creates a surface and sets x coordinate value and its name
polygon_g = g_i.surface((0, 0, 0), (0, 2, 0), (2, 2, 0), (2, 0, 0))
polygon_g.setproperties("x", 4, "Name", "Surface_3")

# Example 2
point_g = g_i.point(3, 4, 9)
point_g.setproperties("x", 5, "y", 1, "z", 0)

# Example 3
# Creates multiple objects; the last one is the Line object ([-1]) and assigns anchor feature to it.
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
anchor_g = g_i.n2nanchor(line_g)

# Changes the mode and adds phases. Sets the option to adjust the prestress force for NodeToNodeAnchor in phase 1 to true. 
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

anchor_s = g_i.NodetoNodeAnchors[-1]
anchor_s.setproperties("Adjustprestress", phase1_s, True)
```

# Python wrapper commands [SETSOILLAYERLEVEL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setsoillayerlevel
Changes the location of a soil layer boundary.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer. Then, changes location of the soil layer boundary
borehole_g = g_i.borehole(1, 4)
g_i.soillayer(3)
g_i.setsoillayerlevel(borehole_g, 0, 6)
```

# Python wrapper commands [SETSOILLAYERPOREPRESSURE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setsoillayerporepressure
Changes the pore pressures in a soil layer.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer. Then, changes pore pressures in a soil layer to -1 at the top and -12 at the bottom
borehole_g = g_i.borehole(1, 4)
g_i.soillayer(3)
soillayer_g = g_i.SoilLayers[-1]

g_i.setsoillayerporepressure(borehole_g, soillayer_g, -1, -12)
```

# Python wrapper commands [SETTOGGLE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## settoggle
Sets a runtime toggle to True or False. This overrides any toggles that have already been specified.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.settoggle("DISPLAY_BUILD_IN_CAPTION", True)
```

# Python wrapper commands [SETUNDOSTACKSIZE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setundostacksize
Displays the amount of actions that can be undone and redone and the maximum revert stack size.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays the number of actions that can be undone and redone and the maximum revert stack size

print(g_i.setundostacksize())
```

---

```python
# Alternative 2
# Displays the number of actions that can be undone and redone and set the maximum revert stack size

print(g_i.setundostacksize(14))
```

# Python wrapper commands [SETWATERDRY]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setwaterdry
Sets the pore pressure of one or more soil features to zero.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Sets the pore pressure of one or more soil features to zero in a specified phase

# Example 1
# Creates a cuboid and changes the mode. Adds phase and sets pore pressures of the volume to zero in a specified phase 
g_i.cuboid(3)
g_i.gotostages()
phase0_s = g_i.InitialPhase
volume_s = g_i.Volumes[-1]

print(g_i.setwaterdry(volume_s, phase0_s))

# Example 2
# Creates volumes and phase, sets pore pressures of the specified volumes to zero in a specified phase
s_i.new()
g_i.cuboid(2)
g_i.sphere(4)
g_i.gotostages()
phase0_s = g_i.InitialPhase

volume1_s = g_i.Volumes[-2]
volume2_s = g_i.Volumes[-1]
print(g_i.setwaterdry((volume1_s, volume2_s), phase0_s))


# Example 3
# Creates a volume and phases, sets pore pressures of the specified volume to zero in specified phases
s_i.new()
g_i.cuboid(2)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
volume_s = g_i.Volumes[-1]

print(g_i.setwaterdry(volume_s, phase0_s, phase1_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Sets the pore pressure of a soil feature to zero in one or more phases

# Creates a cuboid, changes the mode and adds phases. Sets the pore pressure of the soils to zero in the specified phases
g_i.cuboid(2)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
soils_s = g_i.Soils
print(g_i.setwaterdry(soils_s, (phase0_s, phase1_s)))
```

# Python wrapper commands [SETWATERINTERPOLATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## setwaterinterpolate
Sets that the pore pressure of one or more soil features should be interpolated.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Sets that the pore pressure of one or more soil features should be interpolated in a specified phase

# Example 1
# Creates a volume, changes the mode and creates a phase. Sets pore pressure of a volume to interpolate in a specified phase
g_i.cuboid(3)
g_i.gotostages()
phase0_s = g_i.InitialPhase
volume_s = g_i.Volumes[-1]

print(g_i.setwaterinterpolate(volume_s, phase0_s))

# Example 2
s_i.new()
g_i.cuboid(2)
g_i.sphere(4)
g_i.gotostages()
phase0_s = g_i.InitialPhase
volume1_s = g_i.Volumes[-2]
volume2_s = g_i.Volumes[-1]

print(g_i.setwaterinterpolate((volume1_s, volume2_s), phase0_s))

# Example 3
s_i.new()
g_i.cuboid(2)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
volume_s = g_i.Volumes[-1]

print(g_i.setwaterinterpolate(volume_s, phase0_s, phase1_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Sets that the pore pressure of a soil features should be interpolated in one or more specified phases

# Creates a cuboid, changes the mode and adds phases. Sets the pore pressure of the soils to interpolate in the specified phases
g_i.cuboid(2)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
soils_s = g_i.Soils

g_i.setwaterinterpolate(soils_s, (phase0_s, phase1_s))
```

# Python wrapper commands [SETWATERLEVEL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

# setwaterlevel
Assigns a water level to one or more objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Assigns a water level to one or more objects in a phase

# Creates a borehole and soil layers. Changes the mode and adds phases. Adds a water level. 
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(3)
g_i.soillayer(7)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
soil1_s = g_i.Soil_1
soil2_s = g_i.Soil_2
waterlevel_s = g_i.waterlevel(1, 4, 6)

# Assigns a water level to specified soils in the particular phases
g_i.setwaterlevel((soil1_s, soil2_s), (phase0_s, phase1_s), waterlevel_s)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Assigns a water level to an object in one or more phases

# Creates a borehole and soil layers. Changes the mode and adds phases. Adds a water level. 
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(3)
g_i.soillayer(7)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
soil1_s = g_i.Soil_1
soil2_s = g_i.Soil_2
waterlevel_s = g_i.waterlevel(1, 4, 6)

# Assigns a water level to specified soils in the particular phases
soil2_s.setwaterlevel((phase0_s, phase1_s), waterlevel_s)
```

# Python wrapper commands [SLEEP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## sleep
This commands sets the number of milliseconds for the application to do nothing.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.sleep(5)
```

# Python wrapper commands [SLICEMERGE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

# slicemerge
This command merges specific slicing groups in a tunnel.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a tunnel, adds segments and sets some properties. Then, adds a trajectory and merges specifying slicing groups of a tunnel 
tunnel_g = g_i.tunnel((0, 0, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4
tunnel_g.Trajectory.add()
tunnel_g.Trajectory.Segments[0].LineProperties.Length = 25
tunnel_g.Trajectory.add()

tunnel_g.Slicing.slicemerge(g_i.Tunnel_1.Slicing[0], g_i.Tunnel_1.Slicing[1])
```

# Python wrapper commands [SLICEMERGEALL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

# slicemergeall
This command merges all slicing groups in a tunnel.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a tunnel, adds segments and sets some properties. Then, adds a trajectory and merges all slicing groups of a tunnel 
tunnel_g = g_i.tunnel((0, 0, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4
tunnel_g.Trajectory.add()
tunnel_g.Trajectory.Segments[0].LineProperties.Length = 25
tunnel_g.Trajectory.add()

tunnel_g.Slicing.slicemergeall()
```

# Python wrapper commands [SLICINGRESET]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

# slicingreset
This command resets all slicing groups in a tunnel.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a tunnel, adds segments and sets some properties. Then, adds a trajectory and merges all slicing groups of a tunnel and then resets it
tunnel_g = g_i.tunnel((0, 0, 0), (1, 0, 0), (0, 0, 1))
tunnel_g.CrossSection.addsubcurve("Arc", 2, 3, 0, 90, 1)
tunnel_g.CrossSection.setproperties("x", 0, "y", 0, "z", -13.25, 
                                    "ShapeType", "Circular", "WholeHalfMode", "Left")
tunnel_g.CrossSection.Segments[0].ArcProperties.Radius = 4
tunnel_g.Trajectory.add()
tunnel_g.Trajectory.Segments[0].LineProperties.Length = 25
tunnel_g.Trajectory.add()

tunnel_g.Slicing.slicemergeall()
tunnel_g.Slicing.slicingreset()
```

# Python wrapper commands [SNAP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## snap
Snaps geometric objects with a default tolerance value of 0.001 or with an optional tolerance parameter. This command does not remove existing objects, nor creates new geometry but only adjusts the object position. The arguments are commutative, which implies that they are taken in alphabetical order for snapping despite the order of input.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Snaps geometric objects with a default tolerance value of 0.001

# Creates two points and snaps them with a default tolerance
point1_g, point2_g = g_i.point((0, 0, 0), (0.001, 0, 0)) 
g_i.snap(point1_g, point2_g)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Snaps geometric objects with a default tolerance value of 0.001

# Creates points and a line; then snaps all geometric objects with a default tolerance
point1_g, point2_g = g_i.point((1.001, 1, 1), (0.001, 0, 0)) 
line_g = g_i.line((0, 0, 0), (1, 1, 1))[-1]

print(g_i.snap(g_i.Geometry))
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Snaps geometric objects with a tolerance

point1_g, point2_g = g_i.point((0, 0, 0), (1, 0, 0)) 
g_i.snap(point1_g, point2_g, 1)
```

# Python wrapper commands [SNAPLINEAR]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## snaplinear
Snaps one or more points that are connected to a line to the object given as an argument, in such a way that the orientation of the connected line does not change. This command does not remove existing objects, nor creates new geometry but only adjusts the object position.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a point and then multiple objects, the last one is the Line object ([-1])
point_g = g_i.point(0.5, 0.5, 0.5)
line_g = g_i.line((0.001, 0, 0), (1, 1, 1))[-1]

g_i.snaplinear(point_g, line_g)
```

# Python wrapper commands [SOIL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## soil
Adds soil features to volumes.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds soil features to one or more existing volumes in the geometry

# Example 1
# Creates Volume and Soil objects; the first is the Volume object ([0]). Then assigns soil feature to the volume. Displays soil's address in the memory
volume_g = g_i.sphere(5)[0]
g_i.delete(volume_g.Soil)
soil_g = g_i.soil(volume_g)

print(soil_g)

# Example 2
volume1_g = g_i.sphere(5)[0]
volume2_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
g_i.delete(volume1_g.Soil, volume2_g.Soil)
soil_g = g_i.soil(volume1_g, volume2_g)
print(soil_g)

# Example 3
volume1_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
volume2_g = g_i.cone(2, 5, (1, 2, 3), (5, 7, 12))[0]
g_i.delete(volume1_g.Soil, volume2_g.Soil)
soil_g = g_i.soil((volume1_g, volume2_g))
print(soil_g)

# Example 4
# Creates Volume and Soil objects; the first are the Volume objects ([0]). Then groups the volumes.
volume1_g = g_i.cuboid(2, 3, 5, (0, 0, 1))[0]
volume2_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
volume3_g = g_i.cone(2, 5, (1, 2, 3), (5, 7, 12))[0]
g_i.delete(volume1_g.Soil, volume2_g.Soil, volume3_g.Soil)
group_g = g_i.group(volume1_g, volume2_g, volume3_g)

# Assigns soil feature to the volume. Displays soil's address in the memory
soil_g = g_i.soil(group_g)
print(soil_g)

# Obtain ApplyStrengthReduction property value assigned for all soils in a list and display them
soils_strength_reduction = g_i.Soils.ApplyStrengthReduction.value
print(f'Soils strength reduction property: {soils_strength_reduction}')
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Adds soil features to one or more existing volumes in the geometry and directly set their properties

# Example 1
# Creates Volume and Soil objects; the first one is the Volume object ([0]). Deletes a soil and creates a soil material.
volume_g = g_i.cuboid(7, 3, 10, (0, 0, 1))[0]
g_i.delete(g_i.Soil_1)
soilmaterial_i = g_i.soilmat()

# Creates a soil, assigns it to the volume and adds a material to it. Displays soil's address in the memory
soil_g = g_i.soil(volume_g, "Material", soilmaterial_i)
print(soil_g)

# Example 2
volume1_g = g_i.sphere(5)[0]
volume2_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 11))[0]
g_i.delete(g_i.Soil_1, g_i.Soil_2)
soilmaterial_i = g_i.soilmat()
soil_g = g_i.soil((volume1_g, volume2_g), "Material", soilmaterial_i)

print(soil_g)
```

# Python wrapper commands [SOILLAYER]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## soillayer
Adds a soil layer.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds a soil layer with a specified height at z=0 or underneath the last soil layer when it is not the first soil layer

# Creates a borehole and a soil layer. Displays soil's address in the memory
borehole_g = g_i.borehole(1, 4)
boreholevolume_g = g_i.soillayer(borehole_g, 3)

print(g_i.echo(boreholevolume_g))
```

---

```python
# Alternative 2
# Adds a soil layer at a specified borehole with a specified height at z=0 or underneath the last soil layer when it is not the first soil layer

# Creates a borehole and a soil layer. Displays soil's address in the memory
borehole_g = g_i.borehole(1, 4)
boreholevolume_g = g_i.soillayer(3)

print(g_i.echo(boreholevolume_g))
```

# Python wrapper commands [SOILLAYERHEIGHT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## soillayerheight
Changes the height of a soil layer.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer. Then changes the height of a soil layer
borehole_g = g_i.borehole(1, 4)
g_i.soillayer(3)
soillayer_g = g_i.Soillayers[-1]

g_i.soillayerheight(borehole_g, soillayer_g, 1)

print(g_i.echo(soillayer_g))
```

# Python wrapper commands [SOILMAT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## soilmat
Creates a soil material set.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a soil material set with no specified properties.

g_i.soilmat("Identification", "Sand", "SoilModel", "Hardening Soil", "gammaUnsat", 17, "gammaSat", 20, "E50Ref", 40000, "PowerM", 0.5, "cRef", 0.1, "phi", 32, "psi", 2, "InterfaceStrengthDetermination", "Manual", "Rinter", 0.67)
```

# Python wrapper commands [SPHERE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## sphere
Creates a sphere.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a sphere with a specified radius at the origin (0, 0, 0)

# Creates Volume and Soil object;, the first one is the Volume object ([0]). Displays volume's address in the memory
volume_g = g_i.sphere(5)[0]
print(volume_g)
```

---

```python
# Alternative 2
# Creates a sphere with a specified radius at specified coordinates

# Creates Volume and Soil object;, the first one is the Volume object ([0]). Displays volume's address in the memory
volume_g = g_i.sphere(5, (4, 5, 6))[0]
print(volume_g)
```

# Python wrapper commands [SURFACE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## surface
Creates a polygon.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a structural surface between three or more points

# Example 1
# Creates surface with three points. Displays its address in the memory
surface_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))

print(surface_g)

# Example 2
# Creates three points and forms a surface using those three points
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
point3_g = g_i.point(5, 6, 7)
surface_g = g_i.surface(point1_g, point2_g, point3_g)

print(surface_g)

# Example 3
point1_g = g_i.point(3, 4, 9)
point2_g = g_i.point(1, 1, 1)
surface_g = g_i.surface(point1_g, point2_g, (10, 11, 14), (6, 7, 9))

print(surface_g)
```

---

```python
# Alternative 2
# Creates a structural surface from a polycurve

# Creates multiple objects; the first one is the Polycurve object ([0]). Then closes the open polycurve so it can be made a surface
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()

# Creates a surface from a polycurve. Displays surface's address in the memory
surface_g = g_i.surface(polycurve_g)

print(surface_g)

# Obtain AxisFunction property value assigned for all surfaces in a list and display them
surfaces_axisfunction = g_i.Surfaces.AxisFunction.value
print(f'Surfaces Axis function property: {surfaces_axisfunction}')
```

# Python wrapper commands [SURFDISPL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## surfdispl
Adds surface prescribed displacement features to structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds surface prescribed displacement features to one or more existing structural surfaces in the geometry

# Example 1
# Creates a polygon and then assigns prescribed displacement feature to it. Displays feature's address in the memory
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfacedisplacement_g = g_i.surfdispl(polygon_g)

print(surfacedisplacement_g)

# Example 2
polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))
surfacedisplacements_g = g_i.surfdispl(polygon1_g, polygon2_g)

print(surfacedisplacements_g)

# Example 3
polygon1_g = g_i.surface((1, 1, 1), (2, 7, 1), (6, 13, 6), (9, 12, 9))
polygon2_g = g_i.surface((3, 3, 5), (7, 8, 4), (9, 11, 10), (11, 15, 13))
surfacedisplacements_g = g_i.surfdispl((polygon1_g, polygon2_g))

print(surfacedisplacements_g)

# Example 4
# Creates two polygons and groups them. Then, assigns a prescribed displacement feature to objects in the group
polygon1_g = g_i.surface((0, 0, 2), (3, 5, 4), (7, 11, 13), (9, 8, 15))
polygon2_g = g_i.surface((1, 0, 1), (4, 7, 8), (6, 8, 9), (10, 13, 7))
group_g = g_i.group(polygon1_g, polygon2_g)
surfacedisplacements_g = g_i.surfdispl(group_g)

print(surfacedisplacements_g)
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points (which may either exist, or will be created) and add a surface prescribed displacement feature to it

# Creates two points and then a surface with prescribed displacement feature assigned to it
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
surface_g, surfacedisplacement_g = g_i.surfdispl(point1_g, point2_g, (1, 0, 5))

print(surface_g, surfacedisplacement_g)
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and add a surface prescribed displacement feature to it

# Creates multiple objects, the first one is the Polycurve object ([0]) and closes the polycurve. Assigns a feature to a resulting polygon
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()
surface_g, surfacedisplacement_g = g_i.surfdispl(polycurve_g)

print(surface_g, surfacedisplacement_g)
```

---

```python
# Alternative 4
# Adds surface prescribed displacement features to one or more existing structural surfaces in the geometry and directly set their properties

# Example 1
# Creates a surface and using one function, assigns prescribed displacement feature to the polygon and sets some properties
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfacedisplacement_g = g_i.surfdispl(polygon_g, "Displacement_x", 
                                      "Fixed", "Displacement_y", "Prescribed")
print(surfacedisplacement_g)

# Example 2
polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))

surfacedisplacements_g = g_i.surfdispl((polygon1_g, polygon2_g), 
                                       "Displacement_x", "Fixed", "Displacement_y", "Prescribed")
print(surfacedisplacements_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points, adds a surface prescribed displacement feature to it and directly set its properties

# Creates two points and using one function, assigns prescribed displacement feature to the polygon and sets some properties
point1_g, point2_g = g_i.point((6, 4, 8), (8, 7, 9))
surface_g, surfacedisplacement_g = g_i.surfdispl(point1_g, point2_g, (1, 0, 5), "Displacement_x", "Fixed", "Displacement_y", 
                                                 "Prescribed")
print(surface_g, surfacedisplacement_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and adds a surface prescribed displacement feature to it and directly set its properties

# Creates multiple objects; the first one is the Polycurve object([0]), closes the polycurve and assigns a feature to the polygon
polycurve_g = g_i.polycurve((0, 0, 0), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "line", 90, 2, "line", 90, 2)[0]
polycurve_g.symmetricclose()
surface_g, surfacedisplacement_g = g_i.surfdispl(polycurve_g, "Displacement_x", "Fixed", "Displacement_y", "Prescribed")
print(surface_g, surfacedisplacement_g)

# Obtain uz property value assigned for all surface displacements in a list and display them
surfdispls_uz = g_i.SurfaceDisplacements.uz.value
print(f'Surface displacments uz property: {surfdispls_uz}')
```

# Python wrapper commands [SURFDRAIN]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## surfdrain
Adds surface drain features to structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds surface drain features to one or more existing structural surfaces in the geometry

# Example 1
# Creates a polygon and then assigns drain feature to it. Displays feature's address in the memory
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfacedrain_g = g_i.surfdrain(polygon_g)

print(surfacedrain_g)

# Example 2
polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))
surfacedrains_g = g_i.surfdrain(polygon1_g, polygon2_g)

print(surfacedrains_g)

# Example 3
polygon1_g = g_i.surface((1, 1, 1), (2, 7, 1), (6, 13, 6), (9, 12, 9))
polygon2_g = g_i.surface((3, 3, 5), (7, 8, 4), (9, 11, 10), (11, 15, 13))
surfacedrains_g = g_i.surfdrain((polygon1_g, polygon2_g))

print(surfacedrains_g)

# Example 4
# Creates two polygons and groups them. Then, assigns a drain feature to objects in the group
polygon1_g = g_i.surface((0, 0, 2), (3, 5, 4), (7, 11, 13), (9, 8, 15))
polygon2_g = g_i.surface((1, 0, 1), (4, 7, 8), (6, 8, 9), (10, 13, 7))
group_g = g_i.group(polygon1_g, polygon2_g)
surfacedrains_g = g_i.surfdrain(group_g)

print(surfacedrains_g)
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points and adds a surface drain feature to it

# Creates two points and then a surface with drain feature assigned to it. Displays feature's address in the memory
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
surface_g, surfacedrain_g = g_i.surfdrain(point1_g, point2_g, (1, 0, 5))

print(surface_g, surfacedrain_g)
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and add a surface drain feature to it

# Creates multiple objects, the first one is the Polycurve object ([0]) and closes the polycurve.
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()

# Assigns a drain feature to a resulting polygon and displays surface's and feature's addresses in the memory
surface_g, surfacedrain_g = g_i.surfdrain(polycurve_g)
print(surface_g, surfacedrain_g)
```

---

```python
# Alternative 4
# Adds surface drain features to one or more existing structural surfaces in the geometry and directly set their properties

# Example 1
# Creates a surface and a soil material. Then in one function, assigns drain feature to the polygon and material to the feature
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfacedrain_g = g_i.surfdrain(polygon_g, "h", 1.2)

print(surfacedrain_g)

# Example 2
polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))
surfacedrains_g = g_i.surfdrain((polygon1_g, polygon2_g), "h", 1.2)

print(surfacedrains_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points, add a surface drain feature to it and directly set its properties

# Creates two points and using one function, assigns drain feature to a newly created polygon and sets some properties
point1_g, point2_g = g_i.point(6, 4, 8), (8, 7, 9)
surface_g, surfacedrain_g = g_i.surfdrain(point1_g, point2_g, (1, 0, 5), "h", 1.2)

print(surface_g, surfacedrain_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and add a surface drain feature to it and directly set its properties

# Creates multiple objects; the first one is the Polycurve object([0]) and closes the polycurve
polycurve_g = g_i.polycurve((0, 0, 0), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "line", 90, 2, "line", 90, 2)[0]
polycurve_g.symmetricclose()

# Creates multiple objects; Surface and drain objects respectively
surface_g, surfacedrain_g = g_i.surfdrain(polycurve_g, "h", 1.2)

print(surface_g, surfacedrain_g)

# Obtain Behaviour property value assigned for all surface drains in a list and display them
surfacedrains_behaviour= g_i.SurfaceDrains.Behaviour.value
print(f'Surface Drains Behaviour property: {surfacedrains_behaviour}')
```

# Python wrapper commands [surfgwfbc]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## surfgwfbc
Adds surface groundwater flow boundary condition features to structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds surface groundwater flow boundary condition features to one or more existing structural surfaces in the geometry

# Example 1
# Creates a polygon and then a assigns groundwater flow boundary condition feature to it. Displays feature's address in the memory
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfacegroundwaterbc_g = g_i.surfgwfbc(polygon_g)

print(surfacegroundwaterbc_g)

# Example 2
polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))
surfacegroundwaterbcs_g = g_i.surfgwfbc(polygon1_g, polygon2_g)

print(surfacegroundwaterbcs_g)

# Example 3
polygon1_g = g_i.surface((1, 1, 1), (2, 7, 1), (6, 13, 6), (9, 12, 9))
polygon2_g = g_i.surface((3, 3, 5), (7, 8, 4), (9, 11, 10), (11, 15, 13))
surfacegroundwaterbcs_g = g_i.surfgwfbc((polygon1_g, polygon2_g))

print(surfacegroundwaterbcs_g)

# Example 4
# Creates two polygons and groups them. Then, assigns a surface groundwater flow boundary condition feature to objects in the group
polygon1_g = g_i.surface((0, 0, 2), (3, 5, 4), (7, 11, 13), (9, 8, 15))
polygon2_g = g_i.surface((1, 0, 1), (4, 7, 8), (6, 8, 9), (10, 13, 7))
group_g = g_i.group(polygon1_g, polygon2_g)
surfacegroundwaterbcs_g = g_i.surfgwfbc(group_g)

print(surfacegroundwaterbcs_g)
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points and add a surface groundwater flow boundary condition feature to it

# Creates two points and then a surface with groundwater flow boundary condition feature assigned to it
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
surface_g, surfacegroundwaterbc_g = g_i.surfgwfbc(point1_g, point2_g, (1, 0, 5))

print(surface_g, surfacegroundwaterbc_g)
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and add a surface groundwater flow boundary condition feature to it

# Creates multiple objects, the first one is the Polycurve object ([0]) and closes the polycurve. Assigns a feature to a resulting polygon
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()
surface_g, surfacegroundwaterbc_g = g_i.surfgwfbc(polycurve_g)

print(surface_g, surfacegroundwaterbc_g)
```

---

```python
# Alternative 4
# Adds surface groundwater flow boundary condition features to one or more existing structural surfaces in the geometry and directly set their properties

# Example 1
# Creates a surface and a soil material. Then in one function, assigns the feature to the polygon and sets some properties
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfacegroundwaterbc_g = g_i.surfgwfbc(polygon_g, "Behaviour", "Closed")

print(surfacegroundwaterbc_g)

# Example 2
polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))
surfacegroundwaterbcs_g = g_i.surfgwfbc((polygon1_g, polygon2_g), 
                                        "Behaviour", "Closed")
print(surfacegroundwaterbcs_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points, add a surface groundwater flow boundary condition feature to it and directly set its properties

# Creates two points and using one function, assigns the feature to a newly created polygon and sets some properties
point1_g, point2_g = g_i.point((6, 4, 8), (8, 7, 9))
surface_g, surfacegroundwaterbc_g = g_i.surfgwfbc(point1_g, point2_g, (1, 0, 5),
                                                  "Behaviour", "Closed")
print(surface_g, surfacegroundwaterbc_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and add a surface groundwater flow boundary condition feature to it and directly set its properties

# Creates multiple objects; the first one is the Polycurve object([0]), closes the polycurve
polycurve_g = g_i.polycurve((0, 0, 0), (0, 0, 1), (1, 0, 0),
                            "line", 0, 2, "line", 90, 2, "line", 90, 2)[0]
polycurve_g.symmetricclose()

# Creates multiple objects; Surface and groundwater flow boundary condition feature respectively
surface_g, surfacegroundwaterbc_g = g_i.surfgwfbc(polycurve_g, 
                                                  "Behaviour", "Closed")
print(surface_g, surfacegroundwaterbc_g)

# Obtain Behaviour property value assigned for all surface groundwater flow BCs in a list and display them
surfacegwfbcs_behaviour= g_i.SurfaceGroundwaterFlowBCs.Behaviour.value
print(f'Surface Groundwater Flow BCs Behaviour property: {surfacegwfbcs_behaviour}')
```

# Python wrapper commands [SURFLOAD]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## surfload
Adds surface load features to structural surfaces.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds surface load features to one or more existing structural surfaces in the geometry

# Example 1
# Creates a polygon and then assigns load feature to it. Displays feature's address in the memory
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfaceload_g = g_i.surfload(polygon_g)

print(surfaceload_g)

# Example 2
polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))
surfaceloads_g = g_i.surfload(polygon1_g, polygon2_g)

print(surfaceloads_g)

# Example 3
polygon1_g = g_i.surface((1, 1, 1), (2, 7, 1), (6, 13, 6), (9, 12, 9))
polygon2_g = g_i.surface((3, 3, 5), (7, 8, 4), (9, 11, 10), (11, 15, 13))
surfaceloads_g = g_i.surfload((polygon1_g, polygon2_g))

print(surfaceloads_g)

# Example 4
# Creates two polygons and groups them. Then, assigns a load feature to objects in the group
polygon1_g = g_i.surface((0, 0, 2), (3, 5, 4), (7, 11, 13), (9, 8, 15))
polygon2_g = g_i.surface((1, 0, 1), (4, 7, 8), (6, 8, 9), (10, 13, 7))
group_g = g_i.group(polygon1_g, polygon2_g)
surfaceloads_g = g_i.surfload(group_g)

print(surfaceloads_g)
```

---

```python
# Alternative 2
# Creates a structural surface between three or more points and add a surface load feature to it

# Creates two points and then a surface with load feature assigned to it. Displays surface's and feature's addresses in the memory
point1_g, point2_g = g_i.point((5, 2, 10), (7, 3, 6))
surface_g, surfaceload_g = g_i.surfload(point1_g, point2_g, (1, 0, 5))

print(surface_g, surfaceload_g)
```

---

```python
# Alternative 3
# Creates a structural surface from a polycurve and add a surface load feature to it

# Creates multiple objects, the first one is the Polycurve object ([0]) and closes the polycurve
polycurve_g = g_i.polycurve((4, 5, 6), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "arc", 45, 90, 3)[0]
polycurve_g.close()

# Assigns a feature to a resulting polygon. Displays surface's and feature's addresses in the memory
surface_g, surfaceload_g = g_i.surfload(polycurve_g)

print(surface_g, surfaceload_g)
```

---

```python
# Alternative 4
# Adds surface load features to one or more existing structural surfaces in the geometry and directly set their properties

# Example 1
# Creates a surface and using one function, assigns load feature to the polygon and sets some parameters
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
surfaceload_g = g_i.surfload(polygon_g, "sigx", 2, "sigy", 5)

print(surfaceload_g)

# Example 2
polygon1_g = g_i.surface((1, 2, 3), (4, 6, 5), (10, 12, 17), (5, 8, 8))
polygon2_g = g_i.surface((1, 0, 2), (5, 7, 3), (8, 13, 12), (10, 9, 11))
surfaceloads_g = g_i.surfload((polygon1_g, polygon2_g), "sigx", 2, "sigy", 5)

print(surfaceloads_g)
```

---

```python
# Alternative 5
# Creates a structural surface between three or more points, add a surface load feature to it and directly set its properties

# Creates two points and, using one function, assigns load feature to a newly created polygon and sets some properties
point1_g, point2_g = g_i.point((6, 4, 8), (8, 7, 9))
surface_g, surfaceload_g = g_i.surfload(point1_g, point2_g, (1, 0, 5), "sigx", 2, "sigy", 5)

print(surface_g, surfaceload_g)
```

---

```python
# Alternative 6
# Creates a structural surface from a polycurve and add a surface load feature to it and directly set its properties

# Creates multiple objects; the first one is the Polycurve object([0]), closes the polycurve and creates soil material
polycurve_g = g_i.polycurve((0, 0, 0), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "line", 90, 2, "line", 90, 2)[0]
polycurve_g.symmetricclose()

# Creates multiple objects; Surface and SurfaceLoad objects respectively
surface_g, surfaceload_g = g_i.surfload(polycurve_g, "sigx", 2, "sigy", 5)

print(surface_g, surfaceload_g)

# Obtain Distribution property value assigned for all surface loads in a list and display them
surfaceloads_distribution = g_i.SurfaceLoads.Distribution.value
print(f'Surface Loads Distribution property: {surfaceloads_distribution}')
```

# Python wrapper commands [SYMMETRICCLOSE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## symmetricclose
Closes a polycurve symmetrically.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Closes a polycurve symmetrically over the second local axis of the polycurve by adding copies of the existing segments in opposite order. The last point of the polycurve must be located on the local second axis of the polycurve

# Creates multiple objects; the first one is the Polycurve object ([0]) with segments
polycurve_g = g_i.polycurve((0, 0, 0), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "line", 90, 2, "line", 90, 2)[0]
segments_g = polycurve_g.symmetricclose()

print(segments_g)
```

---

```python
# Alternative 2
# Closes a polycurve symmetrically by adding copies of the existing segments in opposite order

# Example 1
# Creates multiple objects; the first one is the Polycurve object with segments and closes the polycurve
polycurve_g = g_i.polycurve((6, 8, 10), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2, "line", 0, 5)[0]
# Closes polycurve symmetrically over the second local axis by adding copies of the existing segments in opposite order.
# If the last point of the polycurve is not located on the local second axis, the symmetry axis will be moved to the last point
segments_g = polycurve_g.symmetricclose(True)

print(segments_g)

# Example 2
# Creates multiple objects; the first one is the Polycurve object
polycurve_g = g_i.polycurve((9, 11, 12), (0, 0, 1), (1, 0, 0), 
                            "line", 0, 2,"line", 90, 2, "line", 90, 2)[0]
# Closes Polycurve_4 symmetrically over the second local axis of Polycurve_4 by adding copies of the existing segments in the
# opposite order. The last point of the polycurve must be located on the local second axis
segments_g = polycurve_g.symmetricclose(False)

print(segments_g)
```

# Python wrapper commands [TABULATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## tabulate
Displays a table of properties for specified objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Displays a table with specified objects.

g_i.platemat("Identification", "Footing", "MaterialType", "Elastic", "Gamma", 15, 
             "E1", 10000000, "D3d", 0.1, "StructNu12", 0.1)
g_i.platemat("Identification", "Footing", "MaterialType", "Elastic", "Gamma", 25, 
             "E1", 20000000, "D3d", 0.4, "StructNu12", 0.2)
materiallist_i = g_i.Materials

print(g_i.tabulate(materiallist_i))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Displays a table of objects that fulfil a specified criterion.

# Example 1
g_i.clear()
# Creates multiple objects, the last one is the Line object ([-1])
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
beammaterial_i = g_i.beammat()
g_i.beam((line1_g, line2_g), "Material", beammaterial_i)

print(g_i.tabulate(g_i.Beams, "Material"))

# Example 2
g_i.clear()
# Creates multiple objects, the last one is the Line object ([-1])
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
lines_g = g_i.Lines

print(g_i.tabulate(lines_g, "First Second"))
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Displays a table (with specified columns) of objects that fulfil a specified criterion.

# Example 1
g_i.point((3, 4, 1), (5, 2, 2), (7, 3, 1))
pointobjects_g = g_i.Points

print(g_i.tabulate(pointobjects_g, "y", "z=1"))

# Example 2
# Creates multiple objects, the last one is the Line object ([-1])
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']

g_i.linedispl(line1_g, "Displacement_x", "Fixed", "Displacement_y", "Prescribed")
g_i.linedispl((line2_g, lines_g[-2], lines_g[-1]), "Displacement_x", "Fixed", "Displacement_y", "Prescribed")
linedisplacements_i = g_i.LineDisplacements
line1_g.LineDisplacement.uz_end = 2
line2_g.LineDisplacement.uz_end = 4

print(g_i.tabulate(linedisplacements_i, "uz_start uz_end", "uz_end!=4"))

# Example 3
g_i.clear()
point1_g, point2_g, point3_g = g_i.point((3, 4, 9), (5, 2, 10), (7, 3, 6))
g_i.pointload(point2_g, point3_g)
pointloads_i = g_i.PointLoads
pointloads_i[-1].Fx = 3

print(g_i.tabulate(pointloads_i, " ", "Fx<5"))

# Example 4
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon3_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
geogridmaterial_i = g_i.geogridmat()
g_i.geogrid((polygon1_g, polygon2_g), "Material", geogridmaterial_i)
geogrids_g = g_i.Geogrids

print(g_i.tabulate(geogrids_g, "", "Material<>"))

# Example 5
g_i.clear()
polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (0, 2, 5), (4, 2, 5))
polygon3_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
surfaces_g = g_i.Surfaces

print(g_i.tabulate(surfaces_g, "Area", "Area<0.01"))
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Displays a table of the values of the specified properties in columns, in the given phase.

polygon1_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
polygon2_g = g_i.surface((0, 0, 0), (0, 2, 5), (4, 2, 5))

for i in range(5):
    g_i.lineload((1, i, 0), (2, i, 0))
    
g_i.gotostages()
phases_s = [g_i.phase(g_i.InitialPhase) for i in range(3)]

lineloads_s = g_i.LineLoads

print(g_i.tabulate(lineloads_s, phases_s[-1]))
```

---

```python
s_i.new()
```

---

```python
# Alternative 5
# Displays a table of the values of the specified properties in columns, in the given phase.

# Creates a borehole and soillayer of specified height
g_i.borehole(0, 0)
g_i.soillayer(2)

for i in range(5):
    g_i.pointload(1, i/2, 0)
    
g_i.gotostages()
phases_s = [g_i.phase(g_i.InitialPhase) for i in range(3)]

pointloads_s = g_i.PointLoads

print(g_i.tabulate(pointloads_s, phases_s[-1], "Fx Fz"))
```

---

```python
s_i.new()
```

---

```python
# Alternative 6
# Displays a table of the values of the specified properties in columns, that fulfil the specified criteria in the given phase.

# Creates a borehole and soillayer of specified height
g_i.borehole(0, 0)
g_i.soillayer(2)

for i in range(5):
    g_i.pointload(1, i/2, 0)
    
g_i.gotostages()
phases_s = [g_i.phase(g_i.InitialPhase) for i in range(3)]

pointloads_s = g_i.PointLoads
g_i.activate(pointloads_s[0], pointloads_s[2], phases_s[-1])

print(g_i.tabulate(pointloads_s, phases_s[-1], "Fx Fy Fz", "Active=True"))
```

---

```python
s_i.new()
```

---

```python
# Alternative 7
# Displays a list of phases in which staged feature is present.

g_i.surface((0, 0, 0), (0, 6, 0), (5, 6, 0), (5, 0, 0))
g_i.pointload(1, 4, 0)

g_i.gotostages()
phases_s = [g_i.phase(g_i.InitialPhase) for i in range(3)]

pointload_s = g_i.PointLoads[-1]
print(g_i.tabulate(pointload_s, phases_s[0], phases_s[1]))
```

---

```python
s_i.new()
```

---

```python
# Alternative 8
# Displays a table of the values of the specified properties in columns, in the given phase.

g_i.surface((0, 0, 0), (0, 6, 0), (5, 6, 0), (5, 0, 0))
g_i.pointload(1, 4, 0)

g_i.gotostages()
phases_s = [g_i.phase(g_i.InitialPhase) for i in range(3)]

pointload_s = g_i.PointLoads[-1]

pointload_s.activate(phases_s[0])
print(g_i.tabulate(pointload_s, phases_s, "Active F"))
```

---

```python
s_i.new()
```

---

```python
# Alternative 9
# Displays a table of the values of the specified properties in columns, that fulfil the specified criteria in the given phase.
g_i.surface((0, 0, 0), (0, 6, 0), (5, 6, 0), (5, 0, 0))
g_i.pointload(1, 4, 0)

g_i.gotostages()
phases_s = [g_i.phase(g_i.InitialPhase) for i in range(3)]

pointload_s = g_i.PointLoads[-1]

pointload_s.activate(phases_s[0])
print(g_i.tabulate(pointload_s, phases_s, "", "Active=True"))
```

# Python wrapper commands [TESTASYNC]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## testasync
Tests that asynchronous task execution works correctly.

---

```python
s_i.new()
```

---

```python
# Alternative 1

g_i.testasync(30)
```

# Python wrapper commands [TRANSFORM]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## transform
Multiplies a multiplier by the scaling factor and writes these values into a new column. The default scaling factor is 1.0.

---

```python
s_i.new()
```

---

```python
# Alternative 1

displacementmultiplier_g = g_i.displmultiplier()
displacementmultiplier_g.transform()
```

# Python wrapper commands [TRANSLATELINE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## translateline
Moves a line of an existing polygon.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a surface and moves a line with index 4 along the given vector
polygon_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9), (5, 6, 8))
polygon_g.translateline(4, (2, 1, 3))
```

# Python wrapper commands [TUNNEL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## tunnel
Creates a tunnel at a specified location.

---

```python
s_i.new()
```

---

```python
# Alternative 1

tunnel_g = g_i.tunnel(6, 2, 3)
print(tunnel_g)
```

# Python wrapper commands [UNGROUP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## unassign
Unassign the assignment of a property to none.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Unassign the assignment of a property to none in Structures mode.

# Unassigns the material data set from the Material property of the Soil object, which is a feature of Volume_1. 
g_i.gotostructures()
polygon = g_i.surface(0, 0, 0, 0, 8, 0, 12, 8, 0, 12, 0, 0)
g_i.extrude(polygon, 0, 0, -1)

material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Volumes[0].Soil.Material = material
print(g_i.Volumes[0].Soil.Material)

g_i.unassign(g_i.Volumes[0].Soil.Material)
print(g_i.Volumes[0].Soil.Material)

# Unassigns the dynamic multiplier from the Multiplierx property of the dynamic line displacement, which is a feature of Surface_1.
g_i.surfdispl(polygon)
g_i.displmultiplier()
g_i.Surfaces[-1].SurfaceDisplacement.SurfaceDisplacement.Multiplierx = g_i.DisplacementMultiplier_1
print(g_i.Surfaces[-1].SurfaceDisplacement.SurfaceDisplacement.Multiplierx)

g_i.unassign(g_i.Surfaces[-1].SurfaceDisplacement.SurfaceDisplacement.Multiplierx)
print(g_i.Surfaces[-1].SurfaceDisplacement.SurfaceDisplacement.Multiplierx)

# Unassigns the discharge function from the groundwater flow boundary condition (SurfaceGWFlowBC) property, which is a feature of Surface_2.
g_i.surfgwfbc(0, 0, 0, 0, 8, 0, 0, 8, -1, 0, 0, -1)
g_i.Surfaces[-1].SurfaceGWFlowBC.Behaviour = "Inflow"
g_i.Surfaces[-1].SurfaceGWFlowBC.TimeDependency = "Time dependent"
g_i.dischargefunction()
g_i.Surfaces[-1].SurfaceGWFlowBC.DischargeFunction = g_i.DischargeFunction_1
print(g_i.Surfaces[-1].SurfaceGWFlowBC.DischargeFunction)

g_i.unassign(g_i.Surfaces[-1].SurfaceGWFlowBC.DischargeFunction)
print(g_i.Surfaces[-1].SurfaceGWFlowBC.DischargeFunction)
```

---

```python
# Alternative 2
# Unassign the assignment of a property to none in Staged construction mode.
g_i.gotostages()
g_i.phase(g_i.Phases[0])
g_i.setcurrentphase(g_i.Phases[-1])

# Unassigns the material data set from the Material property of the Soil_1_1 object, in Phase_1.
g_i.Volumes[0].Soil.Material[g_i.Phases[-1]] = material
print(g_i.Volumes[0].Soil.Material[g_i.Phases[-1]])

g_i.unassign(g_i.Volumes[0].Soil.Material, g_i.Phases[-1])
print(g_i.Volumes[0].Soil.Material[g_i.Phases[-1]])

# Unassigns multiple properties of different objects, in Phase_1
g_i.Volumes[0].Soil.Material[g_i.Phases[-1]] = material
g_i.Surfaces[0].SurfaceDisplacement.SurfaceDisplacement.Multiplierx[g_i.Phases[-1]] = g_i.DisplacementMultiplier_1
g_i.Surfaces[1].SurfaceGWFlowBC.DischargeFunction[g_i.Phases[-1]] = g_i.DischargeFunction_1

g_i.unassign(g_i.Volumes[0].Soil.Material, g_i.Surfaces[0].SurfaceDisplacement.SurfaceDisplacement.Multiplierx, g_i.Surfaces[1].SurfaceGWFlowBC.DischargeFunction,g_i.Phases[-1])
```

# Python wrapper commands [UNDO]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## undo
Undo actions.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Reverses the last action

g_i.borehole(1, 5)
g_i.undo()
```

---

```python
# Alternative 2
# Reverses one or more last actions

# Creates a borehole and soil layers. Then sets soil layer height and reverses four recent actions
borehole_g = g_i.borehole(0,0)
g_i.soillayer(3)
g_i.soillayer(5)
soillayer_g = g_i.Soillayers[-2]
g_i.soillayerheight(borehole_g, soillayer_g, 1)
g_i.undo(4)
```

# Python wrapper commands [UNGROUP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## ungroup
Ungroups a group of objects.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Ungroups a group of objects

# Creates Volume and Soil objects; the first one is the Volume object ([0]). Groups some objects and then ungroups them
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
volume1_g = g_i.sphere(5)[0]
group_g = g_i.group(polygon_g, volume1_g)
g_i.ungroup(group_g)
```

---

```python
# Alternative 2
# Ungroups one or more groups

# Example 1
# Creates multiple objects; the last one is the Line object ([-1]) and a surface. Groups them and then ungroups them
line_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
polygon_g = g_i.surface((3, 2, 1), (4, 5, 8), (10, 11, 14))
group_g = g_i.group(line_g, polygon_g)

print(g_i.ungroup(group_g))

# Example 2
# Creates four surfaces and groups them. Changes names of the groups and ungroups the groups
polygon1_g = g_i.surface((0, 0, 0), (4, 6, 5), (10, 11, 14), (6, 7, 9))
polygon2_g = g_i.surface((1, 1, 1), (3, 6, 4), (9, 15, 13), (8, 9, 10))
polygon3_g = g_i.surface((12, 15, 0), (3, 6, 3), (9, 15, 12), (8, 9, 9))
polygon4_g = g_i.surface((3, 7, 8), (7, 8, 3), (9, 1, 11), (10, 14, 15))
group1_g = g_i.group(polygon1_g, polygon2_g)
group2_g = g_i.group(polygon3_g, polygon4_g)
group1_g.Name = "BasementFloors"
group2_g.Name = "BuildingWalls"
building_walls = g_i.BuildingWalls
basement_floors = g_i.BasementFloors

print(g_i.ungroup(building_walls, basement_floors))
```

# Python wrapper commands [USECUSTOMBOTTOMSURFACE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## usecustombottomsurface
Enables or disables the use of a custom bottom surface for the soil body generated by boreholes.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer and enables the use of a custom bottom surface of the soil body generated by the borehole
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
g_i.usecustombottomsurface(True)

print(g_i.echo(borehole_g))
```

# Python wrapper commands [USECUSTOMTOPSURFACE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## usecustomtopsurface
Enables or disables the use of a custom top surface for the soil body generated by boreholes.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole and a soil layer and disables the use of a custom top surface of the soil body generated by the borehole
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
g_i.usecustomtopsurface(False)
```

# Python wrapper commands [VALIDATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## validate
Checks the Material parameters for invalid inputs.

---

```python
s_i.new()
```

---

```python
# Alternative 1
g_i.soilmat("Identification", "Sand", "SoilModel", "Hardening Soil", "gammaUnsat", 21, "gammaSat", 20, "E50Ref", 40000, "cRef", 0, "phi", 0)
validate_command = g_i.validate(g_i.Materials[-1])
print(validate_command)
```

---

```python
# Alternative 1
g_i.soilmat("Identification", "LowerSand", "SoilModel", "Hardening Soil", "gammaUnsat", 21, "gammaSat", 20, "E50Ref", 40000, "cRef", 0, "phi", 0)
validate_command = g_i.validate(g_i.Materials[-1], "errors")
print(validate_command)
```

# Python wrapper commands [VIEW]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## view
Displays the calculation results of a phase.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole, soil layer and a soil material. Changes material's properties
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes the modes and generates the mesh. Adds phases and calculates the projects. Displays calculation results of phase1_s
g_i.gotomesh()
g_i.mesh(0.2)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.calculate()
g_i.view(phase1_s)
```

# Python wrapper commands [VIEWMESH]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## viewmesh
Displays the generated mesh.

---

```python
s_i.new()
```

---

```python
# Alternative 1

# Creates a borehole, soil layer and a soil material. Changes material's properties
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material

# Changes the modes and generates the mesh. Displays generated mesh
g_i.gotomesh()
g_i.mesh(0.1)
g_i.viewmesh()
```

# Python wrapper commands [WATERLEVEL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## waterlevel
Creates a new water level with one or more points at a specified location. zref is the z-coordinate where the pore pressure is equal to zero and pinc is pressure increment.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Creates a new water level with a point at a specified location (x, y), a zref and a pinc

# Creates a cuboid and changes the mode. Adds a water level at the location (6,4) with zref 1 and pinc 2
g_i.cuboid(10)
g_i.gotoflow()

print(g_i.echo(g_i.waterlevel((6, 4, 1), 2)))
```

---

```python
# Alternative 2
# Creates a new water level with a point at a specified location (x, y) and a zref

# Adds a water level at the location (1,4) with zref 6
g_i.gotoflow()
print(g_i.echo(g_i.waterlevel(1, 4, 6)))

# Obtain TimeDependency property value assigned for all user water levels in a list and display them
waterlevels_timedependency = g_i.UserWaterLevels.TimeDependency.value
print(f'Water levels Time dependency property: {waterlevels_timedependency}')
```

---

```python
# Alternative 3
# Creates a new water level with two or more points at a specified location (x, y) and a zref

# Creates a cuboid and changes the mode. Adds a water level at the location (6,4)with zref 1 and water point at (8,5) with zref 2
g_i.gotosoil()
g_i.clear()
g_i.cuboid(3)
g_i.gotoflow()

g_i.waterlevel((6, 4, 1), (8, 5, 2))
print(g_i.echo(g_i.waterlevel((6, 4, 1), (8, 5, 2))))
```

# Python wrapper commands [WELL]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## well
Adds well features to lines.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds well features to one or more existing lines in the geometry

# Example 1
# Creates multiple objects, the last one is the Line object and assigns well feature to it. Displays line's address in the memory
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
well_g = g_i.well(line_g)

print(well_g)

# Example 2
# Creates two lines and assigns well features to them
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
wells_g = g_i.well(line1_g, line2_g)

print(wells_g)

# Example 3
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
wells_g = g_i.well((line1_g, line2_g))

print(wells_g)

# Example 4
# Creates two lines and groups them, then assigns well features to the objects in the group
line1_g = g_i.line((5, 6, 7), (8, 9, 10))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
res = g_i.line((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
group_g = g_i.group(line1_g, line2_g, lines_g[-2], lines_g[-1])
wells_g = g_i.well(group_g)

print(wells_g)
```

---

```python
# Alternative 2
# Creates a line between two points (which may either exist or will be created) and adds a well feature to it

# Example 1
# Creates a point and then creates a Line and Well objects and assigns well feature to the line
point_g = g_i.point(2, 3, 4)
line_g, well_g = g_i.well(point_g, (5, 6, 7))[-2:]

print(line_g, well_g)

# Example 2
# Creates two points and then using one function creates a line from those points, and then assigns well feature to the line
point1_g = g_i.point(1, 3, 4)
point2_g = g_i.point(7, 8, 5)
line_g, well_g = g_i.well(point1_g, point2_g)[-2:]

print(line_g, well_g)

# Example 3
line_g, well_g = g_i.well((1, 4, 0), (6, 5, 8))[-2:]

print(line_g, well_g)
```

---

```python
# Alternative 3
# Creates lines between three or more points (which may either exist or will be created) and adds well features to them

# Creates two points, and then two lines. Then assigns all line objects to the variable lines_g and all well objects to wells_g
point1_g = g_i.point(1, 3, 4)
point2_g = g_i.point(5, 6, 9)
res = g_i.well(point1_g, (5.1, 6.4, 7.2), point2_g)
lines_g = [item for item in res if item._plx_type == 'Line']
wells_g = [item for item in res if item._plx_type == 'Well']

print(lines_g, wells_g)
```

---

```python
# Alternative 4
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by providing the angles concerning the XY- and the XZ-plane and a length or a vector describing the direction and a length and add well features to them

# Example 1
# Creates multiple objects; last two are Line and Well objects respectively
line_g, well_g = g_i.well((1, 2, 0), "relative", (3, 4, 8))[-2:]

print(g_i.echo(line_g, well_g))

# Example 2
# Creates a point and then using one function creates two lines (using existing point), and assigns well features to them
point_g = g_i.point(2, 3, 4)
res = g_i.well(point_g, "relative", (3, 4, 8), (-5, -9, 10), "angles", 0, 30, 16)
lines_g = [item for item in res if item._plx_type == 'Line']
wells_g = [item for item in res if item._plx_type == 'Well']

print(lines_g, wells_g)

# Example 3
res = g_i.well((1, 2, 3), "angles", 45, 50, 10, "absolute", (4, 5, 6))
lines_g = [item for item in res if item._plx_type == 'Line']
wells_g = [item for item in res if item._plx_type == 'Well']

print(lines_g, wells_g)

# Example 4
# Creates multiple objects; the last one are the Line objects ([-1]), assigns well features to those lines, and snaps them to the volume
point_g = g_i.point(2, 3, 4)
volume_g = g_i.cylinder(2, 5, (1, 2, 3), (5, 7, 12))[0]
line_g, well_g = g_i.well(point_g, "angles", 90, 0, volume_g)[-2:]

print(line_g, well_g)
```

---

```python
# Alternative 5
# Adds well features to one or more existing lines in the geometry and directly set their properties

# Example 1
# Creates multiple objects; the last one is the Line object and assigns well feature to it, setting some properties
line_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
well_g = g_i.well(line_g, "Behaviour", "Extraction")

print(well_g)

# Example 2
# Creates multiple objects; the last ones are the Line objects and assigns well features to them, setting some properties
line1_g = g_i.line((0, 2, 3.2), (-5, 2, 3.2))[-1]
line2_g = g_i.line((1, 2, 0), "relative", (3, 4, 8))[-1]
wells_g = g_i.well((line1_g, line2_g), "Behaviour", "Extraction")

print(wells_g)
```

---

```python
# Alternative 6
# Creates a line between two points, adds a well feature to it and directly sets its properties

# Creates a point and a line and assigns well features to the line, setting some properties
point_g = g_i.point(2, 3, 4)
line_g, well_g = g_i.well(point_g, (5, 6, 7), "Behaviour", "Extraction")[-2:]

print(line_g, well_g)
```

---

```python
# Alternative 7
# Creates lines between three or more points, adds well features to them and directly sets their properties

# Creates multiple objects; the last ones are the Line objects and assigns well features to them, setting some properties
point1_g = g_i.point(1, 3, 4)
point2_g = g_i.point(5, 6, 9)

# Then assigns all line objects to the variable lines_g and all well objects to wells_g
res = g_i.well(point1_g, (5.1, 6.4, 7.2), point2_g, "Behaviour", "Extraction")
lines_g = [item for item in res if item._plx_type == 'Line']
wells_g = [item for item in res if item._plx_type == 'Well']

print(lines_g, wells_g)
```

---

```python
# Alternative 8
# Creates one or more lines by either giving absolute coordinates or relative coordinates, by providing the angles concerning 
# the XY- and the XZ-plane and a length or a vector describing the direction and a length, add well features to them and directly set their properties

# Creates multiple objects; last two are Line and Well objects respectively
line_g, well_g = g_i.well((1, 2, 0), "relative", (3, 4, 8), "Behaviour", 
                          "Extraction")[-2:] 
print(line_g, well_g)

# Obtain Behaviour property value assigned for all wells in a list and display them
wells_behaviour= g_i.Wells.Behaviour.value
print(f'Wells Behaviour property: {wells_behaviour}')
```

# Python wrapper commands [WRITEPHASESTOMESH]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## writephasestomesh
Writes water and load conditions to files.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Writes the modified parts of the water and load conditions in one or more phases to the files used by the calculation kernel

# Creates a soil contour, borehole, soil layer and, soil material. Changes the mode and adds a line load. Generates the mesh
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Creates phases and activates a load line in phase1_s. Calculates this phase
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
phase2_s = g_i.phase(phase1_s)
g_i.LineLoads[-1].Active[phase1_s] = True
g_i.calculate(phase1_s)

# Writes modified parts of the water and load conditions in two phases
print(g_i.writephasestomesh(phase0_s, phase2_s))
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Writes all water and load conditions in one or more phases to the files used by the calculation kernel

# Creates a soil contour, borehole, soil layer and, soil material. Changes the mode and adds a line load. Generates the mesh
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Creates phases and activates a load line in phase1_s. Calculates this phase
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(g_i.Phases[0])
phase2_s = g_i.phase(phase1_s)
g_i.LineLoads[-1].Active[phase1_s] = True
g_i.calculate(phase0_s)

# Writes all water and load conditions in two phases regardless of whether they were changed
print(g_i.writephasestomesh((phase1_s, phase2_s), True))
```

---

```python
s_i.new()
```

---

```python
# Alternative 3
# Writes the modified parts of the water and load conditions in all phases to the files used by the calculation kernel

# Creates a soil contour, borehole, soil layer and, soil material. Changes the mode and adds a line load. Generates the mesh
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))

# Creates phases and activates a load line in phase1_s. Calculates this phase. Writes all water and load conditions in all phases
g_i.gotomesh()
g_i.mesh(0.2)
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(g_i.Phases[0])
phase2_s = g_i.phase(phase1_s)
g_i.LineLoads[-1].Active[phase1_s] = True
g_i.calculate(phase1_s)

print(g_i.writephasestomesh())
```

---

```python
s_i.new()
```

---

```python
# Alternative 4
# Writes all water and load conditions in all phases to the files used by the calculation kernel

# Creates a soil contour, borehole, soil layer and, soil material. Changes the mode and adds a line load. Generates the mesh
g_i.SoilContour.initializerectangular(0, 0, 10, 10)
borehole_g = g_i.borehole(0, 0)
g_i.soillayer(10)
material = g_i.soilmat()
material.setproperties("Identification", "Soil", "SoilModel", "Linear elastic", 
                       "gammaUnsat", 16, "gammaSat", 20, "Eref", 20000)
g_i.Soils[0].Material = material
g_i.gotostructures()
g_i.lineload((3, 5, 0), (7, 5, 0))
g_i.gotomesh()
g_i.mesh(0.2)

# Creates phases and activates a load line in phase1_s. Calculates all phases
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(g_i.Phases[0])
phase2_s = g_i.phase(phase1_s)
g_i.LineLoads[-1].Active[phase1_s] = True
g_i.calculate()

# Writes all water and load conditions in all phases regardless of whether they were changed
print(g_i.writephasestomesh(True))
```

# Python wrapper commands [ADD]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] # Creates Volume + Soil objects, the first one is the Volume object
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    polygons_g = g_i.decomposesrf(volume_g)[:-1] # Creates multiple objects, all except the last one are the Polygon objects

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## add
Adds a certain criteria object to a structural plot.

---

```python
s_i.new()
```

---

```python
# Alternative 1
# Adds a certain criteria object to a structural plot.

# Initialize the s_o, g_o variables
s_o, g_o = simple_test_case(s_i, g_i)

g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.calculate()
g_i.view(phase1_s)

g_o.cl((0, 0, 0), (1, 1, -2))
g_o.centerline((0, 4, -5), (12, 4, 0))
centerline_o = g_o.CenterLines[-1]

g_o.structuralforcesplot(g_o.Plots[-1])
plot_o = g_o.Plots[-1]

g_o.add(plot_o, centerline_o)
```

# Python wrapper commands [ADDCURVEPOINT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## addcurvepoint
Preselection of stress points or nodes for calculation results, with an indication of a preferred direction.

---

```python
# Alternative 1
# Preselection of stress points or nodes for calculation results.

s_o, g_o = simple_test_case(s_i, g_i)

g_i.gotostages()
g_i.selectmeshpoints()
g_o.addcurvepoint("node", (3, 5, 0))
g_o.update()
```

---

```python
# Alternative 2
# Preselection of stress points or nodes for calculation results.
s_o, g_o = simple_test_case(s_i, g_i)

g_i.gotostages()
soil_s = g_i.Soils[-1]

# Get the equivalent Soil entity in Output using get_equivalent command 
soil_o = get_equivalent(soil_s, g_o)

g_i.selectmeshpoints()
g_o.addcurvepoint("node", soil_o, (3, 5, -1))
```

---

```python
# Alternative 3
# Preselection of stress points or nodes for calculation results with an indication of a preferred direction for cases with multiple points near the specified coordinates.

s_o, g_o = simple_test_case(s_i, g_i)

g_i.gotostages()

g_i.selectmeshpoints()
g_o.addcurvepoint("node", (4, 4, -1), (0, 1, 0))
```

---

```python
# Alternative 4
# Preselection of stress points or nodes from an entity for calculation results with an indication of a preferred direction for cases with multiple points near the specified coordinates.

g_i.gotostages()
soil_s = g_i.Soils[-1]

# Get the equivalent Soil entity in Output using get_equivalent command 
soil_o = get_equivalent(soil_s, g_o)

g_i.selectmeshpoints()
g_o.addcurvepoint("node", soil_o, (4, 4, -5), (0, 0, 1))
```

---

```python
# Alternative 5
# Post-selection of the reference point of a rigid body entity for calculation results.

s_o, g_o = simple_test_case(s_i, g_i)

# Add a rigidbody
g_i.gotostructures()

polygon_g = g_i.surface((0, 0, 0), (1, 1, 0), (2, 0, 0))
rigidbody_g = g_i.rigidbody(polygon_g)

# Remeshing after changing geometry
g_i.gotomesh()
g_i.mesh(0.1)

g_i.gotostages()
rigidbody_s = g_i.Rigidbodies[-1]
rigidbody_s.activate(g_i.Phases[-1])

phase_1 = g_i.phase(g_i.InitialPhase)

# Perform calculation to generate rigid body results
g_i.calculate()
g_i.view(g_i.phase_1)

rigidbody_o = get_equivalent(rigidbody_s, g_o)
g_o.addcurvepoint(rigidbody_o)
```

# Python wrapper commands [ALLOCMEM]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## allocmem
Tests if it is possible to allocate a specific amount of additional memory.

---

```python
# Alternative 1
 
s_o, g_o = simple_test_case(s_i, g_i)

try:
    g_o.allocmem(64)  
except:
    print("Allocated 64 MB")
```

# Python wrapper commands [APPLY]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## apply
Applies a command to multiple objects at once.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.calculate()
g_i.view(phase1_s)

g_o.centerline((0, 4, -5), (6, 4, 0))
g_o.centerline((6, 4, 0), (12, 4, -5))

print(g_o.apply(g_o.CenterLines, "commands"))
```

---

```python
# Alternative 2
s_o, g_o = simple_test_case(s_i, g_i)

g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.calculate()
g_i.view(phase1_s)

g_o.centerline((0, 4, -5), (6, 4, 0))
g_o.centerline((6, 4, 0), (12, 4, -5))

centerlines_o = g_o.CenterLines
print(g_o.apply(centerlines_o, "setproperties", "Visible", False))
```

# Python wrapper commands [CENTERLINE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## centerline
Creates a centerline defined by a sequence of coordinates.

---

```python
s_i.new()
```

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.calculate()
g_i.view(phase1_s)

g_o.centerline((0, 4, -10), (12, 4, 0))
```

# Python wrapper commands [CENTERLINECONFIG]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## centerlineconfig
Creates configuration for centerlines.

---

```python
# Alternative 1
# Creates configuration for centerlines for a material.

s_o, g_o = simple_test_case(s_i, g_i)
material_i = g_i.Materials[-1]

# Change the mode and define the phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase1_s)

# Use get_equivalent function to obtain equivalent objects in Output
material_o = get_equivalent(material_i, g_o)
centerlinecriteriaobject_o = g_o.centerlineconfig(material_o)
print(centerlinecriteriaobject_o)
```

---

```python
s_i.new()
```

---

```python
# Alternative 2
# Creates configuration for centerlines for a material with a specified cluster.

# Creates a borehole, two soil layers and assigns materials to soil layers
g_i.borehole(0, 0)
g_i.soillayer(5)
g_i.soillayer(10)
material1_i = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
material2_i = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 2000)
g_i.Soils[-2].Material = material1_i
g_i.Soils[-1].Material = material2_i

# Changes the mode, generate the mesh and connect to Output application
g_i.gotomesh()
g_i.mesh(0.1)
output_port = g_i.viewmesh()
s_o, g_o = new_server('localhost', port=output_port, password=s_i.connection._password)

# Define the phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase1_s)
soil_s = g_i.Soils[-1]

# Use get_equivalent function to obtain equivalent objects in Output
material2_o = get_equivalent(material2_i, g_o)
soil_o = get_equivalent(soil_s, g_o)

centerlinecriteriaobject_o = g_o.centerlineconfig(material2_o, soil_o)
print(centerlinecriteriaobject_o)
```

# Python wrapper commands [CLEARCURVEPOINTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## clearcurvepoints
Clears the preselected curve points.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Change the mode to staged construction and add six curvepoints
g_i.gotostages()

for i in range (6):
    g_o.addcurvepoint("node", (i/2, 0, -i/2))
    
print(g_o.CurvePoints.echo())

# Obtain z coordinate of all Curvepoints in a list and display them
curvepoints_z = g_o.Curvepoints.z.value
print(f'Curvepoints z coordinates: {curvepoints_z}')

g_o.clearcurvepoints()
print(g_o.CurvePoints.echo())
```

# Python wrapper commands [CLOSE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## close
Closes output.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase1_s)

g_o.close()
```

# Python wrapper commands [COMMANDS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## commands
Displays available commands and their signatures.

---

```python
# Alternative 1
# Displays all available global commands for the current working mode with their corresponding signature(s).
s_o, g_o = simple_test_case(s_i, g_i)
print(g_o.commands())
```

---

```python
# Alternative 2
# Displays the signatures of one or more global commands.

# Example 1
print(g_o.commands("rename"))

# Example 2
print(g_o.commands("beam"))
```

---

```python
# Alternative 3
# Displays all available commands for a listable object with their signatures.

s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phase_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase_s)

g_o.centerline((0, 4, -10), (12, 4, 0))
centerline_o = g_o.CenterLines[-1]

print(centerline_o.Points.commands())
```

---

```python
# Alternative 4
# Displays the signatures of one or more global commands for a listable object.

print(g_o.commands(centerline_o.Points, "m"))
```

# Python wrapper commands [COUNT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## count
Displays the number of objects of a specified type that are present.

---

```python
# Alternative 1
# Counts the number of values in an object.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define the phases and add 8 curve points
g_i.gotostages()
phase_s = g_i.phase(g_i.InitialPhase)

for i in range (8):
    g_o.addcurvepoint("node", (i/2, 0, -i/2))
g_o.update()

g_i.calculate()
g_i.view(phase_s)

g_o.count(g_o.CurvePoints)
```

---

```python
# Alternative 2
# Counts the number of values in an object which fulfill a specified criterion.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define the phases and set maximum cores for some phases
g_i.gotostages()
phases_s = [g_i.phase(g_i.phases[0]) for i in range(4)]

phases_s[0].MaxCores = 1
phases_s[2].MaxCores = 1

g_i.calculate()
g_i.view(phases_s[-1])

g_o.count(phases_s, "Info.Maxcores=1")
```

# Python wrapper commands [crosssectionplot]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## crosssectionplot
Creates a plot for visualising cross section.

---

```python
# Alternative 1
# Creates a cross section plot using two points.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define the phases 
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase1_s)

plot1_o = g_o.Plots[-1]
plot1_o.ResultType = g_o.ResultTypes.Soil.SigmaEffective1
g_o.crosssectionplot(plot1_o, (0, 4, 0), (12, 4, 0))
```

---

```python
# Alternative 2
# Creates a plot for visualising cross section using three non-colinear points.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define the phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase1_s)

plot1_o = g_o.Plots[-1]
plot1_o.ResultType = g_o.ResultTypes.Soil.SigmaEffective1
g_o.crosssectionplot(plot1_o, (0, 4, 0), (12, 4, 0), (0, 4, 1))
```

# Python wrapper commands [DELETE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## delete
Deletes a plot or centerline.

---

```python
# Alternative 1
# Deletes a plot.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define the phases
g_i.gotostages()
phase_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase_s)
plot_o = g_o.Plots[-1]

g_o.structuralforcesplot(plot_o)
g_o.delete(plot_o)
```

---

```python
# Alternative 2
# Deletes a centerline.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define the phases
g_i.gotostages()
phase_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase_s)

g_o.cl((0, 4, -10), (12, 4, 0))
g_o.cl((0, 5, -10), (7, 4, 0))

centerline_o = g_o.CenterLines[-1]

g_o.delete(centerline_o)
```

# Python wrapper commands [dump]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## dump
Displays the details of the project.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define the phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.calculate()
g_i.view(phase1_s)

plot_o = g_o.Plots[-1]
g_o.dump()
```

# Python wrapper commands [ECHO]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## echo
Displays the details of an object.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define the phases
g_i.gotostages()
phases_s = [g_i.phase(g_i.phases[0]) for i in range(4)]

g_i.calculate()
g_i.view(phases_s[-1])

phases_o = g_o.Phases

print(g_o.echo(phases_o))
```

---

```python
# Alternative 2
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define the phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)

# Activate the lineload in Phase_1 and add curvepoints
lineload1_s = g_i.LineLoads[-1]
lineload1_s.activate(phase1_s)
curvepoint_o = g_o.addcurvepoint("node", (3, 5, 0))
g_o.update()

g_i.calculate()
g_i.view(phase1_s)

# Echo the results for total displacement in Phase_1
phase1_o = g_o.Phases[-1]
utotresults_o = g_o.getresults(phase1_o, g_o.ResultTypes.Soil.Utot, "node", True)
result_o = utotresults_o.filter("max")
result_o.echo()
```

# Python wrapper commands [EXPORT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## export
Exports a plot.

---

```python
# Alternative 1
# Exports the last created plot to a specified location.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase1_s)

g_o.Plots[-1].export(r"C:\data\image.png")
```

---

```python
# Alternative 2
# Exports a plot to a specified location and with a specific size.
g_i.gotostages()

g_o.Plots[-1].export(r"C:\data\image.png", 1920, 1080)
```

# Python wrapper commands [FILTER]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The input commands can be accessed from the "g_i" object and similarly, the output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, gS
```

---

## filter
Filters a list of specified objects.

---

```python
# Alternative 1
# Shows the contents of a list of objects.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phases_s = [g_i.phase(g_i.phases[0]) for i in range(4)]

g_i.calculate()
g_i.view(phases_s[-1])

phases_o = g_o.Phases
print(g_o.filter(phases_o))
```

---

```python
# Alternative 2
# Shows the item at the specified index.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phases_s = [g_i.phase(g_i.phases[0]) for i in range(4)]

g_i.calculate()
g_i.view(phases_s[-1])

phases_o = g_o.Phases
print(g_o.filter(phases_o, 1))
```

---

```python
# Alternative 3
# Shows a list of objects between two indices.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phases_s = [g_i.phase(g_i.phases[0]) for i in range(4)]

g_i.calculate()
g_i.view(phases_s[-1])

phases_o = g_o.Phases
print(g_o.filter(phases_o, 2, 4))
```

---

```python
# Alternative 4
# Shows a list of objects that fulfill a specified criterion.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phases_s = [g_i.phase(g_i.phases[0]) for i in range(4)]
phases_s[-1].MaxCores = 3
phases_s[-2].MaxCores = 1

g_i.calculate()
g_i.view(phases_s[-1])

# Shows the maximum value of the last element added to the Results listable. For example, this can follow the getresults command.
g_o.getresults(g_o.Phases[-1], g_o.ResultTypes.Soil.Utot, "node")
max_result = g_o.filter(g_o.Results[-1], "max")
print(*max_result)

# Shows the available phases with 1 maximum core.
phases_o = g_o.Phases
print(g_o.filter(phases_o, "info.MaxCores=1"))
```

# Python wrapper commands [GENERATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## generate
Generates a centerline.

---

```python
s_i.new()
```

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)
material_i = g_i.Materials[-1]

# Changes the mode and define phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.calculate()
g_i.view(phase1_s)

# Use get_equivalent function to obtain equivalent objects in Output
phase1_o = g_o.Phases[-1]
material_o = get_equivalent(material_i, g_o)

centerlinecriteriaobject_o = g_o.centerlineconfig(material_o)
g_o.generate(phase1_o, centerlinecriteriaobject_o)
```

# Python wrapper commands [GETCROSSSECTIONRESULTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g


def plate_rigid_body_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a rigid body on a plate and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotostructures()
    material_i = g_i.platemat("Identification", "Rigid_Body", "MaterialType", "Elastic", "Gamma", 25, "D3d", 0.05, "E1", 5000000, "StructNu12", 0.2) 
    g_i.plate((5, 3, 0), (5, 5, 0), (6, 5, 0), (6, 3, 0), "Material", material_i)
    
    rigidbody_1 = g_i.rigidbody(g_i.Surfaces[-1])
    rigidbody_1.Xref = 5.5
    rigidbody_1.Yref = 4
    rigidbody_1.TranslationConditionz = "Displacement"
    rigidbody_1.uz = -0.1

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("Identification", "Test", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## getcrosssectionresults
Generates a table with the calculation results of a specified cross section.

---

```python
# Alternative 1
# Generates a table with the calculation results of a specified cross section in a phase.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

phase1_o = g_o.Phases[-1]

plot1_o = g_o.Plots[0]
plot2_o = g_o.crosssectionplot(plot1_o, (0, 0, -0.5), (1, 0, -0.5), (0, 1, -0.5))

values_o = g_o.getcrosssectionresults(plot2_o, phase1_o, g_o.ResultTypes.Soil.Ux)
print(values_o, values_o.echo())
```

---

```python
# Alternative 2
# Generates a table with the calculation results of a specified cross section without result smooothing.
phase1_o = g_o.Phases[-1]

plot1_o = g_o.Plots[0]
plot2_o = g_o.crosssectionplot(plot1_o, (0, 0, -0.5), (1, 0, -0.5), (0, 1, -0.5))

values_o = g_o.getcrosssectionresults(plot2_o, phase1_o, g_o.ResultTypes.Soil.PActive, False)
print(values_o, values_o.echo())
```

# Python wrapper commands [GETCURVERESULTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## getcurveresults
Displays results for curve points that have been previously selected.

---

```python
# Alternative 1
# Example 1
s_o, g_o = dynamic_test_case(s_i, g_i)

g_i.gotostages()
phase1_s = g_i.Phases[-1]

g_i.selectmeshpoints()
g_o.addcurvepoint("node", (6, 3, -1))
g_o.update()
lineload_s = g_i.LineLoads[-1]
# Activate the Dynamic component of the LineLoad
lineload_s.LineLoad.activate(phase1_s)  

g_i.calculate()
g_i.view(phase1_s)

phase1_o = g_o.Phases[1]
curvepoint_o = g_o.CurvePoints[-1]

uz_o = g_o.getcurveresults(curvepoint_o , phase1_o, g_o.ResultTypes.Soil.Uz)
print(uz_o)

# Example 2

curvepoint_o = g_o.CurvePoints[-1]
print(g_o.getcurveresults(curvepoint_o, g_o.Steps[-1], g_o.ResultTypes.Soil.Uz))
```

---

```python
# Alternative 2
# Example 1

g_i.view(phase1_s)
g_o.addcurvepoint("node", (3, 5, -1))
g_o.addcurvepoint("node", (3, 4, -1))
g_o.addcurvepoint("node", (2, 2, -1))

phase1_o =  g_o.Phases[-1]
ux_o = g_o.getcurveresults(g_o.PostCalcNodes, phase1_o, g_o.ResultTypes.Soil.Ux, "max")
print(ux_o)

# Example 2

g_i.selectmeshpoints()
g_o.addcurvepoint("node", (6, 4, -2))
g_o.update()

curvepoint_o = g_o.CurvePoints[-1]
print(g_o.getcurveresults(curvepoint_o, g_o.Steps[-1], g_o.ResultTypes.Soil.Uz, "min"))
```

# Python wrapper commands [GETCURVERESULTSPATH]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## getcurveresultspath
Displays results for curve points that have been previously selected for several different phases.

---

```python
# Alternative 1
s_o, g_o = dynamic_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.Phases[-1]
phase2_s = g_i.phase(phase1_s)

# Add curvepoint, activate the lineloads in Phase_1 and Phase_2
g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (3, 5, 0))
g_o.update()

lineload_s = g_i.LineLoads[-1]
lineload_s.LineLoad.activate(phase1_s, phase2_s)

g_i.calculate()
g_i.view(phase1_s)

phase0_o = g_o.Phases[0]
phase1_o = g_o.Phases[1]
phase2_o = g_o.Phases[2]

value_o = g_o.getcurveresultspath(curvepoint_o, phase1_o, phase2_o, g_o.ResultTypes.Soil.Utot)
print(value_o, value_o.echo())
```

# Python wrapper commands [GETRESULTS]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g


def plate_rigid_body_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a rigid body on a plate and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotostructures()
    material_i = g_i.platemat("Identification", "Rigid_Body", "MaterialType", "Elastic", "Gamma", 25, "D3d", 0.05, "E1", 5000000, "StructNu12", 0.2) 
    g_i.plate((5, 3, 0), (5, 5, 0), (6, 5, 0), (6, 3, 0), "Material", material_i)
    
    rigidbody_1 = g_i.rigidbody(g_i.Surfaces[-1])
    rigidbody_1.Xref = 5.5
    rigidbody_1.Yref = 4
    rigidbody_1.TranslationConditionz = "Displacement"
    rigidbody_1.uz = -0.1

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("Identification", "Test", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## getresults
Generates a table with the calculation results.

---

```python
# Alternative 1
# Generates a table with the calculation results of a specified block in a phase.
s_o, g_o = suction_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase0_s.DeformCalcType = phase0_s.DeformCalcType.flowonly

# Activate boundary conditions
g_i.Geometry.activate(phase0_s)
g_i.set((g_i.GroundwaterFlow.BoundaryYMin, g_i.GroundwaterFlow.BoundaryYMax), phase0_s, "Closed")

g_i.calculate()
g_i.view(phase0_s)

phase0_o = g_o.Phases[0]
values_o = g_o.getresults(phase0_o, g_o.ResultTypes.Soil.Suction, "stresspoint")
print(values_o, values_o.echo())
```

---

```python
# Alternative 2
# Generates a table with the calculation results of a specified block with result smooothing.

g_i.gotostages()
phase0_s = g_i.InitialPhase
g_i.view(phase0_s)

phase0_o = g_o.Phases[0]
values_o = g_o.getresults(phase0_o, g_o.ResultTypes.Soil.Suction, "node", True)
print(values_o, values_o.echo())
```

---

```python
# Alternative 3
# Generates a table with the calculation results of a specified block in a phase.
s_o, g_o = beam_test_case(s_i, g_i)

# Changes the mode, define the phases and activate the beams and lineloads
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
beam_s = g_i.Beams[-1]

g_i.LineLoads.activate(phase1_s)
beam_s.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

# Use get_equivalent function to get equivalent objects in Output
phase1_o = g_o.Phases[1]
beam_o = get_equivalent(beam_s, g_o)

values_o = g_o.getresults(beam_o, phase1_o, g_o.ResultTypes.Beam.Uz, "node")
print(values_o, values_o.echo())
```

---

```python
# Alternative 4
# Generates a table with the calculation results of a specified block in a phase without result smoothing.
phase1_o = g_o.Phases[1]

values_o = g_o.getresults(beam_o, phase1_o, g_o.ResultTypes.Beam.Uz, "node", False) 
print(values_o, values_o.echo())
```

---

```python
# Alternative 5
# Generates a table with the calculation results of a specified centerline in a phase.
s_o, g_o =  simple_test_case(s_i, g_i)

# Changes the mode, define the phases and activate the line loads
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

g_o.centerline((0, 4, -10), (12, 4, 0))
centerline_o = g_o.CenterLines[-1]
g_o.structuralforcesplot(g_o.Plots[-1])

g_o.add(g_o.Plots[-1], g_o.Centerlines[-1])

phase1_o = g_o.Phases[1]
values_o = g_o.getresults(centerline_o, phase1_o, g_o.ResultTypes.CenterLine.M2)
print(values_o, values_o.echo())
```

---

```python
# Alternative 6
# Generates a table with the calculation results of a specified block for the active phase.
s_o, g_o =  simple_test_case(s_i, g_i)

# Changes the mode, define the phases and activate the line loads
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

lineload_s = g_i.LineLoads[-1]

lineload_s.qx_start.set(phase1_s, -300)
lineload_s.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

values_o = g_o.getresults(g_o.ResultTypes.Soil.Ux, "node")
print(values_o, values_o.echo())
```

---

```python
# Alternative 7
# Generates a table with the calculation results of a specified block for the active phase with result smoothing.

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.Phases[-1]

g_i.view(phase1_s)

values_o = g_o.getresults(g_o.ResultTypes.Soil.Utot, "node", True)
print(values_o, values_o.echo())
```

---

```python
# Alternative 8
# Generates a table with the calculation results of a specified block for the active phase.
s_o, g_o = beam_test_case(s_i, g_i)

# Changes the mode, define the phases and activate the line loads, beams
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.LineLoads.activate(phase1_s)
g_i.Beams.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

beam_o = g_o.Beams[-1]
values_o = g_o.getresults(beam_o, g_o.ResultTypes.Beam.Utot, "node")
print(values_o, values_o.echo())
```

---

```python
# Alternative 9
# Generates a table with the calculation results of a specified block for the active phase with result smoothing.

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.Phases[-1]
beam_s = g_i.Beams[-1]

g_i.view(phase1_s)
beam_o = get_equivalent(beam_s, g_o)

values_o = g_o.getresults(beam_o, g_o.ResultTypes.Beam.Utot, "node", True)
print(values_o, values_o.echo())
```

---

```python
# Alternative 10
# Retrieves the vertical deformations of a rigid body.
s_o, g_o = plate_rigid_body_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.Model.CurrentPhase = phase1_s

# Activate rigid body
g_i.activate(g_i.Surfaces[-1], phase1_s)

# Calculate and retrieve results
g_i.calculate()
g_i.view(phase1_s)

phase1_o = g_o.Phases[-1]
values_o = g_o.getresults(phase1_o, g_o.ResultTypes.RigidBody.Uz, "node")
print(values_o, values_o.echo())
```

# Python wrapper commands [GETSINGLERESULT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## getsingleresult
Gives the result at the specified coordinate or a specific node/stress point with or without result smoothing.

---

```python
# Alternative 1
# Gives the result at a specific node or stress point.

s_o, g_o = suction_test_case(s_i, g_i)

# Add curvepoints, define phases and activate the boundary conditions
g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (4, 0.5, 1.8))
g_o.update()

g_i.gotostages()
phase0_s = g_i.InitialPhase
phase0_s.DeformCalcType = phase0_s.DeformCalcType.flowonly
g_i.Geometry.activate(phase0_s)
g_i.set((g_i.GroundwaterFlow.BoundaryYMin, g_i.GroundwaterFlow.BoundaryYMax), phase0_s, "Closed")

g_i.calculate()
g_i.view(phase0_s)

phase0_o = g_o.Phases[0]
value_o = g_o.getsingleresult(phase0_o, g_o.ResultTypes.Soil.Suction, curvepoint_o)
print(value_o)
```

---

```python
# Alternative 2
# Gives the result at a specific node or stress point with or without result smoothing.

value_o = g_o.getsingleresult(phase0_o, g_o.ResultTypes.Soil.Suction, curvepoint_o, True)
print(value_o)
```

---

```python
# Alternative 3
# Gives the result at a specified coordinate.

value_o = g_o.getsingleresult(phase0_o, g_o.ResultTypes.Soil.Saturation, (4, 0.5, 1.75))
print(value_o)
```

---

```python
# Alternative 4
# Gives the result at a specified coordinate with or without result smoothing.

value_o = g_o.getsingleresult(phase0_o, g_o.ResultTypes.Soil.Saturation, (4, 0.5, 1.75), False)
print(value_o)
```

---

```python
# Alternative 5
# Gives the result at a specified coordinate with or without result smoothing along a preferred direction.

value_o = g_o.getsingleresult(phase0_o, g_o.ResultTypes.Soil.Suction, (4, 0.5, 1.6), True, (1, 0, 0))
print(value_o)
```

---

```python
# Alternative 6
# Gives the result at a specified coordinate on the update geometry of the mesh with or without result smoothing along a preferred direction.

value_o = g_o.getsingleresult(phase0_o, g_o.ResultTypes.Soil.Suction, (4, 0.5, 1.6), False, (1, 0, 0), True)
print(value_o)
```

# Python wrapper commands [HIDE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## hide
Hides elements in a plot.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define the phases and activate the lineload
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
lineload_s = g_i.LineLoads[-1]
lineload_s.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

lineload_o = g_o.LineLoads[-1]
g_o.Plots[-1].hide(lineload_o)
```

# Python wrapper commands [INDEX]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("Identification", "Strut", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## index
Displays the value at the given index.

---

```python
# Alternative 1
# Displays the value at the given index.
s_o, g_o = beam_test_case(s_i, g_i)

# Changes the mode, define the phases, adds a curvepoint and activate the lineloads and beams
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (8, 4, -1))
g_o.update()
g_i.LineLoads.activate(phase1_s)
g_i.Beams.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

beam_o = g_o.Beams[-1]
value_o = g_o.getresults(beam_o, g_o.ResultTypes.Beam.Utot, "node")
print(value_o.index(5), value_o[5])
```

# Python wrapper commands [INFO]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("Identification", "Strut", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## info
Displays all commands and attributes for an object.

---

```python
# Alternative 1
# Displays all commands and attributes for an object.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define the phases
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)

g_i.calculate()
g_i.view(phase1_s)

print(g_o.LineLoads.info())
```

# Python wrapper commands [LINECROSSSECTIONPLOT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## linecrosssectionplot
Creates a cross section plot defined by a line between two specified points.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define the phases and activate lineloads
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

g_o.linecrosssectionplot(g_o.Plots[-1], (5, 1, 1), (10, 1, -4))
```

# Python wrapper commands [RAISE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## raise
Generates an error in order to test the error catching functionality.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

try:
    g_o.raise_()
except:
    print("Exception raised")
```

# Python wrapper commands [RAISEASYNC]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## raiseasync
Generates an error in an asynchronous thread in order to test the error catching functionality.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

try:
    g_o.raiseasync()
except:
    print("Exception raised")
```

# Python wrapper commands [RAISETHREADED]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## raisethreaded
Generates an error in a synchronous thread in order to test the error catching functionality.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

try:
    g_o.raisethreaded()    
except:
    print("Exception raised")
```

# Python wrapper commands [RENAME]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## rename
Renames an object.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define the phases and activates the lineload
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

plot_o = g_o.Plots[-1]
plot_o.rename("DeformedMesh")
```

# Python wrapper commands [REPORTMEM]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## reportmem
Reports memory usage.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

g_o.reportmem()
```

# Python wrapper commands [SET]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## set
Sets one or more properties of one or more objects

---

```python
# Alternative 1
# Copies the properties of one object to another.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define phases and activates the lineload
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

plot1_o = g_o.Plots[-1]
plot2_o = g_o.sfplt(plot1_o)

plot2_o.set(plot1_o)
```

---

```python
# Alternative 2
# Changes a numerical property of an object.

plot_o = g_o.Plots[-1]
plot_o.ScaleFactor.set(50)
```

---

```python
# Alternative 3
# Changes a numerical property of an object.

plot1_o = g_o.Plots[-1]
plot2_o = g_o.Plots[-2]
plot1_o.ScaleFactor.set(plot2_o.ScaleFactor)
```

---

```python
# Alternative 4
# Changes an integer property of an object.

plot_o = g_o.Plots[-1]
plot_o.LegendSettings.Intervals.set(5)
```

---

```python
# Alternative 5
# Changes a text property of an object.

plot_o = g_o.Plots[-1]
plot_o.ProjectDescription.set("Excavation")
```

# Python wrapper commands [SETPHYSICALCPUCOUNT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## setphysicalcpucount
Displays or sets the amount of physical and logical CPUs.

---

```python
# Alternative 1
# Displays the amount of physical and logical CPUs.
s_o, g_o = simple_test_case(s_i, g_i)

print(g_o.setphysicalcpucount())
```

---

```python
# Alternative 2
# Sets the amount of physical and logical CPUs.

print(g_o.setphysicalcpucount(3))
```

# Python wrapper commands [SETPROPERTIES]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## setproperties
Changes properties of objects.

---

```python
# Alternative 1
# Example 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define phases and activate lineloads
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

g_o.centerline((0, 4, -10), (12, 4, 0))
g_o.structuralforcesplot(g_o.Plots[-1])

centerline_o = g_o.CenterLines[-1]
centerline_o.setproperties("Visible", False)

# Example 2
plot_o = g_o.Plots[-1]
plot_o.setproperties("ScaleFactor", 50)
```

# Python wrapper commands [SHOW]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## show
Shows elements in a plot

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define phases and activates the lineload
g_i.gotostages()
phase1_s = g_i.phase(g_i.InitialPhase)
g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

lineload_o = g_o.LineLoads[-1]
g_o.Plots[-1].hide(lineload_o)

g_o.Plots[-1].show(lineload_o)
```

# Python wrapper commands [SLEEP]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## sleep
This command makes the application to do nothing for the specified number of milliseconds.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)
g_o.sleep(2000)
```

# Python wrapper commands [SLICE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## slice
Selects results from a list of objects with a specified criterion.

---

```python
# Alternative 1
# Copies full list of values from the object and creates a new object.

s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define phases, adds a curvepoint and activates a line load 
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (8, 4, -1))
g_o.update()
g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)
values_o = g_o.getresults(g_o.ResultTypes.Soil.Utot, "node", True)

slicedvalues_o = values_o.slice()
print(slicedvalues_o, values_o)
```

---

```python
# Alternative 2
# Selects results from a list of objects starting from a specified index.

slicedvalues_o = values_o.slice(10)
print(slicedvalues_o)
```

---

```python
# Alternative 3
# Selects results from a list of objects with a specific range of indicies.

slicedvalues_o = values_o.slice(1, 3)
print(slicedvalues_o)
```

# Python wrapper commands [STRUCTURALFORCESPLOT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("Identification", "Strut", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## structuralforcesplot
Creates a forces plot for structural elements.

---

```python
# Alternative 1
s_o, g_o = beam_test_case(s_i, g_i)

# Changes the mode, define phases, adds a curvepoint and activate the lineloads, beams
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (8, 4, -1))
g_o.update()
g_i.LineLoads.activate(phase1_s)
g_i.Beams.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

beam_o = g_o.Beams[-1]

plot_o = g_o.structureplot(beam_o)
g_o.structuralforcesplot(plot_o)
```

# Python wrapper commands [STRUCTUREPLOT]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("Identification", "Strut", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## structureplot
Creates a plot for structural elements.

---

```python
# Alternative 1
s_o, g_o = beam_test_case(s_i, g_i)

# Changes the mode, define phases, adds a curvepoint and activate lineloads, beams
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (8, 4, -1))
g_o.update()
g_i.LineLoads.activate(phase1_s)
g_i.Beams.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

beam_o = g_o.Beams[-1]

g_o.structureplot(beam_o)
```

# Python wrapper commands [TABULATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("Identification", "Strut", "MaterialType", "Elastic", "Gamma", 78.5, "CrossSectionType", "User-defined", "A", 0.007367, "E", 210000000, "I2", 5.073E-5, "I3", 5.073E-5) 
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## tabulate
Displays a table with specified objects and their properties.

---

```python
# Alternative 1
# Displays a table with specified objects and their properties.

# Example 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, define phases, add curvepoints and activate line loads
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.selectmeshpoints()
curvepoint1_o = g_o.addcurvepoint("node", (8, 4, -1))
curvepoint2_o = g_o.addcurvepoint("node", (8, 4, -3))
g_o.update()
g_i.LineLoads.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

plots_o = g_o.Plots
print(g_o.tabulate(plots_o))

# Example 2
g_o.centerline((0, 4, -10), (12, 4, 0))
g_o.centerline((0, 4, -4), (12, 4, -4))

centerlines_o = g_o.CenterLines
print(g_o.tabulate(centerlines_o))

# Example 3

curvepoints_o = g_o.CurvePoints
print(g_o.tabulate(curvepoints_o))
```

---

```python
# Alternative 2
# Displays a table with specified objects and some of their properties.

# Example 1
s_o, g_o = beam_test_case(s_i, g_i)

# Changes the mode, define phases, add curvepoints and activate line loads, beamss
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (8, 4, -1))
g_o.update()
g_i.LineLoads.activate(phase1_s)
g_i.Beams.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

beam_s = g_i.Beams[-1]
g_o.structureplot(beam_s)

plots_o = g_o.Plots
print(g_o.tabulate(plots_o, "ResultType"))

# Example 2
g_o.centerline((0, 4, -10), (12, 4, 0))

material_o = g_o.Materials[-2]

centerlinecriteriaobject = g_o.centerlineconfig(material_o)
centerlinecriteriaobject.xmin_symmetry = False
centerlinecriteriaobject.xmax_symmetry = False
centerlinecriteriaobject.ymin_symmetry = False
centerlinecriteriaobject.ymax_symmetry = False

g_o.add(g_o.Plots[-1], centerlinecriteriaobject)
g_o.generate(phase1_s, centerlinecriteriaobject)

centerlines_o = g_o.CenterLines
print(g_o.tabulate(centerlines_o, "CenterLineType"))

# Example 3
g_o.addcurvepoint("stresspoint", (5, 4, -2))

curvepoints_o = g_o.CurvePoints
print(g_o.tabulate(curvepoints_o, "x y z"))
```

---

```python
# Alternative 3
# Displays a table with specified objects that fulfill a specified condition, and some of their properties.

# Example 1
g_o.Plots[-1].ScaleFactor = 50
print(g_o.tabulate(plots_o, "ResultType", "ScaleFactor=50"))

# Example 2

print(g_o.tabulate(curvepoints_o, "x", "PointType != Stress Point"))

# Example 3
g_o.addcurvepoint("stresspoint", (5, 4, -2))

print(g_o.tabulate(curvepoints_o, "x y z", "z<-1"))
```

# Python wrapper commands [TESTASYNC]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## testasync
Tests that asynchronous task execution works correctly.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)
g_o.testasync(30)
```

# Python wrapper commands [UPDATE]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## update
Saves the selected curve points and closes output.

---

```python
# Alternative 1
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode, adds a curvepoint and saves them
g_i.gotostages()

g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (8, 4, -1))

g_o.update()
```

# Python wrapper commands [view]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## view
Changes the view of a plot.

---

```python
# Alternative 1
# Changes the view of a plot to the specified viewpoint.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and adds a curvepoint
g_i.gotostages()
g_i.selectmeshpoints()
curvepoint_o = g_o.addcurvepoint("node", (8, 4, -1))

plot_o = g_o.Plots[-1]
plot_o.view("top")
```

---

```python
# Alternative 2
# Changes the view of a plot to the viewpoint to make it look in the direction of the given vector.

plot_o.view(1, 1, 1)
```

# Python wrapper commands [zoom]
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((4, 4, 0), (9, 4, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

    
def dynamic_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, generate the mesh and add a 
    dynamic calculation phase
    """
    create_geometry(s_i, g_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    g_i.gotostages()
    phase1_s = g_i.phase(g_i.InitialPhase)
    phase1_s.DeformCalcType = phase1_s.DeformCalcType.dynamic
    phase1_s.Deform.TimeIntervalSeconds = 2
    phase1_s.MaxStepsStored = 5
    
    return s, g
```

---

```python
def beam_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    material_i = g_i.beammat("E", 30E6, "w", 6, "A", 0.7, "Izz", 0.029, "Iyy", 0.058)
    g_i.beam((4, 4, -1), (9, 4, -1), "Material", material_i)

    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g


def suction_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features, add groundwater flow boundary conditions 
    and generate the mesh
    """
    s_i.new()

    g_i.SoilContour.initializerectangular(0, 0, 10, 1)
    material_i = g_i.soilmat("Identification", "Test", "SoilModel", "Linear Elastic", "gammaUnsat", 15, "gammaSat", 15, "Eref", 1000, "PermHorizontalPrimary", 1, "PermHorizontalSecondary", 1, "PermVertical", 1)

    polygon_g = g_i.surface((0, 0, 0), (0, 0, 3), (10, 0, 3), (10, 0, 0))
    # Creates multiple objects, the first one is the Volume object
    volume_g = g_i.extrude(polygon_g, (0, 1, 0))[0] 
    g_i.delete(polygon_g)

    g_i.Soils[0].Material = material_i
    # Creates multiple objects, all except the last one are the Polygon objects
    polygons_g = g_i.decomposesrf(volume_g)[:-1]

    surfgwflowbc1_g = g_i.surfgwfbc(polygons_g[-3], "Behaviour", "Head", "Href", 1)
    surfgwflowbc2_g = g_i.surfgwfbc(polygons_g[-4], "Behaviour", "Head", "Href", 2)
    surfgwflowbc3_g = g_i.surfgwfbc(polygons_g[-1], "Behaviour", "Closed")

    g_i.gotomesh()
    surfaces_s = g_i.Surfaces
    surfaces_s[-3].CoarsenessFactor = 1
    surfaces_s[-3].CoarsenessFactor = 0.25
    
    g_i.mesh(10, 256, False)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    return s, g
```

---

## zoom
Zooms in a plot.

---

```python
# Alternative 1
# Zooms in a plot.
s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and previews the last phase
g_i.gotostages()
g_i.preview(g_i.Phases[-1])

plot_o = g_o.Plots[-1]

plot_o.zoom()
```

---

```python
# Alternative 2
# Zooms in a plot centering to a geometric entity.

plot_o.zoom(g_i.Lines[0])
```

---

```python
# Alternative 3
# Zooms in a plot. The defined point specifies where the viewpoint should centre on while keeping the same distance from the mesh.

plot_o.zoom(0, 0, 0)
```

---

```python
# Alternative 4
# Zooms in a plot. The defined points specify a bounding box on which the viewpoint focuses.

plot_o.zoom((0, 0, 0), (12, 8, -2))
```

# Python wrapper commands [GET_EQUIVALENT]

---

The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

## get_equivalent (ge)
Returns the equivalent staged construction object if provided with a geometry object or vice versa.
Can also be used to get objects from a different environment(i.e. Input and Output) by providing the second argument.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, a plate on a surface 
    and returns the plate object in Structures mode (plate_g)
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    
    g_i.gotostructures()
    material_i = g_i.platemat("Identification", "Foundation", "MaterialType", "Elastic", "Gamma", 25, "d", 0.05, "E1", 5000000, "StructNu12", 0.2)
    surface_g = g_i.surface((5, 3, 0), (5, 5, 0), (6, 5, 0), (6, 3, 0))
    plate_g = g_i.plate(surface_g, "Material", material_i)
    
    
    return plate_g
```

---

```python
# Create the geometry and confirm that the get_equivalent returns the correct object in the same mode
plate_g = create_geometry(s_i, g_i)

g_i.gotostructures()
g_i.get_equivalent(plate_g) == plate_g  # True as these are the same object in the Structures mode
```

---

```python
# Identifies the equivalent object from Structures to Staged construction mode.

g_i.gotostages()

plate_s = g_i.get_equivalent(plate_g)  # gets the equivalent staged construction plate object for plate_g
g_i.get_equivalent(plate_s) == plate_s  # True as plate_s is identical to the plate object in Staged construction
```

---

```python
# Map the plate object to the equivalent in Mesh mode and apply a mesh coarsness to the parent object
g_i.gotostructures()
plate_g = g_i.Plates[-1]

g_i.gotomesh() 

plate_staged = get_equivalent(plate_g) # gets the equivalent plate object after intersection in Mesh mode for plate_g

# For-loop required as the plate after intersection can be split in multiple parts
for plate_piece in plate_staged: 
    plate_piece.Parent.CoarsenessFactor = 0.2345
```

# Python wrapper commands [GET_EQUIVALENT]

---

The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

## get_equivalent (ge)
Returns the equivalent staged construction object if provided with a geometry object or vice versa.
Can also be used to get objects from a different environment(i.e. Input and Output) by providing the second argument.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, a plate on a surface 
    and returns the plate object in Structures mode (plate_g)
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    
    g_i.gotostructures()
    material_i = g_i.platemat("Identification", "Foundation", "MaterialType", "Elastic", "Gamma", 25, "D3d" 0.05, "E1", 5000000, "StructNu12", 0.2)
    surface_g = g_i.surface((5, 3, 0), (5, 5, 0), (6, 5, 0), (6, 3, 0))
    plate_g = g_i.plate(surface_g, "Material", material_i)
    
    
    return plate_g
```

---

```python
# Create the geometry, generate a mesh and add a new phase with plate activated
plate_g = create_geometry(s_i, g_i)

g_i.gotomesh()
g_i.mesh(0.1)
   
g_i.gotostages()
plate_s = g_i.get_equivalent(plate_g)  # gets the equivalent staged construction plate object for plate_g

phase_1 = g_i.phase(g_i.Phases[-1])
g_i.activate(plate_s, phase_1)

# Add the phases names from Input to a list and print them
phase_i_names = [phase.Name.value for phase in g_i.Phases]
print(phase_i_names, '<- Phase names in Input')

# Run the analysis
g_i.calculate()

# Launch Output program
output_port = g_i.view(phase_1)
s_o, g_o = new_server('localhost', port=output_port, password=s_i.connection._password)

# Get the equivalent phase objects from Input in Output
phases_o = [ge(phase_s, g_o) for phase_s in g_i.Phases]

# Add the phases names from Output to a list and print them 
phase_o_names = [phase.Name.value for phase in phases_o]
print(phase_o_names, '<- Phase names in Output should be the same as Input')
```

# Appendix H -  Sample scripts - PLAXIS 3D Input
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment.

---

The following sample scripts cover some of the code samples provided in *Appendix H - Python HTTP REST API wrapper* of the PLAXIS reference manual

---

### Removing all lines containing beams

---

```python
s_i.new()
g_i.gotostructures()

# Create three lines
line1_g = g_i.line((0, 0, 0), (3, 0, 0))[-1]
line2_g = g_i.line((5, 0, 0), (5, 5, 0))[-1]
line3_g = g_i.line((0, 8, 0), (3, 4, 0))[-1]

# Assign beams to two of the lines
beam1_g = g_i.beam(line1_g)
beam2_g = g_i.beam(line2_g)

# Create a list of only the lines that have a beam as a user feature.
lines = [b.Parent for b in g_i.Beams]

# Delete the contents of the created list
print(g_i.delete(*lines))
```

---

### Reporting all points that are not used by lines and have no features

---

```python
s_i.new()
g_i.gotostructures()

# Create two lines and two points
line1_g = g_i.line((0, 0, 0), (3, 0, 0))[-1]
line2_g = g_i.line((5, 0, 0), (5, 5, 0))[-1]
point1_g = g_i.point(3, 4, 0)
point2_g = g_i.point(1, 1, 0)

# Add a point load to one of the points
pointload_g = g_i.pointload(point1_g)

# Create a set to be used later on
points_in_lines = set()

# Main code
for line in g_i.Lines[:]:
    for point in line:
        points_in_lines.add(point)
        points = set(g_i.Points)
        points_no_lines = points - points_in_lines
        points_to_report = []
        for p in points_no_lines:
            if len(p.UserFeatures.value) == 0:
                points_to_report.append(p)

# Print the points stored in the set                
for p in points_to_report:
    print(p.Name)
```

---

### Creating an array, storing the results and performing actions on the diagonal

---

```python
s_i.new()
g_i.gotostructures()

# Create a reference point and use the array command
point = g_i.point(0, 0, 0)
added_points = g_i.arrayr(point, 6, (1, 0, 0), 6, (0, 1, 0))

# Main code
diagonal_points = []
for p in added_points:
    if abs(p.x - p.y) < 1E-4:
        diagonal_points.append(p)
g_i.pointload(diagonal_points)
```

---

### Lengthening all the embedded beams in a model

---

```python
s_i.new()
g_i.gotostructures()

# Create a reference embedded beam and use the array command
res = g_i.embeddedbeam((0, 0, 0), (0, 0, -15))
line = [item for item in res if item._plx_type=='Line'][0]
g_i.arrayr(line, 5, (1, 0, 0))

# Function to find the bottom point of the embedded beam
def get_bottom_point(line):
    first, second = line.First, line.Second
    delta = second.z - first.z
    if abs(delta) < 1E-4: # horizontal line
        return None
    if delta > 0: # Second point is higher -> move First down
        return first
    else: # First point is higher -> move Second down
        return second

# Function to lengthen the embedded beams    
def lengthen_embedded_beams(extra_depth):
    # start by selecting the lines which have embedded beams
    pile_lines = [pile.Parent for pile in g_i.EmbeddedBeams[:]]
    # we don't know whether the line is drawn top-to-bottom
    # or bottom-to-top, so find out which point is lowest
    points_to_move = []
    for line in pile_lines:
        bottom_point = get_bottom_point(line)
        if bottom_point:
            points_to_move.append(bottom_point)
            g_i.move(points_to_move, (0, 0, -extra_depth,))

# Call the function with the parameter 2.5m
lengthen_embedded_beams(2.5)
```

---

### Making all plates in all phases have identical settings in staged construction

---

```python
s_i.new()
g_i.gotostructures()

# Create polygons, assign plates and materials
polygon1_g = g_i.surface((0, 0, 0), (0, 1, 0), (1, 1, 0), (1, 0, 0))
polygon2_g = g_i.surface((2, 0, 0), (2, 3, 0), (3, 3, 0), (3, 0, 0))
polygon3_g = g_i.surface((4, 0, 0), (4, 1, 0), (5, 1, 0), (5, 0, 0))
plate1_g = g_i.plate(polygon1_g)
plate2_g = g_i.plate(polygon2_g)
plate3_g = g_i.plate(polygon3_g)

plate1_mat = g_i.platemat("Identification", "Example 1", "MaterialType", "Elastic", "E1", 100000, "D3d", 0.1, "StructNu12", 0.2) 
plate2_mat = g_i.platemat("Identification", "Example 2", "MaterialType", "Elastic", "E1", 100000, "D3d", 0.1, "StructNu12", 0.2) 
plate3_mat = g_i.platemat("Identification", "Example 3", "MaterialType", "Elastic", "E1", 100000, "D3d", 0.1, "StructNu12", 0.2) 

g_i.setmaterial(polygon1_g.Plate, plate1_mat)
g_i.setmaterial(polygon2_g.Plate, plate2_mat)
g_i.setmaterial(polygon3_g.Plate, plate3_mat)

# Define phases in Staged construction
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.setcurrentphase(phase1_s)
g_i.activate(g_i.Plate_1_1, g_i.Phase_1)
phase2_s = g_i.phase(phase1_s)
g_i.setcurrentphase(phase2_s)

# Define function to retrieve the plate material per phase
def print_phase_platemat():
    for phase in g_i.Phases:
        print(phase.Name)
        for plate in g_i.Plates:
            print(plate.Material[phase].Name)

# Check current status
print("Before main code:")
print_phase_platemat()

# Main code
refplate = g_i.Plates[0]
otherplates = g_i.Plates[1:]
for phase in g_i.Phases:
    if refplate.Active[phase] is None: # phase not yet initialized
        continue
    for otherplate in otherplates:
        otherplate.Material[phase] = refplate.Material[phase]
        otherplate.Active[phase] = refplate.Active[phase]

# Check current status       
print("After main code:")
print_phase_platemat()
```

---

### Create safety phase after every consolidation phase

---

```python
s_i.new()

# Create a borehole and single soil layer
g_i.borehole(0, 0)
g_i.soillayer(1)

# Define phases in Staged construction with some phases set to Consolidation
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)
g_i.setcurrentphase(phase1_s)
phase2_s = g_i.phase(phase1_s)
g_i.setcurrentphase(phase2_s)
phase2_s.DeformCalcType = phase2_s.DeformCalcType.consolidation
phase3_s = g_i.phase(phase2_s)
g_i.setcurrentphase(phase3_s)
phase3_s.DeformCalcType = phase3_s.DeformCalcType.consolidation
phase4_s = g_i.phase(phase3_s)
g_i.setcurrentphase(phase4_s)
phase4_s.DeformCalcType = phase4_s.DeformCalcType.consolidation

# Main code
for phase in g_i.Phases[:]:
    if phase.DeformCalcType == phase.DeformCalcType.consolidation:
        newphase = g_i.phase(phase)
        newphase.DeformCalcType = newphase.DeformCalcType.safety
```

---

### Creating a polar array of inclined piles

---

```python
from math import radians, sin, cos

s_i.new()
g_i.gotostructures()

# Main code
# Input parameters
nr_pilerows = 4 # must be > 1
total_angle_deg = 180 # over which to distribute the piles, must be > 0 and <= 360
pilerow_length = 10
pilerow_inclination_deg = 15
array_center = (5, 0, 0)
array_radius = 10

# Calculations
def rel_coords_to_absolute(rel_coords, radius, offset):
    coords = [radius * coord for coord in rel_coords]
    return [p[0] + p[1] for p in zip(coords, offset)]

if total_angle_deg == 360: # fencepost problem -> decrease angle
    total_angle_deg = total_angle_deg / (nr_pilerows) * (nr_pilerows - 1)

pilerow_inclination_rad = radians(pilerow_inclination_deg)

array_bottom_radius = array_radius + pilerow_length * sin(pilerow_inclination_rad)
array_bottom_center = (array_center[0], array_center[1], array_center[2] - pilerow_length * cos(pilerow_inclination_rad))

pilerow_coords = []
for i in range(nr_pilerows):
    angle = radians(total_angle_deg * i / (nr_pilerows - 1))
    rel_coords = [cos(angle), sin(angle), 0]
    top_coords = rel_coords_to_absolute(rel_coords, array_radius, array_center)
    bottom_coords = rel_coords_to_absolute(rel_coords, array_bottom_radius, array_bottom_center)
    pilerow_coords.append((top_coords, bottom_coords))
    for coords_pair in pilerow_coords:
        g_i.embeddedbeam(*coords_pair)
```

---

### Creating a group of embedded beams that are assigned to a specific material

---

```python
s_i.new()

g_i.borehole(0, 0)
g_i.soillayer(10)

# Create a group in Structures mode
g_i.gotostructures()

shortpile = g_i.embeddedbeammat("Identification", "ShortPile", "MaterialType", "Elastic", "Gamma", 24, "E", 10000000, "Diameter", 0.25, "LSpacing", 3, "TSkinStartMax", 1, "TSkinEndMax", 100, "FMax", 100)
longpile = g_i.embeddedbeammat("Identification", "LongPile", "MaterialType", "Elastic", "Colour", 1006087, "Gamma", 24, "E", 10000000, "Diameter", 0.25, "LSpacing", 3, "TSkinStartMax", 1, "TSkinEndMax", 100, "FMax", 100)

g_i.embeddedbeam((4, 4, 0), (4, 4, -5))
g_i.embeddedbeam((6, 4, 0), (6, 4, -7))
g_i.embeddedbeam((8, 4, 0), (8, 4, -6))

g_i.EmbeddedBeams[0].Material = shortpile
g_i.EmbeddedBeams[1].Material = longpile
g_i.EmbeddedBeams[-1].Material = longpile

piles_short = []
for pile in g_i.EmbeddedBeams:
    if pile.Material.value == shortpile:
        piles_short.append(pile)    

print(piles_short)
for pile in piles_short:
    print(pile.Name.value)

# Switch to Staged construction and create a new group
g_i.gotostages()
g_i.phase(g_i.Phases[-1])  # create a phase after InitialPhase
g_i.setcurrentphase(g_i.Phases[-1])

piles_long = []
for pile in g_i.EmbeddedBeams:
    if pile.Material.value == longpile:
        piles_long.append(pile)    

print(piles_long)
for pile in piles_long:
    print(pile.Name.value)
    pile.activate(g_i.Phases[-1])
```

# Appendix H -  Sample scripts - PLAXIS 3D Output
The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 3D Input application. In these examples, the PLAXIS 3D Output application will be opened from Input and connecting to the remote scripting server for Output will provide us with two additional objects, "s_o" and "g_o". The Input commands can be accessed from the "g_i" object and similarly, the Output commands can be accessed from the "g_o" object.

---

The following sample scripts cover some of the code samples provided in *Appendix H - Python HTTP REST API wrapper* of the PLAXIS reference manual

---

### Sample Input models

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create a line load
    with dynamic multiplier
    """
    s_i.new()
    g_i.SoilContour.initializerectangular(0, 0, 10, 10)
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    g_i.gotostructures()
    g_i.lineload((3, 5, 0), (7, 5, 0))
    lineload_g = g_i.LineLoads[-1]
    loadmultiplier_g = g_i.loadmultiplier()
    loadmultiplier_g.setproperties("Amplitude", 5, "Frequency", 2)
    
    lineload_g.LineLoad.qz_start = -100
    lineload_g.LineLoad.Multiplierz = loadmultiplier_g


def simple_test_case(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create geometry features and generate the mesh
    """
    create_geometry(s_i, g_i)
    
    g_i.gotomesh()
    g_i.mesh(0.1)
    
    output_port = g_i.viewmesh()
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g

def simple_pile_foundation(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, assign a test material to soil, create polygon-volume pile, 
    assign a test material to the pile and a line load on it
    """
    s_i.new()
    
    # Creates a borehole, soillayer, assigns material to the soil, creates a pile and assigns the material, and creates line load
    g_i.SoilContour.initializerectangular(0, 0, 10, 10)
    g_i.borehole(0, 0)
    g_i.soillayer(10)
    soil_material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = soil_material
    g_i.gotostructures()
    polygon = g_i.surface(4.8, 4.8, 0, 4.8, 5.2, 0, 5.2, 5.2, 0, 5.2, 4.8, 0)
    g_i.extrude(polygon, 0, 0, -5)
    
    pile_material = g_i.soilmat("Identification", "Concrete", "SoilModel", "Linear elastic", 
                         "DrainageType", "Non-porous", "gammaUnsat", 25, "Eref", 20E6)
    g_i.Volumes[0].Soil.Material = pile_material
    g_i.surfload(polygon)
    surfload_g = g_i.SurfaceLoads[-1]    
    surfload_g.sigz = -100
    
    # Generates the mesh, defines the phases, sets material of pile to Concrete and activates the line load
    g_i.gotomesh()
    g_i.mesh(0.2)

    g_i.gotostages()
    phase0_s = g_i.InitialPhase
    phase1_s = g_i.phase(phase0_s)
    g_i.setcurrentphase(phase1_s)
    g_i.SurfaceLoads[-1].Active[phase1_s] = True
    g_i.Volumes[0].Soil.Material[phase1_s] = pile_material
    g_i.calculate()
    
    # Opens Output to view results
    output_port = g_i.view(phase1_s)
    s, g = new_server('localhost', port=output_port, password=s_i.connection._password)
    
    return s, g
```

---

### Compute a derived result from existing result types

---

```python
from math import atan2

s_o, g_o = simple_test_case(s_i, g_i)

# Changes the mode and define phases
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

# Activate all geometry
g_i.Geometry.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

# Main code
last_phase = g_o.Phases[-1]
ux = g_o.getresults(last_phase, g_o.ResultTypes.Soil.Ux, 'node')
uy = g_o.getresults(last_phase, g_o.ResultTypes.Soil.Uy, 'node')
displacement_angles = [atan2(y, x) for x, y in zip(ux, uy)]
print(displacement_angles)
```

---

### Find the local maximum displacement from existing result types

---

```python
import math

s_o, g_o = simple_test_case(s_i, g_i)

# Define phases in Staged construction
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

# Activate all geometry
g_i.Geometry.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

# Main code
step = 0.1
last_phase = g_o.Phases[-1]
result_type = g_o.ResultTypes.Soil.Utot

def get_displacement(coordinate):
    result = g_o.getsingleresult(last_phase, result_type, *coordinate)
    if result == 'not found':
        return float('nan')
    else:
        return float(result)

# Use simple hill climbing to get to the coordinate with the highest displacement.
def get_walk_direction(coordinate, utot):
    coordinate_dx = (coordinate[0] + step, coordinate[1], coordinate[2])
    result_dx = get_displacement(coordinate_dx)
    if math.isnan(result_dx):
        return (0.0, 0.0, True)
    
    coordinate_dy = (coordinate[0], coordinate[1] + step, coordinate[2])
    result_dy = get_displacement(coordinate_dy)
    if math.isnan(result_dy):
        return (0.0, 0.0, True)
    return (result_dx, result_dy, False)

max_utot = 0.0
coordinate_at_max = (0.0, 0.0, 0.0)
coordinate = (0.0, 0.0, 0.0)
done = False

while not done:
    utot = get_displacement(coordinate)
    if math.isnan(utot):
        break
    max_utot = max(utot, max_utot)
    coordinate_at_max = coordinate
    dutot_dx, dutot_dy, done = get_walk_direction(coordinate, utot)

    # Get new coordinate with sign of partial derivatives.
    coordinate = (coordinate[0] + math.copysign(step, dutot_dx), coordinate[1] + math.copysign(step, dutot_dy), coordinate[2])

    unit_length = g_o.GeneralInfo.UnitLength
    print("Found coordinate ({0} {4}, {1} {4}, {2} {4}). " "With a displacement of: {3} {4}".format(coordinate_at_max[0], coordinate_at_max[1], coordinate_at_max[2], max_utot, unit_length))
```

---

### Receive an image in the scripting layer created by Output

---

```python
# File will be exported by default to the same directory where the current jupyter notebook is located on disk
s_o, g_o = simple_test_case(s_i, g_i)

# Define phases in Staged construction
g_i.gotostages()
phase0_s = g_i.InitialPhase
phase1_s = g_i.phase(phase0_s)

# Activate all geometry
g_i.Geometry.activate(phase1_s)

g_i.calculate()
g_i.view(phase1_s)

# Main code
newest_plot = g_o.Plots[-1]
newest_plot.ResultType = g_o.ResultTypes.Soil.Utot
newest_plot.PlotType = 'shadings'
newest_plot.Phase = g_o.Phases[-1]
#image_wrapper is an object that can save the created
#image or, if Pillow is installed, you can get the internal
#Pillow.Image object and use that.
image_wrapper = newest_plot.export(1600, 1200)
try:
    from PIL import ImageFilter
    pil_image = image_wrapper.image
    new_image = pil_image.filter(ImageFilter.DETAIL)
    new_image.save("test.png")
except ImportError:
    #Just save if we don't have Pillow
    image_wrapper.save("test.png")
```

---

### Retrieve the results for the Structural forces in volume piles

---

```python
# Workflow for retrieving results for a centerline in Structural forces in volume piles tool
s_o, g_o = simple_pile_foundation(s_i, g_i)

# Material assigned to the pile
material = g_o.Concrete

# Generate the structural forces on volume plates plot
str_forces_plot = g_o.structuralforcesinvolumepilesplot(g_o.Plots[-1]) 

# Configuration of centerline for clusters with material

#~ centerlinecriteriaobject_o = g_o.centerlineconfig(material)  # configuration for all clusters with material
centerlinecriteriaobject_o = g_o.centerlineconfig(material, g_o.BoreholeVolume_1_Volume_1_1)  # configuration for specific cluster with material
#~ centerlinecriteriaobject_o = g_o.centerlineconfig(material, g_o.Soil_2_5, g_o.Soil_2_7)  # configuration for multiple clusters with material
#~ centerline = g_o.centerline(5, 0, 5, -5)  # create custom centerline from coordinates

#  Symmetry configuration for centerline - defaults to False
#~ centerlinecriteriaobject_o.xmin_symmetry = False
#~ centerlinecriteriaobject_o.xmax_symmetry = False
#~ centerlinecriteriaobject_o.ymin_symmetry = False
#~ centerlinecriteriaobject_o.ymax_symmetry = False

# Generate centerlines for a specific phase
g_o.generate(g_o.Phases[-1], centerlinecriteriaobject_o)  

# Adds configuration to plot object
g_o.add(g_o.Plots[-1], g_o.CenterLines[-1])  
#~ for centerline in g_o.CenterLines[:]:  # for-loop to add multiple centerlines to plot    
    #~ g_o.add(str_forces_plot, centerline)

# Retrieve various results
n_3d = g_o.getresults(g_o.CenterLines[-1], g_o.Phases[-1], g_o.ResultTypes.CenterLine.N)  # retrieves result for axial forces
print(f'Maximum axial force is {max(n_3d)}.')
q13_3d = g_o.getresults(g_o.CenterLines[-1], g_o.Phases[-1], g_o.ResultTypes.CenterLine.Q13)  # retrieves result for shear forces
print(f'Minimum shear force is {min(q13_3d)}.')
m2_3d = g_o.getresults(g_o.CenterLines[-1], g_o.Phases[-1], g_o.ResultTypes.CenterLine.M2)  # retrieves result for bending moments
for bm in m2_3d:
    print(bm)

# Change the result type of the plot object to various results
str_forces_plot.ResultType =  g_o.ResultTypes.CenterLine.N  # changes visualisation plot to axial forces
str_forces_plot.ResultType =  g_o.ResultTypes.CenterLine.Q13  # changes visualisation plot to shear forces
str_forces_plot.ResultType =  g_o.ResultTypes.CenterLine.M2  # changes visualisation plot to bending moments
```

# Python wrapper commands [GET_EQUIVALENT]

---

The remote scripting server in PLAXIS 3D Input should be activated before starting the session. This notebook has two available objects, the "s_i" object which represents the application server and the "g_i" object which represents the global environment for the PLAXIS 2D Input application.

---

## _plx_type
Attribute that identifies the type of any PLAXIS object, e.g., point, load, etc..
Returns a string with the object type.

---

```python
from plxscripting.easy import *

def create_geometry(s_i, g_i):
    """
    Takes the plaxis variables s_i, g_i and performs a series of operations
    to create a soil layer, a plate on a line
    and add negative and positive interfaces in Structures mode
    """
    s_i.new()
    g_i.borehole(0, 0)
    g_i.soillayer(5)
    material = g_i.soilmat("Identification", "Sand", "SoilModel", "Linear elastic", 
                         "gammaUnsat", 17, "gammaSat", 20, "Eref", 4000)
    g_i.Soils[0].Material = material
    
    g_i.gotostructures()
    material_i = g_i.platemat("Identification", "Foundation", "MaterialType", "Elastic", "Gamma", 25, "d", 0.05, "E1", 5000000, "StructNu12", 0.2)
    surface_g = g_i.surface((5, 3, 0), (5, 5, 0), (5, 5, -5), (5, 3, -5))
    g_i.plate(surface_g, "Material", material_i)
    g_i.neginterface(surface_g)
    g_i.posinterface(surface_g)
```

---

```python
# Create the geometry 
create_geometry(s_i, g_i)

# Querying the type of the negative interface in Structure mode
print(g_i.Interfaces[0]._plx_type)  # should be NegativeInterface

# Switch to Flow conditions (or Staged construction) and use the _plx_type attribute to identify the negative interface
g_i.gotoflow()
print(g_i.Interfaces[0]._plx_type)  # should be staged.NegativeInterface

g_i.phase(g_i.Phases[-1])
g_i.setcurrentphase(g_i.Phases[-1])

# Function to find the requested user feature and return it
def getplxUF(obj, uftype):
    plxobj = None
    for uf in obj.UserFeatures.value[:]:
        if uf._plx_type == uftype:
            plxobj = uf
            break
    return plxobj

neg_interface = getplxUF(g_i.Plates[-1].Parent, 'staged.NegativeInterface')
print(neg_interface.Name)

# Switch only the negative interface to True, in Phase_1
neg_interface.ActiveInFlow[g_i.Phases[-1]] = True
```

